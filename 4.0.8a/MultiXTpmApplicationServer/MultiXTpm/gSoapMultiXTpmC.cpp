/* gSoapMultiXTpmC.cpp
   Generated by gSOAP 2.7.10 from gSoapMultiXTpmwsdl.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "gSoapMultiXTpmH.h"

SOAP_SOURCE_STAMP("@(#) gSoapMultiXTpmC.cpp ver 2.7.10 2008-09-01 10:12:34 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_MultiXTpm__ProcessControlStatus:
		return soap_in_MultiXTpm__ProcessControlStatus(soap, NULL, NULL, "MultiXTpm:ProcessControlStatus");
	case SOAP_TYPE_MultiXTpm__SSL_USCOREAPI:
		return soap_in_MultiXTpm__SSL_USCOREAPI(soap, NULL, NULL, "MultiXTpm:SSL_API");
	case SOAP_TYPE_MultiXTpm__MultiXOpenMode:
		return soap_in_MultiXTpm__MultiXOpenMode(soap, NULL, NULL, "MultiXTpm:MultiXOpenMode");
	case SOAP_TYPE_MultiXTpm__MultiXLinkType:
		return soap_in_MultiXTpm__MultiXLinkType(soap, NULL, NULL, "MultiXTpm:MultiXLinkType");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_MultiXTpm__ArrayOfInt1:
		return soap_in_MultiXTpm__ArrayOfInt1(soap, NULL, NULL, "MultiXTpm:ArrayOfInt1");
	case SOAP_TYPE_MultiXTpm__ProcessStatus:
		return soap_in_MultiXTpm__ProcessStatus(soap, NULL, NULL, "MultiXTpm:ProcessStatus");
	case SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus:
		return soap_in_MultiXTpm__ArrayOfProcessStatus(soap, NULL, NULL, "MultiXTpm:ArrayOfProcessStatus");
	case SOAP_TYPE_MultiXTpm__GroupStatus:
		return soap_in_MultiXTpm__GroupStatus(soap, NULL, NULL, "MultiXTpm:GroupStatus");
	case SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus:
		return soap_in_MultiXTpm__ArrayOfGroupStatus(soap, NULL, NULL, "MultiXTpm:ArrayOfGroupStatus");
	case SOAP_TYPE_MultiXTpm__SystemStatus:
		return soap_in_MultiXTpm__SystemStatus(soap, NULL, NULL, "MultiXTpm:SystemStatus");
	case SOAP_TYPE_MultiXTpm__GroupForwardFlags:
		return soap_in_MultiXTpm__GroupForwardFlags(soap, NULL, NULL, "MultiXTpm:GroupForwardFlags");
	case SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags:
		return soap_in_MultiXTpm__ArrayOfGroupForwardFlags(soap, NULL, NULL, "MultiXTpm:ArrayOfGroupForwardFlags");
	case SOAP_TYPE_MultiXTpm__Message:
		return soap_in_MultiXTpm__Message(soap, NULL, NULL, "MultiXTpm:Message");
	case SOAP_TYPE_MultiXTpm__ArrayOfMessage:
		return soap_in_MultiXTpm__ArrayOfMessage(soap, NULL, NULL, "MultiXTpm:ArrayOfMessage");
	case SOAP_TYPE_MultiXTpm__Group:
		return soap_in_MultiXTpm__Group(soap, NULL, NULL, "MultiXTpm:Group");
	case SOAP_TYPE_MultiXTpm__ArrayOfGroup:
		return soap_in_MultiXTpm__ArrayOfGroup(soap, NULL, NULL, "MultiXTpm:ArrayOfGroup");
	case SOAP_TYPE_MultiXTpm__SSLParams:
		return soap_in_MultiXTpm__SSLParams(soap, NULL, NULL, "MultiXTpm:SSLParams");
	case SOAP_TYPE_MultiXTpm__Link:
		return soap_in_MultiXTpm__Link(soap, NULL, NULL, "MultiXTpm:Link");
	case SOAP_TYPE_MultiXTpm__ArrayOfLink:
		return soap_in_MultiXTpm__ArrayOfLink(soap, NULL, NULL, "MultiXTpm:ArrayOfLink");
	case SOAP_TYPE_MultiXTpm__ArrayOfInt:
		return soap_in_MultiXTpm__ArrayOfInt(soap, NULL, NULL, "MultiXTpm:ArrayOfInt");
	case SOAP_TYPE_MultiXTpm__Param:
		return soap_in_MultiXTpm__Param(soap, NULL, NULL, "MultiXTpm:Param");
	case SOAP_TYPE_MultiXTpm__ArrayOfParam:
		return soap_in_MultiXTpm__ArrayOfParam(soap, NULL, NULL, "MultiXTpm:ArrayOfParam");
	case SOAP_TYPE_MultiXTpm__ProcessClass:
		return soap_in_MultiXTpm__ProcessClass(soap, NULL, NULL, "MultiXTpm:ProcessClass");
	case SOAP_TYPE_MultiXTpm__ArrayOfProcessClass:
		return soap_in_MultiXTpm__ArrayOfProcessClass(soap, NULL, NULL, "MultiXTpm:ArrayOfProcessClass");
	case SOAP_TYPE_MultiXTpm__UserPermission:
		return soap_in_MultiXTpm__UserPermission(soap, NULL, NULL, "MultiXTpm:UserPermission");
	case SOAP_TYPE_MultiXTpm__ArrayOfUserPermission:
		return soap_in_MultiXTpm__ArrayOfUserPermission(soap, NULL, NULL, "MultiXTpm:ArrayOfUserPermission");
	case SOAP_TYPE_MultiXTpm__ConfigData:
		return soap_in_MultiXTpm__ConfigData(soap, NULL, NULL, "MultiXTpm:ConfigData");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeAllResponse:
		return soap_in_PointerTo_MultiXTpm__ResumeAllResponse(soap, NULL, NULL, "MultiXTpm:ResumeAllResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeAll:
		return soap_in_PointerTo_MultiXTpm__ResumeAll(soap, NULL, NULL, "MultiXTpm:ResumeAll");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendAllResponse:
		return soap_in_PointerTo_MultiXTpm__SuspendAllResponse(soap, NULL, NULL, "MultiXTpm:SuspendAllResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendAll:
		return soap_in_PointerTo_MultiXTpm__SuspendAll(soap, NULL, NULL, "MultiXTpm:SuspendAll");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownAllResponse:
		return soap_in_PointerTo_MultiXTpm__ShutdownAllResponse(soap, NULL, NULL, "MultiXTpm:ShutdownAllResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownAll:
		return soap_in_PointerTo_MultiXTpm__ShutdownAll(soap, NULL, NULL, "MultiXTpm:ShutdownAll");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartAllResponse:
		return soap_in_PointerTo_MultiXTpm__StartAllResponse(soap, NULL, NULL, "MultiXTpm:StartAllResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartAll:
		return soap_in_PointerTo_MultiXTpm__StartAll(soap, NULL, NULL, "MultiXTpm:StartAll");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartAllResponse:
		return soap_in_PointerTo_MultiXTpm__RestartAllResponse(soap, NULL, NULL, "MultiXTpm:RestartAllResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartAll:
		return soap_in_PointerTo_MultiXTpm__RestartAll(soap, NULL, NULL, "MultiXTpm:RestartAll");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeProcessResponse:
		return soap_in_PointerTo_MultiXTpm__ResumeProcessResponse(soap, NULL, NULL, "MultiXTpm:ResumeProcessResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeProcess:
		return soap_in_PointerTo_MultiXTpm__ResumeProcess(soap, NULL, NULL, "MultiXTpm:ResumeProcess");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeGroupResponse:
		return soap_in_PointerTo_MultiXTpm__ResumeGroupResponse(soap, NULL, NULL, "MultiXTpm:ResumeGroupResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeGroup:
		return soap_in_PointerTo_MultiXTpm__ResumeGroup(soap, NULL, NULL, "MultiXTpm:ResumeGroup");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendProcessResponse:
		return soap_in_PointerTo_MultiXTpm__SuspendProcessResponse(soap, NULL, NULL, "MultiXTpm:SuspendProcessResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendProcess:
		return soap_in_PointerTo_MultiXTpm__SuspendProcess(soap, NULL, NULL, "MultiXTpm:SuspendProcess");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendGroupResponse:
		return soap_in_PointerTo_MultiXTpm__SuspendGroupResponse(soap, NULL, NULL, "MultiXTpm:SuspendGroupResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendGroup:
		return soap_in_PointerTo_MultiXTpm__SuspendGroup(soap, NULL, NULL, "MultiXTpm:SuspendGroup");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownGroupResponse:
		return soap_in_PointerTo_MultiXTpm__ShutdownGroupResponse(soap, NULL, NULL, "MultiXTpm:ShutdownGroupResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownGroup:
		return soap_in_PointerTo_MultiXTpm__ShutdownGroup(soap, NULL, NULL, "MultiXTpm:ShutdownGroup");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownProcessResponse:
		return soap_in_PointerTo_MultiXTpm__ShutdownProcessResponse(soap, NULL, NULL, "MultiXTpm:ShutdownProcessResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownProcess:
		return soap_in_PointerTo_MultiXTpm__ShutdownProcess(soap, NULL, NULL, "MultiXTpm:ShutdownProcess");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartGroupResponse:
		return soap_in_PointerTo_MultiXTpm__StartGroupResponse(soap, NULL, NULL, "MultiXTpm:StartGroupResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartGroup:
		return soap_in_PointerTo_MultiXTpm__StartGroup(soap, NULL, NULL, "MultiXTpm:StartGroup");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartProcessResponse:
		return soap_in_PointerTo_MultiXTpm__StartProcessResponse(soap, NULL, NULL, "MultiXTpm:StartProcessResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartProcess:
		return soap_in_PointerTo_MultiXTpm__StartProcess(soap, NULL, NULL, "MultiXTpm:StartProcess");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartGroupResponse:
		return soap_in_PointerTo_MultiXTpm__RestartGroupResponse(soap, NULL, NULL, "MultiXTpm:RestartGroupResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartGroup:
		return soap_in_PointerTo_MultiXTpm__RestartGroup(soap, NULL, NULL, "MultiXTpm:RestartGroup");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartProcessResponse:
		return soap_in_PointerTo_MultiXTpm__RestartProcessResponse(soap, NULL, NULL, "MultiXTpm:RestartProcessResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartProcess:
		return soap_in_PointerTo_MultiXTpm__RestartProcess(soap, NULL, NULL, "MultiXTpm:RestartProcess");
	case SOAP_TYPE_PointerTo_MultiXTpm__GetSystemStatusResponse:
		return soap_in_PointerTo_MultiXTpm__GetSystemStatusResponse(soap, NULL, NULL, "MultiXTpm:GetSystemStatusResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__GetSystemStatus:
		return soap_in_PointerTo_MultiXTpm__GetSystemStatus(soap, NULL, NULL, "MultiXTpm:GetSystemStatus");
	case SOAP_TYPE_PointerTo_MultiXTpm__UpdateConfigResponse:
		return soap_in_PointerTo_MultiXTpm__UpdateConfigResponse(soap, NULL, NULL, "MultiXTpm:UpdateConfigResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__UpdateConfig:
		return soap_in_PointerTo_MultiXTpm__UpdateConfig(soap, NULL, NULL, "MultiXTpm:UpdateConfig");
	case SOAP_TYPE_PointerTo_MultiXTpm__GetConfigResponse:
		return soap_in_PointerTo_MultiXTpm__GetConfigResponse(soap, NULL, NULL, "MultiXTpm:GetConfigResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__GetConfig:
		return soap_in_PointerTo_MultiXTpm__GetConfig(soap, NULL, NULL, "MultiXTpm:GetConfig");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfInt1:
		return soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, NULL, NULL, "MultiXTpm:ArrayOfInt1");
	case SOAP_TYPE_PointerToMultiXTpm__SystemStatus:
		return soap_in_PointerToMultiXTpm__SystemStatus(soap, NULL, NULL, "MultiXTpm:SystemStatus");
	case SOAP_TYPE_PointerToMultiXTpm__ConfigData:
		return soap_in_PointerToMultiXTpm__ConfigData(soap, NULL, NULL, "MultiXTpm:ConfigData");
	case SOAP_TYPE_PointerToMultiXTpm__ProcessStatus:
		return soap_in_PointerToMultiXTpm__ProcessStatus(soap, NULL, NULL, "MultiXTpm:ProcessStatus");
	case SOAP_TYPE_PointerToMultiXTpm__GroupStatus:
		return soap_in_PointerToMultiXTpm__GroupStatus(soap, NULL, NULL, "MultiXTpm:GroupStatus");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfProcessStatus:
		return soap_in_PointerToMultiXTpm__ArrayOfProcessStatus(soap, NULL, NULL, "MultiXTpm:ArrayOfProcessStatus");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroupStatus:
		return soap_in_PointerToMultiXTpm__ArrayOfGroupStatus(soap, NULL, NULL, "MultiXTpm:ArrayOfGroupStatus");
	case SOAP_TYPE_PointerToMultiXTpm__GroupForwardFlags:
		return soap_in_PointerToMultiXTpm__GroupForwardFlags(soap, NULL, NULL, "MultiXTpm:GroupForwardFlags");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroupForwardFlags:
		return soap_in_PointerToMultiXTpm__ArrayOfGroupForwardFlags(soap, NULL, NULL, "MultiXTpm:ArrayOfGroupForwardFlags");
	case SOAP_TYPE_PointerToMultiXTpm__Message:
		return soap_in_PointerToMultiXTpm__Message(soap, NULL, NULL, "MultiXTpm:Message");
	case SOAP_TYPE_PointerToMultiXTpm__Group:
		return soap_in_PointerToMultiXTpm__Group(soap, NULL, NULL, "MultiXTpm:Group");
	case SOAP_TYPE_PointerToMultiXTpm__SSLParams:
		return soap_in_PointerToMultiXTpm__SSLParams(soap, NULL, NULL, "MultiXTpm:SSLParams");
	case SOAP_TYPE_PointerToMultiXTpm__Link:
		return soap_in_PointerToMultiXTpm__Link(soap, NULL, NULL, "MultiXTpm:Link");
	case SOAP_TYPE_PointerTo_MultiXTpm__Param_XmlParamValue:
		return soap_in_PointerTo_MultiXTpm__Param_XmlParamValue(soap, NULL, NULL, "MultiXTpm:Param-XmlParamValue");
	case SOAP_TYPE_PointerToMultiXTpm__Param:
		return soap_in_PointerToMultiXTpm__Param(soap, NULL, NULL, "MultiXTpm:Param");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfInt:
		return soap_in_PointerToMultiXTpm__ArrayOfInt(soap, NULL, NULL, "MultiXTpm:ArrayOfInt");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfParam:
		return soap_in_PointerToMultiXTpm__ArrayOfParam(soap, NULL, NULL, "MultiXTpm:ArrayOfParam");
	case SOAP_TYPE_PointerToMultiXTpm__ProcessClass:
		return soap_in_PointerToMultiXTpm__ProcessClass(soap, NULL, NULL, "MultiXTpm:ProcessClass");
	case SOAP_TYPE_PointerToMultiXTpm__UserPermission:
		return soap_in_PointerToMultiXTpm__UserPermission(soap, NULL, NULL, "MultiXTpm:UserPermission");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfUserPermission:
		return soap_in_PointerToMultiXTpm__ArrayOfUserPermission(soap, NULL, NULL, "MultiXTpm:ArrayOfUserPermission");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfMessage:
		return soap_in_PointerToMultiXTpm__ArrayOfMessage(soap, NULL, NULL, "MultiXTpm:ArrayOfMessage");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroup:
		return soap_in_PointerToMultiXTpm__ArrayOfGroup(soap, NULL, NULL, "MultiXTpm:ArrayOfGroup");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfLink:
		return soap_in_PointerToMultiXTpm__ArrayOfLink(soap, NULL, NULL, "MultiXTpm:ArrayOfLink");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfProcessClass:
		return soap_in_PointerToMultiXTpm__ArrayOfProcessClass(soap, NULL, NULL, "MultiXTpm:ArrayOfProcessClass");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfInt1"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfInt1;
			return soap_in_MultiXTpm__ArrayOfInt1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ProcessStatus"))
		{	*type = SOAP_TYPE_MultiXTpm__ProcessStatus;
			return soap_in_MultiXTpm__ProcessStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfProcessStatus"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus;
			return soap_in_MultiXTpm__ArrayOfProcessStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:GroupStatus"))
		{	*type = SOAP_TYPE_MultiXTpm__GroupStatus;
			return soap_in_MultiXTpm__GroupStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfGroupStatus"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus;
			return soap_in_MultiXTpm__ArrayOfGroupStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:SystemStatus"))
		{	*type = SOAP_TYPE_MultiXTpm__SystemStatus;
			return soap_in_MultiXTpm__SystemStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:GroupForwardFlags"))
		{	*type = SOAP_TYPE_MultiXTpm__GroupForwardFlags;
			return soap_in_MultiXTpm__GroupForwardFlags(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfGroupForwardFlags"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags;
			return soap_in_MultiXTpm__ArrayOfGroupForwardFlags(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:Message"))
		{	*type = SOAP_TYPE_MultiXTpm__Message;
			return soap_in_MultiXTpm__Message(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfMessage"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfMessage;
			return soap_in_MultiXTpm__ArrayOfMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:Group"))
		{	*type = SOAP_TYPE_MultiXTpm__Group;
			return soap_in_MultiXTpm__Group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfGroup"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfGroup;
			return soap_in_MultiXTpm__ArrayOfGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:SSLParams"))
		{	*type = SOAP_TYPE_MultiXTpm__SSLParams;
			return soap_in_MultiXTpm__SSLParams(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:Link"))
		{	*type = SOAP_TYPE_MultiXTpm__Link;
			return soap_in_MultiXTpm__Link(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfLink"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfLink;
			return soap_in_MultiXTpm__ArrayOfLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfInt"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfInt;
			return soap_in_MultiXTpm__ArrayOfInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:Param"))
		{	*type = SOAP_TYPE_MultiXTpm__Param;
			return soap_in_MultiXTpm__Param(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfParam"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfParam;
			return soap_in_MultiXTpm__ArrayOfParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ProcessClass"))
		{	*type = SOAP_TYPE_MultiXTpm__ProcessClass;
			return soap_in_MultiXTpm__ProcessClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfProcessClass"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfProcessClass;
			return soap_in_MultiXTpm__ArrayOfProcessClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:UserPermission"))
		{	*type = SOAP_TYPE_MultiXTpm__UserPermission;
			return soap_in_MultiXTpm__UserPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ArrayOfUserPermission"))
		{	*type = SOAP_TYPE_MultiXTpm__ArrayOfUserPermission;
			return soap_in_MultiXTpm__ArrayOfUserPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ConfigData"))
		{	*type = SOAP_TYPE_MultiXTpm__ConfigData;
			return soap_in_MultiXTpm__ConfigData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ProcessControlStatus"))
		{	*type = SOAP_TYPE_MultiXTpm__ProcessControlStatus;
			return soap_in_MultiXTpm__ProcessControlStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:SSL_API"))
		{	*type = SOAP_TYPE_MultiXTpm__SSL_USCOREAPI;
			return soap_in_MultiXTpm__SSL_USCOREAPI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:MultiXOpenMode"))
		{	*type = SOAP_TYPE_MultiXTpm__MultiXOpenMode;
			return soap_in_MultiXTpm__MultiXOpenMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:MultiXLinkType"))
		{	*type = SOAP_TYPE_MultiXTpm__MultiXLinkType;
			return soap_in_MultiXTpm__MultiXLinkType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "MultiXTpm:Param-XmlParamValue"))
		{	*type = SOAP_TYPE__MultiXTpm__Param_XmlParamValue;
			return soap_in__MultiXTpm__Param_XmlParamValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ResumeAllResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__ResumeAllResponse;
			return soap_in__MultiXTpm__ResumeAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ResumeAll"))
		{	*type = SOAP_TYPE__MultiXTpm__ResumeAll;
			return soap_in__MultiXTpm__ResumeAll(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:SuspendAllResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__SuspendAllResponse;
			return soap_in__MultiXTpm__SuspendAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:SuspendAll"))
		{	*type = SOAP_TYPE__MultiXTpm__SuspendAll;
			return soap_in__MultiXTpm__SuspendAll(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ShutdownAllResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__ShutdownAllResponse;
			return soap_in__MultiXTpm__ShutdownAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ShutdownAll"))
		{	*type = SOAP_TYPE__MultiXTpm__ShutdownAll;
			return soap_in__MultiXTpm__ShutdownAll(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:StartAllResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__StartAllResponse;
			return soap_in__MultiXTpm__StartAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:StartAll"))
		{	*type = SOAP_TYPE__MultiXTpm__StartAll;
			return soap_in__MultiXTpm__StartAll(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:RestartAllResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__RestartAllResponse;
			return soap_in__MultiXTpm__RestartAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:RestartAll"))
		{	*type = SOAP_TYPE__MultiXTpm__RestartAll;
			return soap_in__MultiXTpm__RestartAll(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ResumeProcessResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__ResumeProcessResponse;
			return soap_in__MultiXTpm__ResumeProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ResumeProcess"))
		{	*type = SOAP_TYPE__MultiXTpm__ResumeProcess;
			return soap_in__MultiXTpm__ResumeProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ResumeGroupResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__ResumeGroupResponse;
			return soap_in__MultiXTpm__ResumeGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ResumeGroup"))
		{	*type = SOAP_TYPE__MultiXTpm__ResumeGroup;
			return soap_in__MultiXTpm__ResumeGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:SuspendProcessResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__SuspendProcessResponse;
			return soap_in__MultiXTpm__SuspendProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:SuspendProcess"))
		{	*type = SOAP_TYPE__MultiXTpm__SuspendProcess;
			return soap_in__MultiXTpm__SuspendProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:SuspendGroupResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__SuspendGroupResponse;
			return soap_in__MultiXTpm__SuspendGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:SuspendGroup"))
		{	*type = SOAP_TYPE__MultiXTpm__SuspendGroup;
			return soap_in__MultiXTpm__SuspendGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ShutdownGroupResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__ShutdownGroupResponse;
			return soap_in__MultiXTpm__ShutdownGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ShutdownGroup"))
		{	*type = SOAP_TYPE__MultiXTpm__ShutdownGroup;
			return soap_in__MultiXTpm__ShutdownGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ShutdownProcessResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__ShutdownProcessResponse;
			return soap_in__MultiXTpm__ShutdownProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:ShutdownProcess"))
		{	*type = SOAP_TYPE__MultiXTpm__ShutdownProcess;
			return soap_in__MultiXTpm__ShutdownProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:StartGroupResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__StartGroupResponse;
			return soap_in__MultiXTpm__StartGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:StartGroup"))
		{	*type = SOAP_TYPE__MultiXTpm__StartGroup;
			return soap_in__MultiXTpm__StartGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:StartProcessResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__StartProcessResponse;
			return soap_in__MultiXTpm__StartProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:StartProcess"))
		{	*type = SOAP_TYPE__MultiXTpm__StartProcess;
			return soap_in__MultiXTpm__StartProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:RestartGroupResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__RestartGroupResponse;
			return soap_in__MultiXTpm__RestartGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:RestartGroup"))
		{	*type = SOAP_TYPE__MultiXTpm__RestartGroup;
			return soap_in__MultiXTpm__RestartGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:RestartProcessResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__RestartProcessResponse;
			return soap_in__MultiXTpm__RestartProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:RestartProcess"))
		{	*type = SOAP_TYPE__MultiXTpm__RestartProcess;
			return soap_in__MultiXTpm__RestartProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:GetSystemStatusResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__GetSystemStatusResponse;
			return soap_in__MultiXTpm__GetSystemStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:GetSystemStatus"))
		{	*type = SOAP_TYPE__MultiXTpm__GetSystemStatus;
			return soap_in__MultiXTpm__GetSystemStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:UpdateConfigResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__UpdateConfigResponse;
			return soap_in__MultiXTpm__UpdateConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:UpdateConfig"))
		{	*type = SOAP_TYPE__MultiXTpm__UpdateConfig;
			return soap_in__MultiXTpm__UpdateConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:GetConfigResponse"))
		{	*type = SOAP_TYPE__MultiXTpm__GetConfigResponse;
			return soap_in__MultiXTpm__GetConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "MultiXTpm:GetConfig"))
		{	*type = SOAP_TYPE__MultiXTpm__GetConfig;
			return soap_in__MultiXTpm__GetConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_MultiXTpm__ProcessControlStatus:
		return soap_out_MultiXTpm__ProcessControlStatus(soap, tag, id, (const enum MultiXTpm__ProcessControlStatus *)ptr, "MultiXTpm:ProcessControlStatus");
	case SOAP_TYPE_MultiXTpm__SSL_USCOREAPI:
		return soap_out_MultiXTpm__SSL_USCOREAPI(soap, tag, id, (const enum MultiXTpm__SSL_USCOREAPI *)ptr, "MultiXTpm:SSL_API");
	case SOAP_TYPE_MultiXTpm__MultiXOpenMode:
		return soap_out_MultiXTpm__MultiXOpenMode(soap, tag, id, (const enum MultiXTpm__MultiXOpenMode *)ptr, "MultiXTpm:MultiXOpenMode");
	case SOAP_TYPE_MultiXTpm__MultiXLinkType:
		return soap_out_MultiXTpm__MultiXLinkType(soap, tag, id, (const enum MultiXTpm__MultiXLinkType *)ptr, "MultiXTpm:MultiXLinkType");
	case SOAP_TYPE__MultiXTpm__Param_XmlParamValue:
		return ((_MultiXTpm__Param_XmlParamValue *)ptr)->soap_out(soap, "MultiXTpm:Param-XmlParamValue", id, NULL);
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__MultiXTpm__ResumeAllResponse:
		return ((_MultiXTpm__ResumeAllResponse *)ptr)->soap_out(soap, "MultiXTpm:ResumeAllResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__ResumeAll:
		return ((_MultiXTpm__ResumeAll *)ptr)->soap_out(soap, "MultiXTpm:ResumeAll", id, NULL);
	case SOAP_TYPE__MultiXTpm__SuspendAllResponse:
		return ((_MultiXTpm__SuspendAllResponse *)ptr)->soap_out(soap, "MultiXTpm:SuspendAllResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__SuspendAll:
		return ((_MultiXTpm__SuspendAll *)ptr)->soap_out(soap, "MultiXTpm:SuspendAll", id, NULL);
	case SOAP_TYPE__MultiXTpm__ShutdownAllResponse:
		return ((_MultiXTpm__ShutdownAllResponse *)ptr)->soap_out(soap, "MultiXTpm:ShutdownAllResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__ShutdownAll:
		return ((_MultiXTpm__ShutdownAll *)ptr)->soap_out(soap, "MultiXTpm:ShutdownAll", id, NULL);
	case SOAP_TYPE__MultiXTpm__StartAllResponse:
		return ((_MultiXTpm__StartAllResponse *)ptr)->soap_out(soap, "MultiXTpm:StartAllResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__StartAll:
		return ((_MultiXTpm__StartAll *)ptr)->soap_out(soap, "MultiXTpm:StartAll", id, NULL);
	case SOAP_TYPE__MultiXTpm__RestartAllResponse:
		return ((_MultiXTpm__RestartAllResponse *)ptr)->soap_out(soap, "MultiXTpm:RestartAllResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__RestartAll:
		return ((_MultiXTpm__RestartAll *)ptr)->soap_out(soap, "MultiXTpm:RestartAll", id, NULL);
	case SOAP_TYPE__MultiXTpm__ResumeProcessResponse:
		return ((_MultiXTpm__ResumeProcessResponse *)ptr)->soap_out(soap, "MultiXTpm:ResumeProcessResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__ResumeProcess:
		return ((_MultiXTpm__ResumeProcess *)ptr)->soap_out(soap, "MultiXTpm:ResumeProcess", id, NULL);
	case SOAP_TYPE__MultiXTpm__ResumeGroupResponse:
		return ((_MultiXTpm__ResumeGroupResponse *)ptr)->soap_out(soap, "MultiXTpm:ResumeGroupResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__ResumeGroup:
		return ((_MultiXTpm__ResumeGroup *)ptr)->soap_out(soap, "MultiXTpm:ResumeGroup", id, NULL);
	case SOAP_TYPE__MultiXTpm__SuspendProcessResponse:
		return ((_MultiXTpm__SuspendProcessResponse *)ptr)->soap_out(soap, "MultiXTpm:SuspendProcessResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__SuspendProcess:
		return ((_MultiXTpm__SuspendProcess *)ptr)->soap_out(soap, "MultiXTpm:SuspendProcess", id, NULL);
	case SOAP_TYPE__MultiXTpm__SuspendGroupResponse:
		return ((_MultiXTpm__SuspendGroupResponse *)ptr)->soap_out(soap, "MultiXTpm:SuspendGroupResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__SuspendGroup:
		return ((_MultiXTpm__SuspendGroup *)ptr)->soap_out(soap, "MultiXTpm:SuspendGroup", id, NULL);
	case SOAP_TYPE__MultiXTpm__ShutdownGroupResponse:
		return ((_MultiXTpm__ShutdownGroupResponse *)ptr)->soap_out(soap, "MultiXTpm:ShutdownGroupResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__ShutdownGroup:
		return ((_MultiXTpm__ShutdownGroup *)ptr)->soap_out(soap, "MultiXTpm:ShutdownGroup", id, NULL);
	case SOAP_TYPE__MultiXTpm__ShutdownProcessResponse:
		return ((_MultiXTpm__ShutdownProcessResponse *)ptr)->soap_out(soap, "MultiXTpm:ShutdownProcessResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__ShutdownProcess:
		return ((_MultiXTpm__ShutdownProcess *)ptr)->soap_out(soap, "MultiXTpm:ShutdownProcess", id, NULL);
	case SOAP_TYPE__MultiXTpm__StartGroupResponse:
		return ((_MultiXTpm__StartGroupResponse *)ptr)->soap_out(soap, "MultiXTpm:StartGroupResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__StartGroup:
		return ((_MultiXTpm__StartGroup *)ptr)->soap_out(soap, "MultiXTpm:StartGroup", id, NULL);
	case SOAP_TYPE__MultiXTpm__StartProcessResponse:
		return ((_MultiXTpm__StartProcessResponse *)ptr)->soap_out(soap, "MultiXTpm:StartProcessResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__StartProcess:
		return ((_MultiXTpm__StartProcess *)ptr)->soap_out(soap, "MultiXTpm:StartProcess", id, NULL);
	case SOAP_TYPE__MultiXTpm__RestartGroupResponse:
		return ((_MultiXTpm__RestartGroupResponse *)ptr)->soap_out(soap, "MultiXTpm:RestartGroupResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__RestartGroup:
		return ((_MultiXTpm__RestartGroup *)ptr)->soap_out(soap, "MultiXTpm:RestartGroup", id, NULL);
	case SOAP_TYPE__MultiXTpm__RestartProcessResponse:
		return ((_MultiXTpm__RestartProcessResponse *)ptr)->soap_out(soap, "MultiXTpm:RestartProcessResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__RestartProcess:
		return ((_MultiXTpm__RestartProcess *)ptr)->soap_out(soap, "MultiXTpm:RestartProcess", id, NULL);
	case SOAP_TYPE__MultiXTpm__GetSystemStatusResponse:
		return ((_MultiXTpm__GetSystemStatusResponse *)ptr)->soap_out(soap, "MultiXTpm:GetSystemStatusResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__GetSystemStatus:
		return ((_MultiXTpm__GetSystemStatus *)ptr)->soap_out(soap, "MultiXTpm:GetSystemStatus", id, NULL);
	case SOAP_TYPE__MultiXTpm__UpdateConfigResponse:
		return ((_MultiXTpm__UpdateConfigResponse *)ptr)->soap_out(soap, "MultiXTpm:UpdateConfigResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__UpdateConfig:
		return ((_MultiXTpm__UpdateConfig *)ptr)->soap_out(soap, "MultiXTpm:UpdateConfig", id, NULL);
	case SOAP_TYPE__MultiXTpm__GetConfigResponse:
		return ((_MultiXTpm__GetConfigResponse *)ptr)->soap_out(soap, "MultiXTpm:GetConfigResponse", id, NULL);
	case SOAP_TYPE__MultiXTpm__GetConfig:
		return ((_MultiXTpm__GetConfig *)ptr)->soap_out(soap, "MultiXTpm:GetConfig", id, NULL);
	case SOAP_TYPE_MultiXTpm__ArrayOfInt1:
		return ((MultiXTpm__ArrayOfInt1 *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfInt1");
	case SOAP_TYPE_MultiXTpm__ProcessStatus:
		return ((MultiXTpm__ProcessStatus *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ProcessStatus");
	case SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus:
		return ((MultiXTpm__ArrayOfProcessStatus *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfProcessStatus");
	case SOAP_TYPE_MultiXTpm__GroupStatus:
		return ((MultiXTpm__GroupStatus *)ptr)->soap_out(soap, tag, id, "MultiXTpm:GroupStatus");
	case SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus:
		return ((MultiXTpm__ArrayOfGroupStatus *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfGroupStatus");
	case SOAP_TYPE_MultiXTpm__SystemStatus:
		return ((MultiXTpm__SystemStatus *)ptr)->soap_out(soap, tag, id, "MultiXTpm:SystemStatus");
	case SOAP_TYPE_MultiXTpm__GroupForwardFlags:
		return ((MultiXTpm__GroupForwardFlags *)ptr)->soap_out(soap, tag, id, "MultiXTpm:GroupForwardFlags");
	case SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags:
		return ((MultiXTpm__ArrayOfGroupForwardFlags *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfGroupForwardFlags");
	case SOAP_TYPE_MultiXTpm__Message:
		return ((MultiXTpm__Message *)ptr)->soap_out(soap, tag, id, "MultiXTpm:Message");
	case SOAP_TYPE_MultiXTpm__ArrayOfMessage:
		return ((MultiXTpm__ArrayOfMessage *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfMessage");
	case SOAP_TYPE_MultiXTpm__Group:
		return ((MultiXTpm__Group *)ptr)->soap_out(soap, tag, id, "MultiXTpm:Group");
	case SOAP_TYPE_MultiXTpm__ArrayOfGroup:
		return ((MultiXTpm__ArrayOfGroup *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfGroup");
	case SOAP_TYPE_MultiXTpm__SSLParams:
		return ((MultiXTpm__SSLParams *)ptr)->soap_out(soap, tag, id, "MultiXTpm:SSLParams");
	case SOAP_TYPE_MultiXTpm__Link:
		return ((MultiXTpm__Link *)ptr)->soap_out(soap, tag, id, "MultiXTpm:Link");
	case SOAP_TYPE_MultiXTpm__ArrayOfLink:
		return ((MultiXTpm__ArrayOfLink *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfLink");
	case SOAP_TYPE_MultiXTpm__ArrayOfInt:
		return ((MultiXTpm__ArrayOfInt *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfInt");
	case SOAP_TYPE_MultiXTpm__Param:
		return ((MultiXTpm__Param *)ptr)->soap_out(soap, tag, id, "MultiXTpm:Param");
	case SOAP_TYPE_MultiXTpm__ArrayOfParam:
		return ((MultiXTpm__ArrayOfParam *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfParam");
	case SOAP_TYPE_MultiXTpm__ProcessClass:
		return ((MultiXTpm__ProcessClass *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ProcessClass");
	case SOAP_TYPE_MultiXTpm__ArrayOfProcessClass:
		return ((MultiXTpm__ArrayOfProcessClass *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfProcessClass");
	case SOAP_TYPE_MultiXTpm__UserPermission:
		return ((MultiXTpm__UserPermission *)ptr)->soap_out(soap, tag, id, "MultiXTpm:UserPermission");
	case SOAP_TYPE_MultiXTpm__ArrayOfUserPermission:
		return ((MultiXTpm__ArrayOfUserPermission *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ArrayOfUserPermission");
	case SOAP_TYPE_MultiXTpm__ConfigData:
		return ((MultiXTpm__ConfigData *)ptr)->soap_out(soap, tag, id, "MultiXTpm:ConfigData");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeAllResponse:
		return soap_out_PointerTo_MultiXTpm__ResumeAllResponse(soap, tag, id, (_MultiXTpm__ResumeAllResponse *const*)ptr, "MultiXTpm:ResumeAllResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeAll:
		return soap_out_PointerTo_MultiXTpm__ResumeAll(soap, tag, id, (_MultiXTpm__ResumeAll *const*)ptr, "MultiXTpm:ResumeAll");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendAllResponse:
		return soap_out_PointerTo_MultiXTpm__SuspendAllResponse(soap, tag, id, (_MultiXTpm__SuspendAllResponse *const*)ptr, "MultiXTpm:SuspendAllResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendAll:
		return soap_out_PointerTo_MultiXTpm__SuspendAll(soap, tag, id, (_MultiXTpm__SuspendAll *const*)ptr, "MultiXTpm:SuspendAll");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownAllResponse:
		return soap_out_PointerTo_MultiXTpm__ShutdownAllResponse(soap, tag, id, (_MultiXTpm__ShutdownAllResponse *const*)ptr, "MultiXTpm:ShutdownAllResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownAll:
		return soap_out_PointerTo_MultiXTpm__ShutdownAll(soap, tag, id, (_MultiXTpm__ShutdownAll *const*)ptr, "MultiXTpm:ShutdownAll");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartAllResponse:
		return soap_out_PointerTo_MultiXTpm__StartAllResponse(soap, tag, id, (_MultiXTpm__StartAllResponse *const*)ptr, "MultiXTpm:StartAllResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartAll:
		return soap_out_PointerTo_MultiXTpm__StartAll(soap, tag, id, (_MultiXTpm__StartAll *const*)ptr, "MultiXTpm:StartAll");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartAllResponse:
		return soap_out_PointerTo_MultiXTpm__RestartAllResponse(soap, tag, id, (_MultiXTpm__RestartAllResponse *const*)ptr, "MultiXTpm:RestartAllResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartAll:
		return soap_out_PointerTo_MultiXTpm__RestartAll(soap, tag, id, (_MultiXTpm__RestartAll *const*)ptr, "MultiXTpm:RestartAll");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeProcessResponse:
		return soap_out_PointerTo_MultiXTpm__ResumeProcessResponse(soap, tag, id, (_MultiXTpm__ResumeProcessResponse *const*)ptr, "MultiXTpm:ResumeProcessResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeProcess:
		return soap_out_PointerTo_MultiXTpm__ResumeProcess(soap, tag, id, (_MultiXTpm__ResumeProcess *const*)ptr, "MultiXTpm:ResumeProcess");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeGroupResponse:
		return soap_out_PointerTo_MultiXTpm__ResumeGroupResponse(soap, tag, id, (_MultiXTpm__ResumeGroupResponse *const*)ptr, "MultiXTpm:ResumeGroupResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeGroup:
		return soap_out_PointerTo_MultiXTpm__ResumeGroup(soap, tag, id, (_MultiXTpm__ResumeGroup *const*)ptr, "MultiXTpm:ResumeGroup");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendProcessResponse:
		return soap_out_PointerTo_MultiXTpm__SuspendProcessResponse(soap, tag, id, (_MultiXTpm__SuspendProcessResponse *const*)ptr, "MultiXTpm:SuspendProcessResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendProcess:
		return soap_out_PointerTo_MultiXTpm__SuspendProcess(soap, tag, id, (_MultiXTpm__SuspendProcess *const*)ptr, "MultiXTpm:SuspendProcess");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendGroupResponse:
		return soap_out_PointerTo_MultiXTpm__SuspendGroupResponse(soap, tag, id, (_MultiXTpm__SuspendGroupResponse *const*)ptr, "MultiXTpm:SuspendGroupResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendGroup:
		return soap_out_PointerTo_MultiXTpm__SuspendGroup(soap, tag, id, (_MultiXTpm__SuspendGroup *const*)ptr, "MultiXTpm:SuspendGroup");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownGroupResponse:
		return soap_out_PointerTo_MultiXTpm__ShutdownGroupResponse(soap, tag, id, (_MultiXTpm__ShutdownGroupResponse *const*)ptr, "MultiXTpm:ShutdownGroupResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownGroup:
		return soap_out_PointerTo_MultiXTpm__ShutdownGroup(soap, tag, id, (_MultiXTpm__ShutdownGroup *const*)ptr, "MultiXTpm:ShutdownGroup");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownProcessResponse:
		return soap_out_PointerTo_MultiXTpm__ShutdownProcessResponse(soap, tag, id, (_MultiXTpm__ShutdownProcessResponse *const*)ptr, "MultiXTpm:ShutdownProcessResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownProcess:
		return soap_out_PointerTo_MultiXTpm__ShutdownProcess(soap, tag, id, (_MultiXTpm__ShutdownProcess *const*)ptr, "MultiXTpm:ShutdownProcess");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartGroupResponse:
		return soap_out_PointerTo_MultiXTpm__StartGroupResponse(soap, tag, id, (_MultiXTpm__StartGroupResponse *const*)ptr, "MultiXTpm:StartGroupResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartGroup:
		return soap_out_PointerTo_MultiXTpm__StartGroup(soap, tag, id, (_MultiXTpm__StartGroup *const*)ptr, "MultiXTpm:StartGroup");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartProcessResponse:
		return soap_out_PointerTo_MultiXTpm__StartProcessResponse(soap, tag, id, (_MultiXTpm__StartProcessResponse *const*)ptr, "MultiXTpm:StartProcessResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__StartProcess:
		return soap_out_PointerTo_MultiXTpm__StartProcess(soap, tag, id, (_MultiXTpm__StartProcess *const*)ptr, "MultiXTpm:StartProcess");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartGroupResponse:
		return soap_out_PointerTo_MultiXTpm__RestartGroupResponse(soap, tag, id, (_MultiXTpm__RestartGroupResponse *const*)ptr, "MultiXTpm:RestartGroupResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartGroup:
		return soap_out_PointerTo_MultiXTpm__RestartGroup(soap, tag, id, (_MultiXTpm__RestartGroup *const*)ptr, "MultiXTpm:RestartGroup");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartProcessResponse:
		return soap_out_PointerTo_MultiXTpm__RestartProcessResponse(soap, tag, id, (_MultiXTpm__RestartProcessResponse *const*)ptr, "MultiXTpm:RestartProcessResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartProcess:
		return soap_out_PointerTo_MultiXTpm__RestartProcess(soap, tag, id, (_MultiXTpm__RestartProcess *const*)ptr, "MultiXTpm:RestartProcess");
	case SOAP_TYPE_PointerTo_MultiXTpm__GetSystemStatusResponse:
		return soap_out_PointerTo_MultiXTpm__GetSystemStatusResponse(soap, tag, id, (_MultiXTpm__GetSystemStatusResponse *const*)ptr, "MultiXTpm:GetSystemStatusResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__GetSystemStatus:
		return soap_out_PointerTo_MultiXTpm__GetSystemStatus(soap, tag, id, (_MultiXTpm__GetSystemStatus *const*)ptr, "MultiXTpm:GetSystemStatus");
	case SOAP_TYPE_PointerTo_MultiXTpm__UpdateConfigResponse:
		return soap_out_PointerTo_MultiXTpm__UpdateConfigResponse(soap, tag, id, (_MultiXTpm__UpdateConfigResponse *const*)ptr, "MultiXTpm:UpdateConfigResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__UpdateConfig:
		return soap_out_PointerTo_MultiXTpm__UpdateConfig(soap, tag, id, (_MultiXTpm__UpdateConfig *const*)ptr, "MultiXTpm:UpdateConfig");
	case SOAP_TYPE_PointerTo_MultiXTpm__GetConfigResponse:
		return soap_out_PointerTo_MultiXTpm__GetConfigResponse(soap, tag, id, (_MultiXTpm__GetConfigResponse *const*)ptr, "MultiXTpm:GetConfigResponse");
	case SOAP_TYPE_PointerTo_MultiXTpm__GetConfig:
		return soap_out_PointerTo_MultiXTpm__GetConfig(soap, tag, id, (_MultiXTpm__GetConfig *const*)ptr, "MultiXTpm:GetConfig");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfInt1:
		return soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, tag, id, (MultiXTpm__ArrayOfInt1 *const*)ptr, "MultiXTpm:ArrayOfInt1");
	case SOAP_TYPE_PointerToMultiXTpm__SystemStatus:
		return soap_out_PointerToMultiXTpm__SystemStatus(soap, tag, id, (MultiXTpm__SystemStatus *const*)ptr, "MultiXTpm:SystemStatus");
	case SOAP_TYPE_PointerToMultiXTpm__ConfigData:
		return soap_out_PointerToMultiXTpm__ConfigData(soap, tag, id, (MultiXTpm__ConfigData *const*)ptr, "MultiXTpm:ConfigData");
	case SOAP_TYPE_PointerToMultiXTpm__ProcessStatus:
		return soap_out_PointerToMultiXTpm__ProcessStatus(soap, tag, id, (MultiXTpm__ProcessStatus *const*)ptr, "MultiXTpm:ProcessStatus");
	case SOAP_TYPE_PointerToMultiXTpm__GroupStatus:
		return soap_out_PointerToMultiXTpm__GroupStatus(soap, tag, id, (MultiXTpm__GroupStatus *const*)ptr, "MultiXTpm:GroupStatus");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfProcessStatus:
		return soap_out_PointerToMultiXTpm__ArrayOfProcessStatus(soap, tag, id, (MultiXTpm__ArrayOfProcessStatus *const*)ptr, "MultiXTpm:ArrayOfProcessStatus");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroupStatus:
		return soap_out_PointerToMultiXTpm__ArrayOfGroupStatus(soap, tag, id, (MultiXTpm__ArrayOfGroupStatus *const*)ptr, "MultiXTpm:ArrayOfGroupStatus");
	case SOAP_TYPE_PointerToMultiXTpm__GroupForwardFlags:
		return soap_out_PointerToMultiXTpm__GroupForwardFlags(soap, tag, id, (MultiXTpm__GroupForwardFlags *const*)ptr, "MultiXTpm:GroupForwardFlags");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroupForwardFlags:
		return soap_out_PointerToMultiXTpm__ArrayOfGroupForwardFlags(soap, tag, id, (MultiXTpm__ArrayOfGroupForwardFlags *const*)ptr, "MultiXTpm:ArrayOfGroupForwardFlags");
	case SOAP_TYPE_PointerToMultiXTpm__Message:
		return soap_out_PointerToMultiXTpm__Message(soap, tag, id, (MultiXTpm__Message *const*)ptr, "MultiXTpm:Message");
	case SOAP_TYPE_PointerToMultiXTpm__Group:
		return soap_out_PointerToMultiXTpm__Group(soap, tag, id, (MultiXTpm__Group *const*)ptr, "MultiXTpm:Group");
	case SOAP_TYPE_PointerToMultiXTpm__SSLParams:
		return soap_out_PointerToMultiXTpm__SSLParams(soap, tag, id, (MultiXTpm__SSLParams *const*)ptr, "MultiXTpm:SSLParams");
	case SOAP_TYPE_PointerToMultiXTpm__Link:
		return soap_out_PointerToMultiXTpm__Link(soap, tag, id, (MultiXTpm__Link *const*)ptr, "MultiXTpm:Link");
	case SOAP_TYPE_PointerTo_MultiXTpm__Param_XmlParamValue:
		return soap_out_PointerTo_MultiXTpm__Param_XmlParamValue(soap, tag, id, (_MultiXTpm__Param_XmlParamValue *const*)ptr, "MultiXTpm:Param-XmlParamValue");
	case SOAP_TYPE_PointerToMultiXTpm__Param:
		return soap_out_PointerToMultiXTpm__Param(soap, tag, id, (MultiXTpm__Param *const*)ptr, "MultiXTpm:Param");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfInt:
		return soap_out_PointerToMultiXTpm__ArrayOfInt(soap, tag, id, (MultiXTpm__ArrayOfInt *const*)ptr, "MultiXTpm:ArrayOfInt");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfParam:
		return soap_out_PointerToMultiXTpm__ArrayOfParam(soap, tag, id, (MultiXTpm__ArrayOfParam *const*)ptr, "MultiXTpm:ArrayOfParam");
	case SOAP_TYPE_PointerToMultiXTpm__ProcessClass:
		return soap_out_PointerToMultiXTpm__ProcessClass(soap, tag, id, (MultiXTpm__ProcessClass *const*)ptr, "MultiXTpm:ProcessClass");
	case SOAP_TYPE_PointerToMultiXTpm__UserPermission:
		return soap_out_PointerToMultiXTpm__UserPermission(soap, tag, id, (MultiXTpm__UserPermission *const*)ptr, "MultiXTpm:UserPermission");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfUserPermission:
		return soap_out_PointerToMultiXTpm__ArrayOfUserPermission(soap, tag, id, (MultiXTpm__ArrayOfUserPermission *const*)ptr, "MultiXTpm:ArrayOfUserPermission");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfMessage:
		return soap_out_PointerToMultiXTpm__ArrayOfMessage(soap, tag, id, (MultiXTpm__ArrayOfMessage *const*)ptr, "MultiXTpm:ArrayOfMessage");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroup:
		return soap_out_PointerToMultiXTpm__ArrayOfGroup(soap, tag, id, (MultiXTpm__ArrayOfGroup *const*)ptr, "MultiXTpm:ArrayOfGroup");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfLink:
		return soap_out_PointerToMultiXTpm__ArrayOfLink(soap, tag, id, (MultiXTpm__ArrayOfLink *const*)ptr, "MultiXTpm:ArrayOfLink");
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfProcessClass:
		return soap_out_PointerToMultiXTpm__ArrayOfProcessClass(soap, tag, id, (MultiXTpm__ArrayOfProcessClass *const*)ptr, "MultiXTpm:ArrayOfProcessClass");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__MultiXTpm__Param_XmlParamValue:
		((_MultiXTpm__Param_XmlParamValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__MultiXTpm__ResumeAllResponse:
		((_MultiXTpm__ResumeAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ResumeAll:
		((_MultiXTpm__ResumeAll *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__SuspendAllResponse:
		((_MultiXTpm__SuspendAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__SuspendAll:
		((_MultiXTpm__SuspendAll *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownAllResponse:
		((_MultiXTpm__ShutdownAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownAll:
		((_MultiXTpm__ShutdownAll *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__StartAllResponse:
		((_MultiXTpm__StartAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__StartAll:
		((_MultiXTpm__StartAll *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__RestartAllResponse:
		((_MultiXTpm__RestartAllResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__RestartAll:
		((_MultiXTpm__RestartAll *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ResumeProcessResponse:
		((_MultiXTpm__ResumeProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ResumeProcess:
		((_MultiXTpm__ResumeProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ResumeGroupResponse:
		((_MultiXTpm__ResumeGroupResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ResumeGroup:
		((_MultiXTpm__ResumeGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__SuspendProcessResponse:
		((_MultiXTpm__SuspendProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__SuspendProcess:
		((_MultiXTpm__SuspendProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__SuspendGroupResponse:
		((_MultiXTpm__SuspendGroupResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__SuspendGroup:
		((_MultiXTpm__SuspendGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownGroupResponse:
		((_MultiXTpm__ShutdownGroupResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownGroup:
		((_MultiXTpm__ShutdownGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownProcessResponse:
		((_MultiXTpm__ShutdownProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownProcess:
		((_MultiXTpm__ShutdownProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__StartGroupResponse:
		((_MultiXTpm__StartGroupResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__StartGroup:
		((_MultiXTpm__StartGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__StartProcessResponse:
		((_MultiXTpm__StartProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__StartProcess:
		((_MultiXTpm__StartProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__RestartGroupResponse:
		((_MultiXTpm__RestartGroupResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__RestartGroup:
		((_MultiXTpm__RestartGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__RestartProcessResponse:
		((_MultiXTpm__RestartProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__RestartProcess:
		((_MultiXTpm__RestartProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__GetSystemStatusResponse:
		((_MultiXTpm__GetSystemStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__GetSystemStatus:
		((_MultiXTpm__GetSystemStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__UpdateConfigResponse:
		((_MultiXTpm__UpdateConfigResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__UpdateConfig:
		((_MultiXTpm__UpdateConfig *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__GetConfigResponse:
		((_MultiXTpm__GetConfigResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__MultiXTpm__GetConfig:
		((_MultiXTpm__GetConfig *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfInt1:
		((MultiXTpm__ArrayOfInt1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ProcessStatus:
		((MultiXTpm__ProcessStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus:
		((MultiXTpm__ArrayOfProcessStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__GroupStatus:
		((MultiXTpm__GroupStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus:
		((MultiXTpm__ArrayOfGroupStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__SystemStatus:
		((MultiXTpm__SystemStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__GroupForwardFlags:
		((MultiXTpm__GroupForwardFlags *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags:
		((MultiXTpm__ArrayOfGroupForwardFlags *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__Message:
		((MultiXTpm__Message *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfMessage:
		((MultiXTpm__ArrayOfMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__Group:
		((MultiXTpm__Group *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfGroup:
		((MultiXTpm__ArrayOfGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__SSLParams:
		((MultiXTpm__SSLParams *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__Link:
		((MultiXTpm__Link *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfLink:
		((MultiXTpm__ArrayOfLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfInt:
		((MultiXTpm__ArrayOfInt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__Param:
		((MultiXTpm__Param *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfParam:
		((MultiXTpm__ArrayOfParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ProcessClass:
		((MultiXTpm__ProcessClass *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfProcessClass:
		((MultiXTpm__ArrayOfProcessClass *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__UserPermission:
		((MultiXTpm__UserPermission *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfUserPermission:
		((MultiXTpm__ArrayOfUserPermission *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_MultiXTpm__ConfigData:
		((MultiXTpm__ConfigData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___MultiXTpm12__ResumeAll:
		soap_serialize___MultiXTpm12__ResumeAll(soap, (const struct __MultiXTpm12__ResumeAll *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__SuspendAll:
		soap_serialize___MultiXTpm12__SuspendAll(soap, (const struct __MultiXTpm12__SuspendAll *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__ShutdownAll:
		soap_serialize___MultiXTpm12__ShutdownAll(soap, (const struct __MultiXTpm12__ShutdownAll *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__StartAll:
		soap_serialize___MultiXTpm12__StartAll(soap, (const struct __MultiXTpm12__StartAll *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__RestartAll:
		soap_serialize___MultiXTpm12__RestartAll(soap, (const struct __MultiXTpm12__RestartAll *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__ResumeProcess:
		soap_serialize___MultiXTpm12__ResumeProcess(soap, (const struct __MultiXTpm12__ResumeProcess *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__ResumeGroup:
		soap_serialize___MultiXTpm12__ResumeGroup(soap, (const struct __MultiXTpm12__ResumeGroup *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__SuspendProcess:
		soap_serialize___MultiXTpm12__SuspendProcess(soap, (const struct __MultiXTpm12__SuspendProcess *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__SuspendGroup:
		soap_serialize___MultiXTpm12__SuspendGroup(soap, (const struct __MultiXTpm12__SuspendGroup *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__ShutdownGroup:
		soap_serialize___MultiXTpm12__ShutdownGroup(soap, (const struct __MultiXTpm12__ShutdownGroup *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__ShutdownProcess:
		soap_serialize___MultiXTpm12__ShutdownProcess(soap, (const struct __MultiXTpm12__ShutdownProcess *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__StartGroup:
		soap_serialize___MultiXTpm12__StartGroup(soap, (const struct __MultiXTpm12__StartGroup *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__StartProcess:
		soap_serialize___MultiXTpm12__StartProcess(soap, (const struct __MultiXTpm12__StartProcess *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__RestartGroup:
		soap_serialize___MultiXTpm12__RestartGroup(soap, (const struct __MultiXTpm12__RestartGroup *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__RestartProcess:
		soap_serialize___MultiXTpm12__RestartProcess(soap, (const struct __MultiXTpm12__RestartProcess *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__GetSystemStatus:
		soap_serialize___MultiXTpm12__GetSystemStatus(soap, (const struct __MultiXTpm12__GetSystemStatus *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__UpdateConfig:
		soap_serialize___MultiXTpm12__UpdateConfig(soap, (const struct __MultiXTpm12__UpdateConfig *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm12__GetConfig:
		soap_serialize___MultiXTpm12__GetConfig(soap, (const struct __MultiXTpm12__GetConfig *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__ResumeAll:
		soap_serialize___MultiXTpm11__ResumeAll(soap, (const struct __MultiXTpm11__ResumeAll *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__SuspendAll:
		soap_serialize___MultiXTpm11__SuspendAll(soap, (const struct __MultiXTpm11__SuspendAll *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__ShutdownAll:
		soap_serialize___MultiXTpm11__ShutdownAll(soap, (const struct __MultiXTpm11__ShutdownAll *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__StartAll:
		soap_serialize___MultiXTpm11__StartAll(soap, (const struct __MultiXTpm11__StartAll *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__RestartAll:
		soap_serialize___MultiXTpm11__RestartAll(soap, (const struct __MultiXTpm11__RestartAll *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__ResumeProcess:
		soap_serialize___MultiXTpm11__ResumeProcess(soap, (const struct __MultiXTpm11__ResumeProcess *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__ResumeGroup:
		soap_serialize___MultiXTpm11__ResumeGroup(soap, (const struct __MultiXTpm11__ResumeGroup *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__SuspendProcess:
		soap_serialize___MultiXTpm11__SuspendProcess(soap, (const struct __MultiXTpm11__SuspendProcess *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__SuspendGroup:
		soap_serialize___MultiXTpm11__SuspendGroup(soap, (const struct __MultiXTpm11__SuspendGroup *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__ShutdownGroup:
		soap_serialize___MultiXTpm11__ShutdownGroup(soap, (const struct __MultiXTpm11__ShutdownGroup *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__ShutdownProcess:
		soap_serialize___MultiXTpm11__ShutdownProcess(soap, (const struct __MultiXTpm11__ShutdownProcess *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__StartGroup:
		soap_serialize___MultiXTpm11__StartGroup(soap, (const struct __MultiXTpm11__StartGroup *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__StartProcess:
		soap_serialize___MultiXTpm11__StartProcess(soap, (const struct __MultiXTpm11__StartProcess *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__RestartGroup:
		soap_serialize___MultiXTpm11__RestartGroup(soap, (const struct __MultiXTpm11__RestartGroup *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__RestartProcess:
		soap_serialize___MultiXTpm11__RestartProcess(soap, (const struct __MultiXTpm11__RestartProcess *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__GetSystemStatus:
		soap_serialize___MultiXTpm11__GetSystemStatus(soap, (const struct __MultiXTpm11__GetSystemStatus *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__UpdateConfig:
		soap_serialize___MultiXTpm11__UpdateConfig(soap, (const struct __MultiXTpm11__UpdateConfig *)ptr);
		break;
	case SOAP_TYPE___MultiXTpm11__GetConfig:
		soap_serialize___MultiXTpm11__GetConfig(soap, (const struct __MultiXTpm11__GetConfig *)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeAllResponse:
		soap_serialize_PointerTo_MultiXTpm__ResumeAllResponse(soap, (_MultiXTpm__ResumeAllResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeAll:
		soap_serialize_PointerTo_MultiXTpm__ResumeAll(soap, (_MultiXTpm__ResumeAll *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendAllResponse:
		soap_serialize_PointerTo_MultiXTpm__SuspendAllResponse(soap, (_MultiXTpm__SuspendAllResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendAll:
		soap_serialize_PointerTo_MultiXTpm__SuspendAll(soap, (_MultiXTpm__SuspendAll *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownAllResponse:
		soap_serialize_PointerTo_MultiXTpm__ShutdownAllResponse(soap, (_MultiXTpm__ShutdownAllResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownAll:
		soap_serialize_PointerTo_MultiXTpm__ShutdownAll(soap, (_MultiXTpm__ShutdownAll *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__StartAllResponse:
		soap_serialize_PointerTo_MultiXTpm__StartAllResponse(soap, (_MultiXTpm__StartAllResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__StartAll:
		soap_serialize_PointerTo_MultiXTpm__StartAll(soap, (_MultiXTpm__StartAll *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartAllResponse:
		soap_serialize_PointerTo_MultiXTpm__RestartAllResponse(soap, (_MultiXTpm__RestartAllResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartAll:
		soap_serialize_PointerTo_MultiXTpm__RestartAll(soap, (_MultiXTpm__RestartAll *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeProcessResponse:
		soap_serialize_PointerTo_MultiXTpm__ResumeProcessResponse(soap, (_MultiXTpm__ResumeProcessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeProcess:
		soap_serialize_PointerTo_MultiXTpm__ResumeProcess(soap, (_MultiXTpm__ResumeProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeGroupResponse:
		soap_serialize_PointerTo_MultiXTpm__ResumeGroupResponse(soap, (_MultiXTpm__ResumeGroupResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ResumeGroup:
		soap_serialize_PointerTo_MultiXTpm__ResumeGroup(soap, (_MultiXTpm__ResumeGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendProcessResponse:
		soap_serialize_PointerTo_MultiXTpm__SuspendProcessResponse(soap, (_MultiXTpm__SuspendProcessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendProcess:
		soap_serialize_PointerTo_MultiXTpm__SuspendProcess(soap, (_MultiXTpm__SuspendProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendGroupResponse:
		soap_serialize_PointerTo_MultiXTpm__SuspendGroupResponse(soap, (_MultiXTpm__SuspendGroupResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__SuspendGroup:
		soap_serialize_PointerTo_MultiXTpm__SuspendGroup(soap, (_MultiXTpm__SuspendGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownGroupResponse:
		soap_serialize_PointerTo_MultiXTpm__ShutdownGroupResponse(soap, (_MultiXTpm__ShutdownGroupResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownGroup:
		soap_serialize_PointerTo_MultiXTpm__ShutdownGroup(soap, (_MultiXTpm__ShutdownGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownProcessResponse:
		soap_serialize_PointerTo_MultiXTpm__ShutdownProcessResponse(soap, (_MultiXTpm__ShutdownProcessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__ShutdownProcess:
		soap_serialize_PointerTo_MultiXTpm__ShutdownProcess(soap, (_MultiXTpm__ShutdownProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__StartGroupResponse:
		soap_serialize_PointerTo_MultiXTpm__StartGroupResponse(soap, (_MultiXTpm__StartGroupResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__StartGroup:
		soap_serialize_PointerTo_MultiXTpm__StartGroup(soap, (_MultiXTpm__StartGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__StartProcessResponse:
		soap_serialize_PointerTo_MultiXTpm__StartProcessResponse(soap, (_MultiXTpm__StartProcessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__StartProcess:
		soap_serialize_PointerTo_MultiXTpm__StartProcess(soap, (_MultiXTpm__StartProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartGroupResponse:
		soap_serialize_PointerTo_MultiXTpm__RestartGroupResponse(soap, (_MultiXTpm__RestartGroupResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartGroup:
		soap_serialize_PointerTo_MultiXTpm__RestartGroup(soap, (_MultiXTpm__RestartGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartProcessResponse:
		soap_serialize_PointerTo_MultiXTpm__RestartProcessResponse(soap, (_MultiXTpm__RestartProcessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__RestartProcess:
		soap_serialize_PointerTo_MultiXTpm__RestartProcess(soap, (_MultiXTpm__RestartProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__GetSystemStatusResponse:
		soap_serialize_PointerTo_MultiXTpm__GetSystemStatusResponse(soap, (_MultiXTpm__GetSystemStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__GetSystemStatus:
		soap_serialize_PointerTo_MultiXTpm__GetSystemStatus(soap, (_MultiXTpm__GetSystemStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__UpdateConfigResponse:
		soap_serialize_PointerTo_MultiXTpm__UpdateConfigResponse(soap, (_MultiXTpm__UpdateConfigResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__UpdateConfig:
		soap_serialize_PointerTo_MultiXTpm__UpdateConfig(soap, (_MultiXTpm__UpdateConfig *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__GetConfigResponse:
		soap_serialize_PointerTo_MultiXTpm__GetConfigResponse(soap, (_MultiXTpm__GetConfigResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__GetConfig:
		soap_serialize_PointerTo_MultiXTpm__GetConfig(soap, (_MultiXTpm__GetConfig *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfInt1:
		soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, (MultiXTpm__ArrayOfInt1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__SystemStatus:
		soap_serialize_PointerToMultiXTpm__SystemStatus(soap, (MultiXTpm__SystemStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ConfigData:
		soap_serialize_PointerToMultiXTpm__ConfigData(soap, (MultiXTpm__ConfigData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ProcessStatus:
		soap_serialize_PointerToMultiXTpm__ProcessStatus(soap, (MultiXTpm__ProcessStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__GroupStatus:
		soap_serialize_PointerToMultiXTpm__GroupStatus(soap, (MultiXTpm__GroupStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfProcessStatus:
		soap_serialize_PointerToMultiXTpm__ArrayOfProcessStatus(soap, (MultiXTpm__ArrayOfProcessStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroupStatus:
		soap_serialize_PointerToMultiXTpm__ArrayOfGroupStatus(soap, (MultiXTpm__ArrayOfGroupStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__GroupForwardFlags:
		soap_serialize_PointerToMultiXTpm__GroupForwardFlags(soap, (MultiXTpm__GroupForwardFlags *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroupForwardFlags:
		soap_serialize_PointerToMultiXTpm__ArrayOfGroupForwardFlags(soap, (MultiXTpm__ArrayOfGroupForwardFlags *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__Message:
		soap_serialize_PointerToMultiXTpm__Message(soap, (MultiXTpm__Message *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__Group:
		soap_serialize_PointerToMultiXTpm__Group(soap, (MultiXTpm__Group *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__SSLParams:
		soap_serialize_PointerToMultiXTpm__SSLParams(soap, (MultiXTpm__SSLParams *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__Link:
		soap_serialize_PointerToMultiXTpm__Link(soap, (MultiXTpm__Link *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_MultiXTpm__Param_XmlParamValue:
		soap_serialize_PointerTo_MultiXTpm__Param_XmlParamValue(soap, (_MultiXTpm__Param_XmlParamValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__Param:
		soap_serialize_PointerToMultiXTpm__Param(soap, (MultiXTpm__Param *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfInt:
		soap_serialize_PointerToMultiXTpm__ArrayOfInt(soap, (MultiXTpm__ArrayOfInt *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfParam:
		soap_serialize_PointerToMultiXTpm__ArrayOfParam(soap, (MultiXTpm__ArrayOfParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ProcessClass:
		soap_serialize_PointerToMultiXTpm__ProcessClass(soap, (MultiXTpm__ProcessClass *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__UserPermission:
		soap_serialize_PointerToMultiXTpm__UserPermission(soap, (MultiXTpm__UserPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfUserPermission:
		soap_serialize_PointerToMultiXTpm__ArrayOfUserPermission(soap, (MultiXTpm__ArrayOfUserPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfMessage:
		soap_serialize_PointerToMultiXTpm__ArrayOfMessage(soap, (MultiXTpm__ArrayOfMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroup:
		soap_serialize_PointerToMultiXTpm__ArrayOfGroup(soap, (MultiXTpm__ArrayOfGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfLink:
		soap_serialize_PointerToMultiXTpm__ArrayOfLink(soap, (MultiXTpm__ArrayOfLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMultiXTpm__ArrayOfProcessClass:
		soap_serialize_PointerToMultiXTpm__ArrayOfProcessClass(soap, (MultiXTpm__ArrayOfProcessClass *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ConfigData:
		return (void*)soap_instantiate_MultiXTpm__ConfigData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfUserPermission:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfUserPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__UserPermission:
		return (void*)soap_instantiate_MultiXTpm__UserPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfProcessClass:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfProcessClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ProcessClass:
		return (void*)soap_instantiate_MultiXTpm__ProcessClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfParam:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__Param_XmlParamValue:
		return (void*)soap_instantiate__MultiXTpm__Param_XmlParamValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__Param:
		return (void*)soap_instantiate_MultiXTpm__Param(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfInt:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfLink:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__Link:
		return (void*)soap_instantiate_MultiXTpm__Link(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__SSLParams:
		return (void*)soap_instantiate_MultiXTpm__SSLParams(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfGroup:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__Group:
		return (void*)soap_instantiate_MultiXTpm__Group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfMessage:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__Message:
		return (void*)soap_instantiate_MultiXTpm__Message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfGroupForwardFlags(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__GroupForwardFlags:
		return (void*)soap_instantiate_MultiXTpm__GroupForwardFlags(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__SystemStatus:
		return (void*)soap_instantiate_MultiXTpm__SystemStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfGroupStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__GroupStatus:
		return (void*)soap_instantiate_MultiXTpm__GroupStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfProcessStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ProcessStatus:
		return (void*)soap_instantiate_MultiXTpm__ProcessStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_MultiXTpm__ArrayOfInt1:
		return (void*)soap_instantiate_MultiXTpm__ArrayOfInt1(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__GetConfig:
		return (void*)soap_instantiate__MultiXTpm__GetConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__GetConfigResponse:
		return (void*)soap_instantiate__MultiXTpm__GetConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__UpdateConfig:
		return (void*)soap_instantiate__MultiXTpm__UpdateConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__UpdateConfigResponse:
		return (void*)soap_instantiate__MultiXTpm__UpdateConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__GetSystemStatus:
		return (void*)soap_instantiate__MultiXTpm__GetSystemStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__GetSystemStatusResponse:
		return (void*)soap_instantiate__MultiXTpm__GetSystemStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__RestartProcess:
		return (void*)soap_instantiate__MultiXTpm__RestartProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__RestartProcessResponse:
		return (void*)soap_instantiate__MultiXTpm__RestartProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__RestartGroup:
		return (void*)soap_instantiate__MultiXTpm__RestartGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__RestartGroupResponse:
		return (void*)soap_instantiate__MultiXTpm__RestartGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__StartProcess:
		return (void*)soap_instantiate__MultiXTpm__StartProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__StartProcessResponse:
		return (void*)soap_instantiate__MultiXTpm__StartProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__StartGroup:
		return (void*)soap_instantiate__MultiXTpm__StartGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__StartGroupResponse:
		return (void*)soap_instantiate__MultiXTpm__StartGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ShutdownProcess:
		return (void*)soap_instantiate__MultiXTpm__ShutdownProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ShutdownProcessResponse:
		return (void*)soap_instantiate__MultiXTpm__ShutdownProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ShutdownGroup:
		return (void*)soap_instantiate__MultiXTpm__ShutdownGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ShutdownGroupResponse:
		return (void*)soap_instantiate__MultiXTpm__ShutdownGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__SuspendGroup:
		return (void*)soap_instantiate__MultiXTpm__SuspendGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__SuspendGroupResponse:
		return (void*)soap_instantiate__MultiXTpm__SuspendGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__SuspendProcess:
		return (void*)soap_instantiate__MultiXTpm__SuspendProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__SuspendProcessResponse:
		return (void*)soap_instantiate__MultiXTpm__SuspendProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ResumeGroup:
		return (void*)soap_instantiate__MultiXTpm__ResumeGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ResumeGroupResponse:
		return (void*)soap_instantiate__MultiXTpm__ResumeGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ResumeProcess:
		return (void*)soap_instantiate__MultiXTpm__ResumeProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ResumeProcessResponse:
		return (void*)soap_instantiate__MultiXTpm__ResumeProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__RestartAll:
		return (void*)soap_instantiate__MultiXTpm__RestartAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__RestartAllResponse:
		return (void*)soap_instantiate__MultiXTpm__RestartAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__StartAll:
		return (void*)soap_instantiate__MultiXTpm__StartAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__StartAllResponse:
		return (void*)soap_instantiate__MultiXTpm__StartAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ShutdownAll:
		return (void*)soap_instantiate__MultiXTpm__ShutdownAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ShutdownAllResponse:
		return (void*)soap_instantiate__MultiXTpm__ShutdownAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__SuspendAll:
		return (void*)soap_instantiate__MultiXTpm__SuspendAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__SuspendAllResponse:
		return (void*)soap_instantiate__MultiXTpm__SuspendAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ResumeAll:
		return (void*)soap_instantiate__MultiXTpm__ResumeAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE__MultiXTpm__ResumeAllResponse:
		return (void*)soap_instantiate__MultiXTpm__ResumeAllResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__GetConfig:
		return (void*)soap_instantiate___MultiXTpm11__GetConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__UpdateConfig:
		return (void*)soap_instantiate___MultiXTpm11__UpdateConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__GetSystemStatus:
		return (void*)soap_instantiate___MultiXTpm11__GetSystemStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__RestartProcess:
		return (void*)soap_instantiate___MultiXTpm11__RestartProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__RestartGroup:
		return (void*)soap_instantiate___MultiXTpm11__RestartGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__StartProcess:
		return (void*)soap_instantiate___MultiXTpm11__StartProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__StartGroup:
		return (void*)soap_instantiate___MultiXTpm11__StartGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__ShutdownProcess:
		return (void*)soap_instantiate___MultiXTpm11__ShutdownProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__ShutdownGroup:
		return (void*)soap_instantiate___MultiXTpm11__ShutdownGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__SuspendGroup:
		return (void*)soap_instantiate___MultiXTpm11__SuspendGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__SuspendProcess:
		return (void*)soap_instantiate___MultiXTpm11__SuspendProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__ResumeGroup:
		return (void*)soap_instantiate___MultiXTpm11__ResumeGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__ResumeProcess:
		return (void*)soap_instantiate___MultiXTpm11__ResumeProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__RestartAll:
		return (void*)soap_instantiate___MultiXTpm11__RestartAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__StartAll:
		return (void*)soap_instantiate___MultiXTpm11__StartAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__ShutdownAll:
		return (void*)soap_instantiate___MultiXTpm11__ShutdownAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__SuspendAll:
		return (void*)soap_instantiate___MultiXTpm11__SuspendAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm11__ResumeAll:
		return (void*)soap_instantiate___MultiXTpm11__ResumeAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__GetConfig:
		return (void*)soap_instantiate___MultiXTpm12__GetConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__UpdateConfig:
		return (void*)soap_instantiate___MultiXTpm12__UpdateConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__GetSystemStatus:
		return (void*)soap_instantiate___MultiXTpm12__GetSystemStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__RestartProcess:
		return (void*)soap_instantiate___MultiXTpm12__RestartProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__RestartGroup:
		return (void*)soap_instantiate___MultiXTpm12__RestartGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__StartProcess:
		return (void*)soap_instantiate___MultiXTpm12__StartProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__StartGroup:
		return (void*)soap_instantiate___MultiXTpm12__StartGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__ShutdownProcess:
		return (void*)soap_instantiate___MultiXTpm12__ShutdownProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__ShutdownGroup:
		return (void*)soap_instantiate___MultiXTpm12__ShutdownGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__SuspendGroup:
		return (void*)soap_instantiate___MultiXTpm12__SuspendGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__SuspendProcess:
		return (void*)soap_instantiate___MultiXTpm12__SuspendProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__ResumeGroup:
		return (void*)soap_instantiate___MultiXTpm12__ResumeGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__ResumeProcess:
		return (void*)soap_instantiate___MultiXTpm12__ResumeProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__RestartAll:
		return (void*)soap_instantiate___MultiXTpm12__RestartAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__StartAll:
		return (void*)soap_instantiate___MultiXTpm12__StartAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__ShutdownAll:
		return (void*)soap_instantiate___MultiXTpm12__ShutdownAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__SuspendAll:
		return (void*)soap_instantiate___MultiXTpm12__SuspendAll(soap, -1, type, arrayType, n);
	case SOAP_TYPE___MultiXTpm12__ResumeAll:
		return (void*)soap_instantiate___MultiXTpm12__ResumeAll(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Message:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Message(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Group:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Link:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Link(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Param:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Param(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__UserPermission:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ConfigData:
		if (p->size < 0)
			delete (MultiXTpm__ConfigData*)p->ptr;
		else
			delete[] (MultiXTpm__ConfigData*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfUserPermission:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfUserPermission*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfUserPermission*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__UserPermission:
		if (p->size < 0)
			delete (MultiXTpm__UserPermission*)p->ptr;
		else
			delete[] (MultiXTpm__UserPermission*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfProcessClass:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfProcessClass*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfProcessClass*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ProcessClass:
		if (p->size < 0)
			delete (MultiXTpm__ProcessClass*)p->ptr;
		else
			delete[] (MultiXTpm__ProcessClass*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfParam:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfParam*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfParam*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__Param_XmlParamValue:
		if (p->size < 0)
			delete (_MultiXTpm__Param_XmlParamValue*)p->ptr;
		else
			delete[] (_MultiXTpm__Param_XmlParamValue*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__Param:
		if (p->size < 0)
			delete (MultiXTpm__Param*)p->ptr;
		else
			delete[] (MultiXTpm__Param*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfInt:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfInt*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfInt*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfLink:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfLink*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfLink*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__Link:
		if (p->size < 0)
			delete (MultiXTpm__Link*)p->ptr;
		else
			delete[] (MultiXTpm__Link*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__SSLParams:
		if (p->size < 0)
			delete (MultiXTpm__SSLParams*)p->ptr;
		else
			delete[] (MultiXTpm__SSLParams*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfGroup:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfGroup*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfGroup*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__Group:
		if (p->size < 0)
			delete (MultiXTpm__Group*)p->ptr;
		else
			delete[] (MultiXTpm__Group*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfMessage:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfMessage*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfMessage*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__Message:
		if (p->size < 0)
			delete (MultiXTpm__Message*)p->ptr;
		else
			delete[] (MultiXTpm__Message*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfGroupForwardFlags*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfGroupForwardFlags*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__GroupForwardFlags:
		if (p->size < 0)
			delete (MultiXTpm__GroupForwardFlags*)p->ptr;
		else
			delete[] (MultiXTpm__GroupForwardFlags*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__SystemStatus:
		if (p->size < 0)
			delete (MultiXTpm__SystemStatus*)p->ptr;
		else
			delete[] (MultiXTpm__SystemStatus*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfGroupStatus*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfGroupStatus*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__GroupStatus:
		if (p->size < 0)
			delete (MultiXTpm__GroupStatus*)p->ptr;
		else
			delete[] (MultiXTpm__GroupStatus*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfProcessStatus*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfProcessStatus*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ProcessStatus:
		if (p->size < 0)
			delete (MultiXTpm__ProcessStatus*)p->ptr;
		else
			delete[] (MultiXTpm__ProcessStatus*)p->ptr;
		break;
	case SOAP_TYPE_MultiXTpm__ArrayOfInt1:
		if (p->size < 0)
			delete (MultiXTpm__ArrayOfInt1*)p->ptr;
		else
			delete[] (MultiXTpm__ArrayOfInt1*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__GetConfig:
		if (p->size < 0)
			delete (_MultiXTpm__GetConfig*)p->ptr;
		else
			delete[] (_MultiXTpm__GetConfig*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__GetConfigResponse:
		if (p->size < 0)
			delete (_MultiXTpm__GetConfigResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__GetConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__UpdateConfig:
		if (p->size < 0)
			delete (_MultiXTpm__UpdateConfig*)p->ptr;
		else
			delete[] (_MultiXTpm__UpdateConfig*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__UpdateConfigResponse:
		if (p->size < 0)
			delete (_MultiXTpm__UpdateConfigResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__UpdateConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__GetSystemStatus:
		if (p->size < 0)
			delete (_MultiXTpm__GetSystemStatus*)p->ptr;
		else
			delete[] (_MultiXTpm__GetSystemStatus*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__GetSystemStatusResponse:
		if (p->size < 0)
			delete (_MultiXTpm__GetSystemStatusResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__GetSystemStatusResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__RestartProcess:
		if (p->size < 0)
			delete (_MultiXTpm__RestartProcess*)p->ptr;
		else
			delete[] (_MultiXTpm__RestartProcess*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__RestartProcessResponse:
		if (p->size < 0)
			delete (_MultiXTpm__RestartProcessResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__RestartProcessResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__RestartGroup:
		if (p->size < 0)
			delete (_MultiXTpm__RestartGroup*)p->ptr;
		else
			delete[] (_MultiXTpm__RestartGroup*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__RestartGroupResponse:
		if (p->size < 0)
			delete (_MultiXTpm__RestartGroupResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__RestartGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__StartProcess:
		if (p->size < 0)
			delete (_MultiXTpm__StartProcess*)p->ptr;
		else
			delete[] (_MultiXTpm__StartProcess*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__StartProcessResponse:
		if (p->size < 0)
			delete (_MultiXTpm__StartProcessResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__StartProcessResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__StartGroup:
		if (p->size < 0)
			delete (_MultiXTpm__StartGroup*)p->ptr;
		else
			delete[] (_MultiXTpm__StartGroup*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__StartGroupResponse:
		if (p->size < 0)
			delete (_MultiXTpm__StartGroupResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__StartGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownProcess:
		if (p->size < 0)
			delete (_MultiXTpm__ShutdownProcess*)p->ptr;
		else
			delete[] (_MultiXTpm__ShutdownProcess*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownProcessResponse:
		if (p->size < 0)
			delete (_MultiXTpm__ShutdownProcessResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__ShutdownProcessResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownGroup:
		if (p->size < 0)
			delete (_MultiXTpm__ShutdownGroup*)p->ptr;
		else
			delete[] (_MultiXTpm__ShutdownGroup*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownGroupResponse:
		if (p->size < 0)
			delete (_MultiXTpm__ShutdownGroupResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__ShutdownGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__SuspendGroup:
		if (p->size < 0)
			delete (_MultiXTpm__SuspendGroup*)p->ptr;
		else
			delete[] (_MultiXTpm__SuspendGroup*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__SuspendGroupResponse:
		if (p->size < 0)
			delete (_MultiXTpm__SuspendGroupResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__SuspendGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__SuspendProcess:
		if (p->size < 0)
			delete (_MultiXTpm__SuspendProcess*)p->ptr;
		else
			delete[] (_MultiXTpm__SuspendProcess*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__SuspendProcessResponse:
		if (p->size < 0)
			delete (_MultiXTpm__SuspendProcessResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__SuspendProcessResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ResumeGroup:
		if (p->size < 0)
			delete (_MultiXTpm__ResumeGroup*)p->ptr;
		else
			delete[] (_MultiXTpm__ResumeGroup*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ResumeGroupResponse:
		if (p->size < 0)
			delete (_MultiXTpm__ResumeGroupResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__ResumeGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ResumeProcess:
		if (p->size < 0)
			delete (_MultiXTpm__ResumeProcess*)p->ptr;
		else
			delete[] (_MultiXTpm__ResumeProcess*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ResumeProcessResponse:
		if (p->size < 0)
			delete (_MultiXTpm__ResumeProcessResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__ResumeProcessResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__RestartAll:
		if (p->size < 0)
			delete (_MultiXTpm__RestartAll*)p->ptr;
		else
			delete[] (_MultiXTpm__RestartAll*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__RestartAllResponse:
		if (p->size < 0)
			delete (_MultiXTpm__RestartAllResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__RestartAllResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__StartAll:
		if (p->size < 0)
			delete (_MultiXTpm__StartAll*)p->ptr;
		else
			delete[] (_MultiXTpm__StartAll*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__StartAllResponse:
		if (p->size < 0)
			delete (_MultiXTpm__StartAllResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__StartAllResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownAll:
		if (p->size < 0)
			delete (_MultiXTpm__ShutdownAll*)p->ptr;
		else
			delete[] (_MultiXTpm__ShutdownAll*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ShutdownAllResponse:
		if (p->size < 0)
			delete (_MultiXTpm__ShutdownAllResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__ShutdownAllResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__SuspendAll:
		if (p->size < 0)
			delete (_MultiXTpm__SuspendAll*)p->ptr;
		else
			delete[] (_MultiXTpm__SuspendAll*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__SuspendAllResponse:
		if (p->size < 0)
			delete (_MultiXTpm__SuspendAllResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__SuspendAllResponse*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ResumeAll:
		if (p->size < 0)
			delete (_MultiXTpm__ResumeAll*)p->ptr;
		else
			delete[] (_MultiXTpm__ResumeAll*)p->ptr;
		break;
	case SOAP_TYPE__MultiXTpm__ResumeAllResponse:
		if (p->size < 0)
			delete (_MultiXTpm__ResumeAllResponse*)p->ptr;
		else
			delete[] (_MultiXTpm__ResumeAllResponse*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__GetConfig:
		if (p->size < 0)
			delete (struct __MultiXTpm11__GetConfig*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__GetConfig*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__UpdateConfig:
		if (p->size < 0)
			delete (struct __MultiXTpm11__UpdateConfig*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__UpdateConfig*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__GetSystemStatus:
		if (p->size < 0)
			delete (struct __MultiXTpm11__GetSystemStatus*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__GetSystemStatus*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__RestartProcess:
		if (p->size < 0)
			delete (struct __MultiXTpm11__RestartProcess*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__RestartProcess*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__RestartGroup:
		if (p->size < 0)
			delete (struct __MultiXTpm11__RestartGroup*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__RestartGroup*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__StartProcess:
		if (p->size < 0)
			delete (struct __MultiXTpm11__StartProcess*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__StartProcess*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__StartGroup:
		if (p->size < 0)
			delete (struct __MultiXTpm11__StartGroup*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__StartGroup*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__ShutdownProcess:
		if (p->size < 0)
			delete (struct __MultiXTpm11__ShutdownProcess*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__ShutdownProcess*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__ShutdownGroup:
		if (p->size < 0)
			delete (struct __MultiXTpm11__ShutdownGroup*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__ShutdownGroup*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__SuspendGroup:
		if (p->size < 0)
			delete (struct __MultiXTpm11__SuspendGroup*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__SuspendGroup*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__SuspendProcess:
		if (p->size < 0)
			delete (struct __MultiXTpm11__SuspendProcess*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__SuspendProcess*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__ResumeGroup:
		if (p->size < 0)
			delete (struct __MultiXTpm11__ResumeGroup*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__ResumeGroup*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__ResumeProcess:
		if (p->size < 0)
			delete (struct __MultiXTpm11__ResumeProcess*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__ResumeProcess*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__RestartAll:
		if (p->size < 0)
			delete (struct __MultiXTpm11__RestartAll*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__RestartAll*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__StartAll:
		if (p->size < 0)
			delete (struct __MultiXTpm11__StartAll*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__StartAll*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__ShutdownAll:
		if (p->size < 0)
			delete (struct __MultiXTpm11__ShutdownAll*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__ShutdownAll*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__SuspendAll:
		if (p->size < 0)
			delete (struct __MultiXTpm11__SuspendAll*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__SuspendAll*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm11__ResumeAll:
		if (p->size < 0)
			delete (struct __MultiXTpm11__ResumeAll*)p->ptr;
		else
			delete[] (struct __MultiXTpm11__ResumeAll*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__GetConfig:
		if (p->size < 0)
			delete (struct __MultiXTpm12__GetConfig*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__GetConfig*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__UpdateConfig:
		if (p->size < 0)
			delete (struct __MultiXTpm12__UpdateConfig*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__UpdateConfig*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__GetSystemStatus:
		if (p->size < 0)
			delete (struct __MultiXTpm12__GetSystemStatus*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__GetSystemStatus*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__RestartProcess:
		if (p->size < 0)
			delete (struct __MultiXTpm12__RestartProcess*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__RestartProcess*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__RestartGroup:
		if (p->size < 0)
			delete (struct __MultiXTpm12__RestartGroup*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__RestartGroup*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__StartProcess:
		if (p->size < 0)
			delete (struct __MultiXTpm12__StartProcess*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__StartProcess*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__StartGroup:
		if (p->size < 0)
			delete (struct __MultiXTpm12__StartGroup*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__StartGroup*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__ShutdownProcess:
		if (p->size < 0)
			delete (struct __MultiXTpm12__ShutdownProcess*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__ShutdownProcess*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__ShutdownGroup:
		if (p->size < 0)
			delete (struct __MultiXTpm12__ShutdownGroup*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__ShutdownGroup*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__SuspendGroup:
		if (p->size < 0)
			delete (struct __MultiXTpm12__SuspendGroup*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__SuspendGroup*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__SuspendProcess:
		if (p->size < 0)
			delete (struct __MultiXTpm12__SuspendProcess*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__SuspendProcess*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__ResumeGroup:
		if (p->size < 0)
			delete (struct __MultiXTpm12__ResumeGroup*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__ResumeGroup*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__ResumeProcess:
		if (p->size < 0)
			delete (struct __MultiXTpm12__ResumeProcess*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__ResumeProcess*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__RestartAll:
		if (p->size < 0)
			delete (struct __MultiXTpm12__RestartAll*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__RestartAll*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__StartAll:
		if (p->size < 0)
			delete (struct __MultiXTpm12__StartAll*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__StartAll*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__ShutdownAll:
		if (p->size < 0)
			delete (struct __MultiXTpm12__ShutdownAll*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__ShutdownAll*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__SuspendAll:
		if (p->size < 0)
			delete (struct __MultiXTpm12__SuspendAll*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__SuspendAll*)p->ptr;
		break;
	case SOAP_TYPE___MultiXTpm12__ResumeAll:
		if (p->size < 0)
			delete (struct __MultiXTpm12__ResumeAll*)p->ptr;
		else
			delete[] (struct __MultiXTpm12__ResumeAll*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus:
		if (p->size < 0)
			delete (std::vector<MultiXTpm__ProcessStatus * >*)p->ptr;
		else
			delete[] (std::vector<MultiXTpm__ProcessStatus * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus:
		if (p->size < 0)
			delete (std::vector<MultiXTpm__GroupStatus * >*)p->ptr;
		else
			delete[] (std::vector<MultiXTpm__GroupStatus * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags:
		if (p->size < 0)
			delete (std::vector<MultiXTpm__GroupForwardFlags * >*)p->ptr;
		else
			delete[] (std::vector<MultiXTpm__GroupForwardFlags * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Message:
		if (p->size < 0)
			delete (std::vector<MultiXTpm__Message * >*)p->ptr;
		else
			delete[] (std::vector<MultiXTpm__Message * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Group:
		if (p->size < 0)
			delete (std::vector<MultiXTpm__Group * >*)p->ptr;
		else
			delete[] (std::vector<MultiXTpm__Group * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Link:
		if (p->size < 0)
			delete (std::vector<MultiXTpm__Link * >*)p->ptr;
		else
			delete[] (std::vector<MultiXTpm__Link * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			delete (std::vector<int >*)p->ptr;
		else
			delete[] (std::vector<int >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			delete (std::vector<char * >*)p->ptr;
		else
			delete[] (std::vector<char * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Param:
		if (p->size < 0)
			delete (std::vector<MultiXTpm__Param * >*)p->ptr;
		else
			delete[] (std::vector<MultiXTpm__Param * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass:
		if (p->size < 0)
			delete (std::vector<MultiXTpm__ProcessClass * >*)p->ptr;
		else
			delete[] (std::vector<MultiXTpm__ProcessClass * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__UserPermission:
		if (p->size < 0)
			delete (std::vector<MultiXTpm__UserPermission * >*)p->ptr;
		else
			delete[] (std::vector<MultiXTpm__UserPermission * >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<MultiXTpm__ProcessStatus * >*)p)[len] = *(MultiXTpm__ProcessStatus **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<MultiXTpm__GroupStatus * >*)p)[len] = *(MultiXTpm__GroupStatus **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<MultiXTpm__GroupForwardFlags * >*)p)[len] = *(MultiXTpm__GroupForwardFlags **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Message:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<MultiXTpm__Message * >*)p)[len] = *(MultiXTpm__Message **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Group:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<MultiXTpm__Group * >*)p)[len] = *(MultiXTpm__Group **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Link:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<MultiXTpm__Link * >*)p)[len] = *(MultiXTpm__Link **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Param:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<MultiXTpm__Param * >*)p)[len] = *(MultiXTpm__Param **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<MultiXTpm__ProcessClass * >*)p)[len] = *(MultiXTpm__ProcessClass **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__UserPermission:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<MultiXTpm__UserPermission * >*)p)[len] = *(MultiXTpm__UserPermission **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_MultiXTpm__ProcessControlStatus(struct soap *soap, enum MultiXTpm__ProcessControlStatus *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_MultiXTpm__ProcessControlStatus
	*a = SOAP_DEFAULT_MultiXTpm__ProcessControlStatus;
#else
	*a = (enum MultiXTpm__ProcessControlStatus)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_MultiXTpm__ProcessControlStatus(struct soap *soap, const enum MultiXTpm__ProcessControlStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ProcessControlStatus);
	if (soap_out_MultiXTpm__ProcessControlStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_MultiXTpm__ProcessControlStatus[] =
{	{ (long)MultiXTpm__ProcessControlStatus__Normal, "Normal" },
	{ (long)MultiXTpm__ProcessControlStatus__Shutdown, "Shutdown" },
	{ (long)MultiXTpm__ProcessControlStatus__Suspend, "Suspend" },
	{ (long)MultiXTpm__ProcessControlStatus__Restart, "Restart" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_MultiXTpm__ProcessControlStatus2s(struct soap *soap, enum MultiXTpm__ProcessControlStatus n)
{	const char *s = soap_code_str(soap_codes_MultiXTpm__ProcessControlStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ProcessControlStatus(struct soap *soap, const char *tag, int id, const enum MultiXTpm__ProcessControlStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ProcessControlStatus), type) || soap_send(soap, soap_MultiXTpm__ProcessControlStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum MultiXTpm__ProcessControlStatus * SOAP_FMAC4 soap_get_MultiXTpm__ProcessControlStatus(struct soap *soap, enum MultiXTpm__ProcessControlStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ProcessControlStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2MultiXTpm__ProcessControlStatus(struct soap *soap, const char *s, enum MultiXTpm__ProcessControlStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_MultiXTpm__ProcessControlStatus, s);
	if (map)
		*a = (enum MultiXTpm__ProcessControlStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum MultiXTpm__ProcessControlStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum MultiXTpm__ProcessControlStatus * SOAP_FMAC4 soap_in_MultiXTpm__ProcessControlStatus(struct soap *soap, const char *tag, enum MultiXTpm__ProcessControlStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum MultiXTpm__ProcessControlStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ProcessControlStatus, sizeof(enum MultiXTpm__ProcessControlStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2MultiXTpm__ProcessControlStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum MultiXTpm__ProcessControlStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ProcessControlStatus, 0, sizeof(enum MultiXTpm__ProcessControlStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_MultiXTpm__SSL_USCOREAPI(struct soap *soap, enum MultiXTpm__SSL_USCOREAPI *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_MultiXTpm__SSL_USCOREAPI
	*a = SOAP_DEFAULT_MultiXTpm__SSL_USCOREAPI;
#else
	*a = (enum MultiXTpm__SSL_USCOREAPI)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_MultiXTpm__SSL_USCOREAPI(struct soap *soap, const enum MultiXTpm__SSL_USCOREAPI *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_MultiXTpm__SSL_USCOREAPI);
	if (soap_out_MultiXTpm__SSL_USCOREAPI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_MultiXTpm__SSL_USCOREAPI[] =
{	{ (long)MultiXTpm__SSL_USCOREAPI__NoSSLAPI, "NoSSLAPI" },
	{ (long)MultiXTpm__SSL_USCOREAPI__OpenSSL, "OpenSSL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_MultiXTpm__SSL_USCOREAPI2s(struct soap *soap, enum MultiXTpm__SSL_USCOREAPI n)
{	const char *s = soap_code_str(soap_codes_MultiXTpm__SSL_USCOREAPI, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__SSL_USCOREAPI(struct soap *soap, const char *tag, int id, const enum MultiXTpm__SSL_USCOREAPI *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__SSL_USCOREAPI), type) || soap_send(soap, soap_MultiXTpm__SSL_USCOREAPI2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum MultiXTpm__SSL_USCOREAPI * SOAP_FMAC4 soap_get_MultiXTpm__SSL_USCOREAPI(struct soap *soap, enum MultiXTpm__SSL_USCOREAPI *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__SSL_USCOREAPI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2MultiXTpm__SSL_USCOREAPI(struct soap *soap, const char *s, enum MultiXTpm__SSL_USCOREAPI *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_MultiXTpm__SSL_USCOREAPI, s);
	if (map)
		*a = (enum MultiXTpm__SSL_USCOREAPI)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum MultiXTpm__SSL_USCOREAPI)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum MultiXTpm__SSL_USCOREAPI * SOAP_FMAC4 soap_in_MultiXTpm__SSL_USCOREAPI(struct soap *soap, const char *tag, enum MultiXTpm__SSL_USCOREAPI *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum MultiXTpm__SSL_USCOREAPI *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__SSL_USCOREAPI, sizeof(enum MultiXTpm__SSL_USCOREAPI), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2MultiXTpm__SSL_USCOREAPI(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum MultiXTpm__SSL_USCOREAPI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__SSL_USCOREAPI, 0, sizeof(enum MultiXTpm__SSL_USCOREAPI), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_MultiXTpm__MultiXOpenMode(struct soap *soap, enum MultiXTpm__MultiXOpenMode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_MultiXTpm__MultiXOpenMode
	*a = SOAP_DEFAULT_MultiXTpm__MultiXOpenMode;
#else
	*a = (enum MultiXTpm__MultiXOpenMode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_MultiXTpm__MultiXOpenMode(struct soap *soap, const enum MultiXTpm__MultiXOpenMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_MultiXTpm__MultiXOpenMode);
	if (soap_out_MultiXTpm__MultiXOpenMode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_MultiXTpm__MultiXOpenMode[] =
{	{ (long)MultiXTpm__MultiXOpenMode__MultiXOpenModeFirst, "MultiXOpenModeFirst" },
	{ (long)MultiXTpm__MultiXOpenMode__MultiXOpenModeServer, "MultiXOpenModeServer" },
	{ (long)MultiXTpm__MultiXOpenMode__MultiXOpenModeClient, "MultiXOpenModeClient" },
	{ (long)MultiXTpm__MultiXOpenMode__MultiXOpenModeAccept, "MultiXOpenModeAccept" },
	{ (long)MultiXTpm__MultiXOpenMode__MultiXOpenModeLast, "MultiXOpenModeLast" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_MultiXTpm__MultiXOpenMode2s(struct soap *soap, enum MultiXTpm__MultiXOpenMode n)
{	const char *s = soap_code_str(soap_codes_MultiXTpm__MultiXOpenMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__MultiXOpenMode(struct soap *soap, const char *tag, int id, const enum MultiXTpm__MultiXOpenMode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__MultiXOpenMode), type) || soap_send(soap, soap_MultiXTpm__MultiXOpenMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum MultiXTpm__MultiXOpenMode * SOAP_FMAC4 soap_get_MultiXTpm__MultiXOpenMode(struct soap *soap, enum MultiXTpm__MultiXOpenMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__MultiXOpenMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2MultiXTpm__MultiXOpenMode(struct soap *soap, const char *s, enum MultiXTpm__MultiXOpenMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_MultiXTpm__MultiXOpenMode, s);
	if (map)
		*a = (enum MultiXTpm__MultiXOpenMode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum MultiXTpm__MultiXOpenMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum MultiXTpm__MultiXOpenMode * SOAP_FMAC4 soap_in_MultiXTpm__MultiXOpenMode(struct soap *soap, const char *tag, enum MultiXTpm__MultiXOpenMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum MultiXTpm__MultiXOpenMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__MultiXOpenMode, sizeof(enum MultiXTpm__MultiXOpenMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2MultiXTpm__MultiXOpenMode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum MultiXTpm__MultiXOpenMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__MultiXOpenMode, 0, sizeof(enum MultiXTpm__MultiXOpenMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_MultiXTpm__MultiXLinkType(struct soap *soap, enum MultiXTpm__MultiXLinkType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_MultiXTpm__MultiXLinkType
	*a = SOAP_DEFAULT_MultiXTpm__MultiXLinkType;
#else
	*a = (enum MultiXTpm__MultiXLinkType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_MultiXTpm__MultiXLinkType(struct soap *soap, const enum MultiXTpm__MultiXLinkType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_MultiXTpm__MultiXLinkType);
	if (soap_out_MultiXTpm__MultiXLinkType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_MultiXTpm__MultiXLinkType[] =
{	{ (long)MultiXTpm__MultiXLinkType__MultiXLinkTypeFirst, "MultiXLinkTypeFirst" },
	{ (long)MultiXTpm__MultiXLinkType__MultiXLinkTypeTcp, "MultiXLinkTypeTcp" },
	{ (long)MultiXTpm__MultiXLinkType__MultiXLinkTypeLast, "MultiXLinkTypeLast" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_MultiXTpm__MultiXLinkType2s(struct soap *soap, enum MultiXTpm__MultiXLinkType n)
{	const char *s = soap_code_str(soap_codes_MultiXTpm__MultiXLinkType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__MultiXLinkType(struct soap *soap, const char *tag, int id, const enum MultiXTpm__MultiXLinkType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__MultiXLinkType), type) || soap_send(soap, soap_MultiXTpm__MultiXLinkType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum MultiXTpm__MultiXLinkType * SOAP_FMAC4 soap_get_MultiXTpm__MultiXLinkType(struct soap *soap, enum MultiXTpm__MultiXLinkType *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__MultiXLinkType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2MultiXTpm__MultiXLinkType(struct soap *soap, const char *s, enum MultiXTpm__MultiXLinkType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_MultiXTpm__MultiXLinkType, s);
	if (map)
		*a = (enum MultiXTpm__MultiXLinkType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum MultiXTpm__MultiXLinkType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum MultiXTpm__MultiXLinkType * SOAP_FMAC4 soap_in_MultiXTpm__MultiXLinkType(struct soap *soap, const char *tag, enum MultiXTpm__MultiXLinkType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum MultiXTpm__MultiXLinkType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__MultiXLinkType, sizeof(enum MultiXTpm__MultiXLinkType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2MultiXTpm__MultiXLinkType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum MultiXTpm__MultiXLinkType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__MultiXLinkType, 0, sizeof(enum MultiXTpm__MultiXLinkType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void _MultiXTpm__Param_XmlParamValue::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_MultiXTpm__Param_XmlParamValue::__any);
	this->_MultiXTpm__Param_XmlParamValue::__anyAttribute = NULL;
	this->_MultiXTpm__Param_XmlParamValue::__mixed = NULL;
}

void _MultiXTpm__Param_XmlParamValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_MultiXTpm__Param_XmlParamValue::__any);
}

int _MultiXTpm__Param_XmlParamValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__Param_XmlParamValue);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__Param_XmlParamValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__Param_XmlParamValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__Param_XmlParamValue(struct soap *soap, const char *tag, int id, const _MultiXTpm__Param_XmlParamValue *a, const char *type)
{
	if (((_MultiXTpm__Param_XmlParamValue *)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((_MultiXTpm__Param_XmlParamValue *)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__Param_XmlParamValue), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->_MultiXTpm__Param_XmlParamValue::__any), ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &(a->_MultiXTpm__Param_XmlParamValue::__mixed), NULL);
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__Param_XmlParamValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__Param_XmlParamValue(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__Param_XmlParamValue * SOAP_FMAC4 soap_get__MultiXTpm__Param_XmlParamValue(struct soap *soap, _MultiXTpm__Param_XmlParamValue *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__Param_XmlParamValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__Param_XmlParamValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__Param_XmlParamValue(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__Param_XmlParamValue * SOAP_FMAC4 soap_in__MultiXTpm__Param_XmlParamValue(struct soap *soap, const char *tag, _MultiXTpm__Param_XmlParamValue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__Param_XmlParamValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__Param_XmlParamValue, sizeof(_MultiXTpm__Param_XmlParamValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__Param_XmlParamValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__Param_XmlParamValue *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((_MultiXTpm__Param_XmlParamValue *)a)->__anyAttribute))
		return NULL;
	short soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->_MultiXTpm__Param_XmlParamValue::__any), ""))
					continue;
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &(a->_MultiXTpm__Param_XmlParamValue::__mixed)))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__Param_XmlParamValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__Param_XmlParamValue, 0, sizeof(_MultiXTpm__Param_XmlParamValue), 0, soap_copy__MultiXTpm__Param_XmlParamValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__Param_XmlParamValue * SOAP_FMAC6 soap_new__MultiXTpm__Param_XmlParamValue(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__Param_XmlParamValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__Param_XmlParamValue(struct soap *soap, _MultiXTpm__Param_XmlParamValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__Param_XmlParamValue * SOAP_FMAC4 soap_instantiate__MultiXTpm__Param_XmlParamValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__Param_XmlParamValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__Param_XmlParamValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__Param_XmlParamValue;
		if (size)
			*size = sizeof(_MultiXTpm__Param_XmlParamValue);
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__Param_XmlParamValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__Param_XmlParamValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__Param_XmlParamValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__Param_XmlParamValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__Param_XmlParamValue %p -> %p\n", q, p));
	*(_MultiXTpm__Param_XmlParamValue*)p = *(_MultiXTpm__Param_XmlParamValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _MultiXTpm__ResumeAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__ResumeAllResponse::ResumeAllResult);
	/* transient soap skipped */
}

void _MultiXTpm__ResumeAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__ResumeAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ResumeAllResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ResumeAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ResumeAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ResumeAllResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__ResumeAllResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ResumeAllResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:ResumeAllResult");
	if (soap_out_bool(soap, "MultiXTpm:ResumeAllResult", -1, &(a->_MultiXTpm__ResumeAllResponse::ResumeAllResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ResumeAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ResumeAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeAllResponse * SOAP_FMAC4 soap_get__MultiXTpm__ResumeAllResponse(struct soap *soap, _MultiXTpm__ResumeAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ResumeAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ResumeAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ResumeAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeAllResponse * SOAP_FMAC4 soap_in__MultiXTpm__ResumeAllResponse(struct soap *soap, const char *tag, _MultiXTpm__ResumeAllResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ResumeAllResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ResumeAllResponse, sizeof(_MultiXTpm__ResumeAllResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ResumeAllResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ResumeAllResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ResumeAllResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResumeAllResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ResumeAllResult", &(a->_MultiXTpm__ResumeAllResponse::ResumeAllResult), "xsd:boolean"))
				{	soap_flag_ResumeAllResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:ResumeAllResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ResumeAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ResumeAllResponse, 0, sizeof(_MultiXTpm__ResumeAllResponse), 0, soap_copy__MultiXTpm__ResumeAllResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResumeAllResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ResumeAllResponse * SOAP_FMAC6 soap_new__MultiXTpm__ResumeAllResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ResumeAllResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ResumeAllResponse(struct soap *soap, _MultiXTpm__ResumeAllResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ResumeAllResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__ResumeAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ResumeAllResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ResumeAllResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ResumeAllResponse;
		if (size)
			*size = sizeof(_MultiXTpm__ResumeAllResponse);
		((_MultiXTpm__ResumeAllResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ResumeAllResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ResumeAllResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ResumeAllResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ResumeAllResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ResumeAllResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ResumeAllResponse %p -> %p\n", q, p));
	*(_MultiXTpm__ResumeAllResponse*)p = *(_MultiXTpm__ResumeAllResponse*)q;
}

void _MultiXTpm__ResumeAll::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _MultiXTpm__ResumeAll::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__ResumeAll::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ResumeAll);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ResumeAll::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ResumeAll(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ResumeAll(struct soap *soap, const char *tag, int id, const _MultiXTpm__ResumeAll *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ResumeAll), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ResumeAll::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ResumeAll(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeAll * SOAP_FMAC4 soap_get__MultiXTpm__ResumeAll(struct soap *soap, _MultiXTpm__ResumeAll *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ResumeAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ResumeAll::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ResumeAll(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeAll * SOAP_FMAC4 soap_in__MultiXTpm__ResumeAll(struct soap *soap, const char *tag, _MultiXTpm__ResumeAll *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ResumeAll *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ResumeAll, sizeof(_MultiXTpm__ResumeAll), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ResumeAll)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ResumeAll *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ResumeAll *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ResumeAll, 0, sizeof(_MultiXTpm__ResumeAll), 0, soap_copy__MultiXTpm__ResumeAll);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ResumeAll * SOAP_FMAC6 soap_new__MultiXTpm__ResumeAll(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ResumeAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ResumeAll(struct soap *soap, _MultiXTpm__ResumeAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ResumeAll * SOAP_FMAC4 soap_instantiate__MultiXTpm__ResumeAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ResumeAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ResumeAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ResumeAll;
		if (size)
			*size = sizeof(_MultiXTpm__ResumeAll);
		((_MultiXTpm__ResumeAll*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ResumeAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ResumeAll);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ResumeAll*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ResumeAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ResumeAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ResumeAll %p -> %p\n", q, p));
	*(_MultiXTpm__ResumeAll*)p = *(_MultiXTpm__ResumeAll*)q;
}

void _MultiXTpm__SuspendAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__SuspendAllResponse::SuspendAllResult);
	/* transient soap skipped */
}

void _MultiXTpm__SuspendAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__SuspendAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__SuspendAllResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__SuspendAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__SuspendAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__SuspendAllResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__SuspendAllResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__SuspendAllResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:SuspendAllResult");
	if (soap_out_bool(soap, "MultiXTpm:SuspendAllResult", -1, &(a->_MultiXTpm__SuspendAllResponse::SuspendAllResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__SuspendAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__SuspendAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendAllResponse * SOAP_FMAC4 soap_get__MultiXTpm__SuspendAllResponse(struct soap *soap, _MultiXTpm__SuspendAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__SuspendAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__SuspendAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__SuspendAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendAllResponse * SOAP_FMAC4 soap_in__MultiXTpm__SuspendAllResponse(struct soap *soap, const char *tag, _MultiXTpm__SuspendAllResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__SuspendAllResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__SuspendAllResponse, sizeof(_MultiXTpm__SuspendAllResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__SuspendAllResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__SuspendAllResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_SuspendAllResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SuspendAllResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:SuspendAllResult", &(a->_MultiXTpm__SuspendAllResponse::SuspendAllResult), "xsd:boolean"))
				{	soap_flag_SuspendAllResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:SuspendAllResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__SuspendAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__SuspendAllResponse, 0, sizeof(_MultiXTpm__SuspendAllResponse), 0, soap_copy__MultiXTpm__SuspendAllResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SuspendAllResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__SuspendAllResponse * SOAP_FMAC6 soap_new__MultiXTpm__SuspendAllResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__SuspendAllResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__SuspendAllResponse(struct soap *soap, _MultiXTpm__SuspendAllResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__SuspendAllResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__SuspendAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__SuspendAllResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__SuspendAllResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__SuspendAllResponse;
		if (size)
			*size = sizeof(_MultiXTpm__SuspendAllResponse);
		((_MultiXTpm__SuspendAllResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__SuspendAllResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__SuspendAllResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__SuspendAllResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__SuspendAllResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__SuspendAllResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__SuspendAllResponse %p -> %p\n", q, p));
	*(_MultiXTpm__SuspendAllResponse*)p = *(_MultiXTpm__SuspendAllResponse*)q;
}

void _MultiXTpm__SuspendAll::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _MultiXTpm__SuspendAll::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__SuspendAll::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__SuspendAll);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__SuspendAll::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__SuspendAll(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__SuspendAll(struct soap *soap, const char *tag, int id, const _MultiXTpm__SuspendAll *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__SuspendAll), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__SuspendAll::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__SuspendAll(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendAll * SOAP_FMAC4 soap_get__MultiXTpm__SuspendAll(struct soap *soap, _MultiXTpm__SuspendAll *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__SuspendAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__SuspendAll::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__SuspendAll(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendAll * SOAP_FMAC4 soap_in__MultiXTpm__SuspendAll(struct soap *soap, const char *tag, _MultiXTpm__SuspendAll *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__SuspendAll *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__SuspendAll, sizeof(_MultiXTpm__SuspendAll), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__SuspendAll)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__SuspendAll *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__SuspendAll *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__SuspendAll, 0, sizeof(_MultiXTpm__SuspendAll), 0, soap_copy__MultiXTpm__SuspendAll);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__SuspendAll * SOAP_FMAC6 soap_new__MultiXTpm__SuspendAll(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__SuspendAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__SuspendAll(struct soap *soap, _MultiXTpm__SuspendAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__SuspendAll * SOAP_FMAC4 soap_instantiate__MultiXTpm__SuspendAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__SuspendAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__SuspendAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__SuspendAll;
		if (size)
			*size = sizeof(_MultiXTpm__SuspendAll);
		((_MultiXTpm__SuspendAll*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__SuspendAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__SuspendAll);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__SuspendAll*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__SuspendAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__SuspendAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__SuspendAll %p -> %p\n", q, p));
	*(_MultiXTpm__SuspendAll*)p = *(_MultiXTpm__SuspendAll*)q;
}

void _MultiXTpm__ShutdownAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__ShutdownAllResponse::ShutdownAllResult);
	/* transient soap skipped */
}

void _MultiXTpm__ShutdownAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__ShutdownAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ShutdownAllResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ShutdownAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ShutdownAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ShutdownAllResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__ShutdownAllResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ShutdownAllResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:ShutdownAllResult");
	if (soap_out_bool(soap, "MultiXTpm:ShutdownAllResult", -1, &(a->_MultiXTpm__ShutdownAllResponse::ShutdownAllResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ShutdownAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ShutdownAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownAllResponse * SOAP_FMAC4 soap_get__MultiXTpm__ShutdownAllResponse(struct soap *soap, _MultiXTpm__ShutdownAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ShutdownAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ShutdownAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ShutdownAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownAllResponse * SOAP_FMAC4 soap_in__MultiXTpm__ShutdownAllResponse(struct soap *soap, const char *tag, _MultiXTpm__ShutdownAllResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ShutdownAllResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ShutdownAllResponse, sizeof(_MultiXTpm__ShutdownAllResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ShutdownAllResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ShutdownAllResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ShutdownAllResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ShutdownAllResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ShutdownAllResult", &(a->_MultiXTpm__ShutdownAllResponse::ShutdownAllResult), "xsd:boolean"))
				{	soap_flag_ShutdownAllResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:ShutdownAllResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ShutdownAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ShutdownAllResponse, 0, sizeof(_MultiXTpm__ShutdownAllResponse), 0, soap_copy__MultiXTpm__ShutdownAllResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ShutdownAllResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ShutdownAllResponse * SOAP_FMAC6 soap_new__MultiXTpm__ShutdownAllResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ShutdownAllResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ShutdownAllResponse(struct soap *soap, _MultiXTpm__ShutdownAllResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ShutdownAllResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__ShutdownAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ShutdownAllResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ShutdownAllResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownAllResponse;
		if (size)
			*size = sizeof(_MultiXTpm__ShutdownAllResponse);
		((_MultiXTpm__ShutdownAllResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownAllResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ShutdownAllResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ShutdownAllResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ShutdownAllResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ShutdownAllResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ShutdownAllResponse %p -> %p\n", q, p));
	*(_MultiXTpm__ShutdownAllResponse*)p = *(_MultiXTpm__ShutdownAllResponse*)q;
}

void _MultiXTpm__ShutdownAll::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__ShutdownAll::bForce);
	/* transient soap skipped */
}

void _MultiXTpm__ShutdownAll::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__ShutdownAll::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ShutdownAll);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ShutdownAll::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ShutdownAll(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ShutdownAll(struct soap *soap, const char *tag, int id, const _MultiXTpm__ShutdownAll *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ShutdownAll), type))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:bForce", -1, &(a->_MultiXTpm__ShutdownAll::bForce), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ShutdownAll::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ShutdownAll(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownAll * SOAP_FMAC4 soap_get__MultiXTpm__ShutdownAll(struct soap *soap, _MultiXTpm__ShutdownAll *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ShutdownAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ShutdownAll::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ShutdownAll(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownAll * SOAP_FMAC4 soap_in__MultiXTpm__ShutdownAll(struct soap *soap, const char *tag, _MultiXTpm__ShutdownAll *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ShutdownAll *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ShutdownAll, sizeof(_MultiXTpm__ShutdownAll), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ShutdownAll)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ShutdownAll *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_bForce1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bForce1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:bForce", &(a->_MultiXTpm__ShutdownAll::bForce), "xsd:boolean"))
				{	soap_flag_bForce1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ShutdownAll *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ShutdownAll, 0, sizeof(_MultiXTpm__ShutdownAll), 0, soap_copy__MultiXTpm__ShutdownAll);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bForce1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ShutdownAll * SOAP_FMAC6 soap_new__MultiXTpm__ShutdownAll(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ShutdownAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ShutdownAll(struct soap *soap, _MultiXTpm__ShutdownAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ShutdownAll * SOAP_FMAC4 soap_instantiate__MultiXTpm__ShutdownAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ShutdownAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ShutdownAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownAll;
		if (size)
			*size = sizeof(_MultiXTpm__ShutdownAll);
		((_MultiXTpm__ShutdownAll*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ShutdownAll);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ShutdownAll*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ShutdownAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ShutdownAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ShutdownAll %p -> %p\n", q, p));
	*(_MultiXTpm__ShutdownAll*)p = *(_MultiXTpm__ShutdownAll*)q;
}

void _MultiXTpm__StartAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__StartAllResponse::StartAllResult);
	/* transient soap skipped */
}

void _MultiXTpm__StartAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__StartAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__StartAllResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__StartAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__StartAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__StartAllResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__StartAllResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__StartAllResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:StartAllResult");
	if (soap_out_bool(soap, "MultiXTpm:StartAllResult", -1, &(a->_MultiXTpm__StartAllResponse::StartAllResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__StartAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__StartAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__StartAllResponse * SOAP_FMAC4 soap_get__MultiXTpm__StartAllResponse(struct soap *soap, _MultiXTpm__StartAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__StartAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__StartAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__StartAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__StartAllResponse * SOAP_FMAC4 soap_in__MultiXTpm__StartAllResponse(struct soap *soap, const char *tag, _MultiXTpm__StartAllResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__StartAllResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__StartAllResponse, sizeof(_MultiXTpm__StartAllResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__StartAllResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__StartAllResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_StartAllResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartAllResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:StartAllResult", &(a->_MultiXTpm__StartAllResponse::StartAllResult), "xsd:boolean"))
				{	soap_flag_StartAllResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:StartAllResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__StartAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__StartAllResponse, 0, sizeof(_MultiXTpm__StartAllResponse), 0, soap_copy__MultiXTpm__StartAllResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartAllResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__StartAllResponse * SOAP_FMAC6 soap_new__MultiXTpm__StartAllResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__StartAllResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__StartAllResponse(struct soap *soap, _MultiXTpm__StartAllResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__StartAllResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__StartAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__StartAllResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__StartAllResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__StartAllResponse;
		if (size)
			*size = sizeof(_MultiXTpm__StartAllResponse);
		((_MultiXTpm__StartAllResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__StartAllResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__StartAllResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__StartAllResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__StartAllResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__StartAllResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__StartAllResponse %p -> %p\n", q, p));
	*(_MultiXTpm__StartAllResponse*)p = *(_MultiXTpm__StartAllResponse*)q;
}

void _MultiXTpm__StartAll::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _MultiXTpm__StartAll::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__StartAll::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__StartAll);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__StartAll::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__StartAll(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__StartAll(struct soap *soap, const char *tag, int id, const _MultiXTpm__StartAll *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__StartAll), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__StartAll::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__StartAll(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__StartAll * SOAP_FMAC4 soap_get__MultiXTpm__StartAll(struct soap *soap, _MultiXTpm__StartAll *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__StartAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__StartAll::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__StartAll(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__StartAll * SOAP_FMAC4 soap_in__MultiXTpm__StartAll(struct soap *soap, const char *tag, _MultiXTpm__StartAll *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__StartAll *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__StartAll, sizeof(_MultiXTpm__StartAll), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__StartAll)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__StartAll *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__StartAll *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__StartAll, 0, sizeof(_MultiXTpm__StartAll), 0, soap_copy__MultiXTpm__StartAll);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__StartAll * SOAP_FMAC6 soap_new__MultiXTpm__StartAll(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__StartAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__StartAll(struct soap *soap, _MultiXTpm__StartAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__StartAll * SOAP_FMAC4 soap_instantiate__MultiXTpm__StartAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__StartAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__StartAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__StartAll;
		if (size)
			*size = sizeof(_MultiXTpm__StartAll);
		((_MultiXTpm__StartAll*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__StartAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__StartAll);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__StartAll*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__StartAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__StartAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__StartAll %p -> %p\n", q, p));
	*(_MultiXTpm__StartAll*)p = *(_MultiXTpm__StartAll*)q;
}

void _MultiXTpm__RestartAllResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__RestartAllResponse::RestartAllResult);
	/* transient soap skipped */
}

void _MultiXTpm__RestartAllResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__RestartAllResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__RestartAllResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__RestartAllResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__RestartAllResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__RestartAllResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__RestartAllResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__RestartAllResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:RestartAllResult");
	if (soap_out_bool(soap, "MultiXTpm:RestartAllResult", -1, &(a->_MultiXTpm__RestartAllResponse::RestartAllResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__RestartAllResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__RestartAllResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__RestartAllResponse * SOAP_FMAC4 soap_get__MultiXTpm__RestartAllResponse(struct soap *soap, _MultiXTpm__RestartAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__RestartAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__RestartAllResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__RestartAllResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__RestartAllResponse * SOAP_FMAC4 soap_in__MultiXTpm__RestartAllResponse(struct soap *soap, const char *tag, _MultiXTpm__RestartAllResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__RestartAllResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__RestartAllResponse, sizeof(_MultiXTpm__RestartAllResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__RestartAllResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__RestartAllResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_RestartAllResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RestartAllResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:RestartAllResult", &(a->_MultiXTpm__RestartAllResponse::RestartAllResult), "xsd:boolean"))
				{	soap_flag_RestartAllResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:RestartAllResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__RestartAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__RestartAllResponse, 0, sizeof(_MultiXTpm__RestartAllResponse), 0, soap_copy__MultiXTpm__RestartAllResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RestartAllResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__RestartAllResponse * SOAP_FMAC6 soap_new__MultiXTpm__RestartAllResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__RestartAllResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__RestartAllResponse(struct soap *soap, _MultiXTpm__RestartAllResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__RestartAllResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__RestartAllResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__RestartAllResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__RestartAllResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__RestartAllResponse;
		if (size)
			*size = sizeof(_MultiXTpm__RestartAllResponse);
		((_MultiXTpm__RestartAllResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__RestartAllResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__RestartAllResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__RestartAllResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__RestartAllResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__RestartAllResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__RestartAllResponse %p -> %p\n", q, p));
	*(_MultiXTpm__RestartAllResponse*)p = *(_MultiXTpm__RestartAllResponse*)q;
}

void _MultiXTpm__RestartAll::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__RestartAll::bForce);
	/* transient soap skipped */
}

void _MultiXTpm__RestartAll::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__RestartAll::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__RestartAll);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__RestartAll::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__RestartAll(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__RestartAll(struct soap *soap, const char *tag, int id, const _MultiXTpm__RestartAll *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__RestartAll), type))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:bForce", -1, &(a->_MultiXTpm__RestartAll::bForce), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__RestartAll::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__RestartAll(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__RestartAll * SOAP_FMAC4 soap_get__MultiXTpm__RestartAll(struct soap *soap, _MultiXTpm__RestartAll *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__RestartAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__RestartAll::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__RestartAll(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__RestartAll * SOAP_FMAC4 soap_in__MultiXTpm__RestartAll(struct soap *soap, const char *tag, _MultiXTpm__RestartAll *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__RestartAll *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__RestartAll, sizeof(_MultiXTpm__RestartAll), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__RestartAll)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__RestartAll *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_bForce1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bForce1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:bForce", &(a->_MultiXTpm__RestartAll::bForce), "xsd:boolean"))
				{	soap_flag_bForce1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__RestartAll *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__RestartAll, 0, sizeof(_MultiXTpm__RestartAll), 0, soap_copy__MultiXTpm__RestartAll);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bForce1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__RestartAll * SOAP_FMAC6 soap_new__MultiXTpm__RestartAll(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__RestartAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__RestartAll(struct soap *soap, _MultiXTpm__RestartAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__RestartAll * SOAP_FMAC4 soap_instantiate__MultiXTpm__RestartAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__RestartAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__RestartAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__RestartAll;
		if (size)
			*size = sizeof(_MultiXTpm__RestartAll);
		((_MultiXTpm__RestartAll*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__RestartAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__RestartAll);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__RestartAll*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__RestartAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__RestartAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__RestartAll %p -> %p\n", q, p));
	*(_MultiXTpm__RestartAll*)p = *(_MultiXTpm__RestartAll*)q;
}

void _MultiXTpm__ResumeProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__ResumeProcessResponse::ResumeProcessResult);
	/* transient soap skipped */
}

void _MultiXTpm__ResumeProcessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__ResumeProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ResumeProcessResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ResumeProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ResumeProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ResumeProcessResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__ResumeProcessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ResumeProcessResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:ResumeProcessResult");
	if (soap_out_bool(soap, "MultiXTpm:ResumeProcessResult", -1, &(a->_MultiXTpm__ResumeProcessResponse::ResumeProcessResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ResumeProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ResumeProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeProcessResponse * SOAP_FMAC4 soap_get__MultiXTpm__ResumeProcessResponse(struct soap *soap, _MultiXTpm__ResumeProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ResumeProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ResumeProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ResumeProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeProcessResponse * SOAP_FMAC4 soap_in__MultiXTpm__ResumeProcessResponse(struct soap *soap, const char *tag, _MultiXTpm__ResumeProcessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ResumeProcessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ResumeProcessResponse, sizeof(_MultiXTpm__ResumeProcessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ResumeProcessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ResumeProcessResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ResumeProcessResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResumeProcessResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ResumeProcessResult", &(a->_MultiXTpm__ResumeProcessResponse::ResumeProcessResult), "xsd:boolean"))
				{	soap_flag_ResumeProcessResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:ResumeProcessResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ResumeProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ResumeProcessResponse, 0, sizeof(_MultiXTpm__ResumeProcessResponse), 0, soap_copy__MultiXTpm__ResumeProcessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResumeProcessResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ResumeProcessResponse * SOAP_FMAC6 soap_new__MultiXTpm__ResumeProcessResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ResumeProcessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ResumeProcessResponse(struct soap *soap, _MultiXTpm__ResumeProcessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ResumeProcessResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__ResumeProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ResumeProcessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ResumeProcessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ResumeProcessResponse;
		if (size)
			*size = sizeof(_MultiXTpm__ResumeProcessResponse);
		((_MultiXTpm__ResumeProcessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ResumeProcessResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ResumeProcessResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ResumeProcessResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ResumeProcessResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ResumeProcessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ResumeProcessResponse %p -> %p\n", q, p));
	*(_MultiXTpm__ResumeProcessResponse*)p = *(_MultiXTpm__ResumeProcessResponse*)q;
}

void _MultiXTpm__ResumeProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__ResumeProcess::ProcessID = NULL;
	/* transient soap skipped */
}

void _MultiXTpm__ResumeProcess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, &this->_MultiXTpm__ResumeProcess::ProcessID);
	/* transient soap skipped */
}

int _MultiXTpm__ResumeProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ResumeProcess);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ResumeProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ResumeProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ResumeProcess(struct soap *soap, const char *tag, int id, const _MultiXTpm__ResumeProcess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ResumeProcess), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:ProcessID", -1, &(a->_MultiXTpm__ResumeProcess::ProcessID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ResumeProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ResumeProcess(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeProcess * SOAP_FMAC4 soap_get__MultiXTpm__ResumeProcess(struct soap *soap, _MultiXTpm__ResumeProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ResumeProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ResumeProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ResumeProcess(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeProcess * SOAP_FMAC4 soap_in__MultiXTpm__ResumeProcess(struct soap *soap, const char *tag, _MultiXTpm__ResumeProcess *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ResumeProcess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ResumeProcess, sizeof(_MultiXTpm__ResumeProcess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ResumeProcess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ResumeProcess *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ProcessID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:ProcessID", &(a->_MultiXTpm__ResumeProcess::ProcessID), "MultiXTpm:ArrayOfInt1"))
				{	soap_flag_ProcessID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ResumeProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ResumeProcess, 0, sizeof(_MultiXTpm__ResumeProcess), 0, soap_copy__MultiXTpm__ResumeProcess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ResumeProcess * SOAP_FMAC6 soap_new__MultiXTpm__ResumeProcess(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ResumeProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ResumeProcess(struct soap *soap, _MultiXTpm__ResumeProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ResumeProcess * SOAP_FMAC4 soap_instantiate__MultiXTpm__ResumeProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ResumeProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ResumeProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ResumeProcess;
		if (size)
			*size = sizeof(_MultiXTpm__ResumeProcess);
		((_MultiXTpm__ResumeProcess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ResumeProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ResumeProcess);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ResumeProcess*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ResumeProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ResumeProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ResumeProcess %p -> %p\n", q, p));
	*(_MultiXTpm__ResumeProcess*)p = *(_MultiXTpm__ResumeProcess*)q;
}

void _MultiXTpm__ResumeGroupResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__ResumeGroupResponse::ResumeGroupResult);
	/* transient soap skipped */
}

void _MultiXTpm__ResumeGroupResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__ResumeGroupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ResumeGroupResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ResumeGroupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ResumeGroupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ResumeGroupResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__ResumeGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ResumeGroupResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:ResumeGroupResult");
	if (soap_out_bool(soap, "MultiXTpm:ResumeGroupResult", -1, &(a->_MultiXTpm__ResumeGroupResponse::ResumeGroupResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ResumeGroupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ResumeGroupResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeGroupResponse * SOAP_FMAC4 soap_get__MultiXTpm__ResumeGroupResponse(struct soap *soap, _MultiXTpm__ResumeGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ResumeGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ResumeGroupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ResumeGroupResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeGroupResponse * SOAP_FMAC4 soap_in__MultiXTpm__ResumeGroupResponse(struct soap *soap, const char *tag, _MultiXTpm__ResumeGroupResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ResumeGroupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ResumeGroupResponse, sizeof(_MultiXTpm__ResumeGroupResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ResumeGroupResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ResumeGroupResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ResumeGroupResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResumeGroupResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ResumeGroupResult", &(a->_MultiXTpm__ResumeGroupResponse::ResumeGroupResult), "xsd:boolean"))
				{	soap_flag_ResumeGroupResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:ResumeGroupResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ResumeGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ResumeGroupResponse, 0, sizeof(_MultiXTpm__ResumeGroupResponse), 0, soap_copy__MultiXTpm__ResumeGroupResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResumeGroupResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ResumeGroupResponse * SOAP_FMAC6 soap_new__MultiXTpm__ResumeGroupResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ResumeGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ResumeGroupResponse(struct soap *soap, _MultiXTpm__ResumeGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ResumeGroupResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__ResumeGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ResumeGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ResumeGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ResumeGroupResponse;
		if (size)
			*size = sizeof(_MultiXTpm__ResumeGroupResponse);
		((_MultiXTpm__ResumeGroupResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ResumeGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ResumeGroupResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ResumeGroupResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ResumeGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ResumeGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ResumeGroupResponse %p -> %p\n", q, p));
	*(_MultiXTpm__ResumeGroupResponse*)p = *(_MultiXTpm__ResumeGroupResponse*)q;
}

void _MultiXTpm__ResumeGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__ResumeGroup::GroupID = NULL;
	/* transient soap skipped */
}

void _MultiXTpm__ResumeGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, &this->_MultiXTpm__ResumeGroup::GroupID);
	/* transient soap skipped */
}

int _MultiXTpm__ResumeGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ResumeGroup);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ResumeGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ResumeGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ResumeGroup(struct soap *soap, const char *tag, int id, const _MultiXTpm__ResumeGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ResumeGroup), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:GroupID", -1, &(a->_MultiXTpm__ResumeGroup::GroupID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ResumeGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ResumeGroup(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeGroup * SOAP_FMAC4 soap_get__MultiXTpm__ResumeGroup(struct soap *soap, _MultiXTpm__ResumeGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ResumeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ResumeGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ResumeGroup(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeGroup * SOAP_FMAC4 soap_in__MultiXTpm__ResumeGroup(struct soap *soap, const char *tag, _MultiXTpm__ResumeGroup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ResumeGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ResumeGroup, sizeof(_MultiXTpm__ResumeGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ResumeGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ResumeGroup *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GroupID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GroupID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:GroupID", &(a->_MultiXTpm__ResumeGroup::GroupID), "MultiXTpm:ArrayOfInt1"))
				{	soap_flag_GroupID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ResumeGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ResumeGroup, 0, sizeof(_MultiXTpm__ResumeGroup), 0, soap_copy__MultiXTpm__ResumeGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ResumeGroup * SOAP_FMAC6 soap_new__MultiXTpm__ResumeGroup(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ResumeGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ResumeGroup(struct soap *soap, _MultiXTpm__ResumeGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ResumeGroup * SOAP_FMAC4 soap_instantiate__MultiXTpm__ResumeGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ResumeGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ResumeGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ResumeGroup;
		if (size)
			*size = sizeof(_MultiXTpm__ResumeGroup);
		((_MultiXTpm__ResumeGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ResumeGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ResumeGroup);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ResumeGroup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ResumeGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ResumeGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ResumeGroup %p -> %p\n", q, p));
	*(_MultiXTpm__ResumeGroup*)p = *(_MultiXTpm__ResumeGroup*)q;
}

void _MultiXTpm__SuspendProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__SuspendProcessResponse::SuspendProcessResult);
	/* transient soap skipped */
}

void _MultiXTpm__SuspendProcessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__SuspendProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__SuspendProcessResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__SuspendProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__SuspendProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__SuspendProcessResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__SuspendProcessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__SuspendProcessResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:SuspendProcessResult");
	if (soap_out_bool(soap, "MultiXTpm:SuspendProcessResult", -1, &(a->_MultiXTpm__SuspendProcessResponse::SuspendProcessResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__SuspendProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__SuspendProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendProcessResponse * SOAP_FMAC4 soap_get__MultiXTpm__SuspendProcessResponse(struct soap *soap, _MultiXTpm__SuspendProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__SuspendProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__SuspendProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__SuspendProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendProcessResponse * SOAP_FMAC4 soap_in__MultiXTpm__SuspendProcessResponse(struct soap *soap, const char *tag, _MultiXTpm__SuspendProcessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__SuspendProcessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__SuspendProcessResponse, sizeof(_MultiXTpm__SuspendProcessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__SuspendProcessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__SuspendProcessResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_SuspendProcessResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SuspendProcessResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:SuspendProcessResult", &(a->_MultiXTpm__SuspendProcessResponse::SuspendProcessResult), "xsd:boolean"))
				{	soap_flag_SuspendProcessResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:SuspendProcessResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__SuspendProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__SuspendProcessResponse, 0, sizeof(_MultiXTpm__SuspendProcessResponse), 0, soap_copy__MultiXTpm__SuspendProcessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SuspendProcessResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__SuspendProcessResponse * SOAP_FMAC6 soap_new__MultiXTpm__SuspendProcessResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__SuspendProcessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__SuspendProcessResponse(struct soap *soap, _MultiXTpm__SuspendProcessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__SuspendProcessResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__SuspendProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__SuspendProcessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__SuspendProcessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__SuspendProcessResponse;
		if (size)
			*size = sizeof(_MultiXTpm__SuspendProcessResponse);
		((_MultiXTpm__SuspendProcessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__SuspendProcessResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__SuspendProcessResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__SuspendProcessResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__SuspendProcessResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__SuspendProcessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__SuspendProcessResponse %p -> %p\n", q, p));
	*(_MultiXTpm__SuspendProcessResponse*)p = *(_MultiXTpm__SuspendProcessResponse*)q;
}

void _MultiXTpm__SuspendProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__SuspendProcess::ProcessID = NULL;
	/* transient soap skipped */
}

void _MultiXTpm__SuspendProcess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, &this->_MultiXTpm__SuspendProcess::ProcessID);
	/* transient soap skipped */
}

int _MultiXTpm__SuspendProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__SuspendProcess);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__SuspendProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__SuspendProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__SuspendProcess(struct soap *soap, const char *tag, int id, const _MultiXTpm__SuspendProcess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__SuspendProcess), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:ProcessID", -1, &(a->_MultiXTpm__SuspendProcess::ProcessID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__SuspendProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__SuspendProcess(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendProcess * SOAP_FMAC4 soap_get__MultiXTpm__SuspendProcess(struct soap *soap, _MultiXTpm__SuspendProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__SuspendProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__SuspendProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__SuspendProcess(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendProcess * SOAP_FMAC4 soap_in__MultiXTpm__SuspendProcess(struct soap *soap, const char *tag, _MultiXTpm__SuspendProcess *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__SuspendProcess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__SuspendProcess, sizeof(_MultiXTpm__SuspendProcess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__SuspendProcess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__SuspendProcess *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ProcessID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:ProcessID", &(a->_MultiXTpm__SuspendProcess::ProcessID), "MultiXTpm:ArrayOfInt1"))
				{	soap_flag_ProcessID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__SuspendProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__SuspendProcess, 0, sizeof(_MultiXTpm__SuspendProcess), 0, soap_copy__MultiXTpm__SuspendProcess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__SuspendProcess * SOAP_FMAC6 soap_new__MultiXTpm__SuspendProcess(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__SuspendProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__SuspendProcess(struct soap *soap, _MultiXTpm__SuspendProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__SuspendProcess * SOAP_FMAC4 soap_instantiate__MultiXTpm__SuspendProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__SuspendProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__SuspendProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__SuspendProcess;
		if (size)
			*size = sizeof(_MultiXTpm__SuspendProcess);
		((_MultiXTpm__SuspendProcess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__SuspendProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__SuspendProcess);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__SuspendProcess*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__SuspendProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__SuspendProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__SuspendProcess %p -> %p\n", q, p));
	*(_MultiXTpm__SuspendProcess*)p = *(_MultiXTpm__SuspendProcess*)q;
}

void _MultiXTpm__SuspendGroupResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__SuspendGroupResponse::SuspendGroupResult);
	/* transient soap skipped */
}

void _MultiXTpm__SuspendGroupResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__SuspendGroupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__SuspendGroupResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__SuspendGroupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__SuspendGroupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__SuspendGroupResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__SuspendGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__SuspendGroupResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:SuspendGroupResult");
	if (soap_out_bool(soap, "MultiXTpm:SuspendGroupResult", -1, &(a->_MultiXTpm__SuspendGroupResponse::SuspendGroupResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__SuspendGroupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__SuspendGroupResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendGroupResponse * SOAP_FMAC4 soap_get__MultiXTpm__SuspendGroupResponse(struct soap *soap, _MultiXTpm__SuspendGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__SuspendGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__SuspendGroupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__SuspendGroupResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendGroupResponse * SOAP_FMAC4 soap_in__MultiXTpm__SuspendGroupResponse(struct soap *soap, const char *tag, _MultiXTpm__SuspendGroupResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__SuspendGroupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__SuspendGroupResponse, sizeof(_MultiXTpm__SuspendGroupResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__SuspendGroupResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__SuspendGroupResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_SuspendGroupResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SuspendGroupResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:SuspendGroupResult", &(a->_MultiXTpm__SuspendGroupResponse::SuspendGroupResult), "xsd:boolean"))
				{	soap_flag_SuspendGroupResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:SuspendGroupResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__SuspendGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__SuspendGroupResponse, 0, sizeof(_MultiXTpm__SuspendGroupResponse), 0, soap_copy__MultiXTpm__SuspendGroupResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SuspendGroupResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__SuspendGroupResponse * SOAP_FMAC6 soap_new__MultiXTpm__SuspendGroupResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__SuspendGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__SuspendGroupResponse(struct soap *soap, _MultiXTpm__SuspendGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__SuspendGroupResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__SuspendGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__SuspendGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__SuspendGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__SuspendGroupResponse;
		if (size)
			*size = sizeof(_MultiXTpm__SuspendGroupResponse);
		((_MultiXTpm__SuspendGroupResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__SuspendGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__SuspendGroupResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__SuspendGroupResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__SuspendGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__SuspendGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__SuspendGroupResponse %p -> %p\n", q, p));
	*(_MultiXTpm__SuspendGroupResponse*)p = *(_MultiXTpm__SuspendGroupResponse*)q;
}

void _MultiXTpm__SuspendGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__SuspendGroup::GroupID = NULL;
	/* transient soap skipped */
}

void _MultiXTpm__SuspendGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, &this->_MultiXTpm__SuspendGroup::GroupID);
	/* transient soap skipped */
}

int _MultiXTpm__SuspendGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__SuspendGroup);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__SuspendGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__SuspendGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__SuspendGroup(struct soap *soap, const char *tag, int id, const _MultiXTpm__SuspendGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__SuspendGroup), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:GroupID", -1, &(a->_MultiXTpm__SuspendGroup::GroupID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__SuspendGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__SuspendGroup(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendGroup * SOAP_FMAC4 soap_get__MultiXTpm__SuspendGroup(struct soap *soap, _MultiXTpm__SuspendGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__SuspendGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__SuspendGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__SuspendGroup(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendGroup * SOAP_FMAC4 soap_in__MultiXTpm__SuspendGroup(struct soap *soap, const char *tag, _MultiXTpm__SuspendGroup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__SuspendGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__SuspendGroup, sizeof(_MultiXTpm__SuspendGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__SuspendGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__SuspendGroup *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GroupID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GroupID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:GroupID", &(a->_MultiXTpm__SuspendGroup::GroupID), "MultiXTpm:ArrayOfInt1"))
				{	soap_flag_GroupID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__SuspendGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__SuspendGroup, 0, sizeof(_MultiXTpm__SuspendGroup), 0, soap_copy__MultiXTpm__SuspendGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__SuspendGroup * SOAP_FMAC6 soap_new__MultiXTpm__SuspendGroup(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__SuspendGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__SuspendGroup(struct soap *soap, _MultiXTpm__SuspendGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__SuspendGroup * SOAP_FMAC4 soap_instantiate__MultiXTpm__SuspendGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__SuspendGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__SuspendGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__SuspendGroup;
		if (size)
			*size = sizeof(_MultiXTpm__SuspendGroup);
		((_MultiXTpm__SuspendGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__SuspendGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__SuspendGroup);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__SuspendGroup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__SuspendGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__SuspendGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__SuspendGroup %p -> %p\n", q, p));
	*(_MultiXTpm__SuspendGroup*)p = *(_MultiXTpm__SuspendGroup*)q;
}

void _MultiXTpm__ShutdownGroupResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__ShutdownGroupResponse::ShutdownGroupResult);
	/* transient soap skipped */
}

void _MultiXTpm__ShutdownGroupResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__ShutdownGroupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ShutdownGroupResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ShutdownGroupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ShutdownGroupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ShutdownGroupResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__ShutdownGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ShutdownGroupResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:ShutdownGroupResult");
	if (soap_out_bool(soap, "MultiXTpm:ShutdownGroupResult", -1, &(a->_MultiXTpm__ShutdownGroupResponse::ShutdownGroupResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ShutdownGroupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ShutdownGroupResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownGroupResponse * SOAP_FMAC4 soap_get__MultiXTpm__ShutdownGroupResponse(struct soap *soap, _MultiXTpm__ShutdownGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ShutdownGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ShutdownGroupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ShutdownGroupResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownGroupResponse * SOAP_FMAC4 soap_in__MultiXTpm__ShutdownGroupResponse(struct soap *soap, const char *tag, _MultiXTpm__ShutdownGroupResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ShutdownGroupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ShutdownGroupResponse, sizeof(_MultiXTpm__ShutdownGroupResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ShutdownGroupResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ShutdownGroupResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ShutdownGroupResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ShutdownGroupResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ShutdownGroupResult", &(a->_MultiXTpm__ShutdownGroupResponse::ShutdownGroupResult), "xsd:boolean"))
				{	soap_flag_ShutdownGroupResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:ShutdownGroupResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ShutdownGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ShutdownGroupResponse, 0, sizeof(_MultiXTpm__ShutdownGroupResponse), 0, soap_copy__MultiXTpm__ShutdownGroupResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ShutdownGroupResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ShutdownGroupResponse * SOAP_FMAC6 soap_new__MultiXTpm__ShutdownGroupResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ShutdownGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ShutdownGroupResponse(struct soap *soap, _MultiXTpm__ShutdownGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ShutdownGroupResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__ShutdownGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ShutdownGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ShutdownGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownGroupResponse;
		if (size)
			*size = sizeof(_MultiXTpm__ShutdownGroupResponse);
		((_MultiXTpm__ShutdownGroupResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ShutdownGroupResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ShutdownGroupResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ShutdownGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ShutdownGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ShutdownGroupResponse %p -> %p\n", q, p));
	*(_MultiXTpm__ShutdownGroupResponse*)p = *(_MultiXTpm__ShutdownGroupResponse*)q;
}

void _MultiXTpm__ShutdownGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__ShutdownGroup::GroupID = NULL;
	soap_default_bool(soap, &this->_MultiXTpm__ShutdownGroup::bForce);
	/* transient soap skipped */
}

void _MultiXTpm__ShutdownGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, &this->_MultiXTpm__ShutdownGroup::GroupID);
	/* transient soap skipped */
}

int _MultiXTpm__ShutdownGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ShutdownGroup);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ShutdownGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ShutdownGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ShutdownGroup(struct soap *soap, const char *tag, int id, const _MultiXTpm__ShutdownGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ShutdownGroup), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:GroupID", -1, &(a->_MultiXTpm__ShutdownGroup::GroupID), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:bForce", -1, &(a->_MultiXTpm__ShutdownGroup::bForce), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ShutdownGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ShutdownGroup(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownGroup * SOAP_FMAC4 soap_get__MultiXTpm__ShutdownGroup(struct soap *soap, _MultiXTpm__ShutdownGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ShutdownGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ShutdownGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ShutdownGroup(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownGroup * SOAP_FMAC4 soap_in__MultiXTpm__ShutdownGroup(struct soap *soap, const char *tag, _MultiXTpm__ShutdownGroup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ShutdownGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ShutdownGroup, sizeof(_MultiXTpm__ShutdownGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ShutdownGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ShutdownGroup *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GroupID1 = 1, soap_flag_bForce1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GroupID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:GroupID", &(a->_MultiXTpm__ShutdownGroup::GroupID), "MultiXTpm:ArrayOfInt1"))
				{	soap_flag_GroupID1--;
					continue;
				}
			if (soap_flag_bForce1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:bForce", &(a->_MultiXTpm__ShutdownGroup::bForce), "xsd:boolean"))
				{	soap_flag_bForce1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ShutdownGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ShutdownGroup, 0, sizeof(_MultiXTpm__ShutdownGroup), 0, soap_copy__MultiXTpm__ShutdownGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bForce1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ShutdownGroup * SOAP_FMAC6 soap_new__MultiXTpm__ShutdownGroup(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ShutdownGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ShutdownGroup(struct soap *soap, _MultiXTpm__ShutdownGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ShutdownGroup * SOAP_FMAC4 soap_instantiate__MultiXTpm__ShutdownGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ShutdownGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ShutdownGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownGroup;
		if (size)
			*size = sizeof(_MultiXTpm__ShutdownGroup);
		((_MultiXTpm__ShutdownGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ShutdownGroup);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ShutdownGroup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ShutdownGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ShutdownGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ShutdownGroup %p -> %p\n", q, p));
	*(_MultiXTpm__ShutdownGroup*)p = *(_MultiXTpm__ShutdownGroup*)q;
}

void _MultiXTpm__ShutdownProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__ShutdownProcessResponse::ShutdownProcessResult);
	/* transient soap skipped */
}

void _MultiXTpm__ShutdownProcessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__ShutdownProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ShutdownProcessResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ShutdownProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ShutdownProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ShutdownProcessResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__ShutdownProcessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ShutdownProcessResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:ShutdownProcessResult");
	if (soap_out_bool(soap, "MultiXTpm:ShutdownProcessResult", -1, &(a->_MultiXTpm__ShutdownProcessResponse::ShutdownProcessResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ShutdownProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ShutdownProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownProcessResponse * SOAP_FMAC4 soap_get__MultiXTpm__ShutdownProcessResponse(struct soap *soap, _MultiXTpm__ShutdownProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ShutdownProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ShutdownProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ShutdownProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownProcessResponse * SOAP_FMAC4 soap_in__MultiXTpm__ShutdownProcessResponse(struct soap *soap, const char *tag, _MultiXTpm__ShutdownProcessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ShutdownProcessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ShutdownProcessResponse, sizeof(_MultiXTpm__ShutdownProcessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ShutdownProcessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ShutdownProcessResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ShutdownProcessResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ShutdownProcessResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ShutdownProcessResult", &(a->_MultiXTpm__ShutdownProcessResponse::ShutdownProcessResult), "xsd:boolean"))
				{	soap_flag_ShutdownProcessResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:ShutdownProcessResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ShutdownProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ShutdownProcessResponse, 0, sizeof(_MultiXTpm__ShutdownProcessResponse), 0, soap_copy__MultiXTpm__ShutdownProcessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ShutdownProcessResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ShutdownProcessResponse * SOAP_FMAC6 soap_new__MultiXTpm__ShutdownProcessResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ShutdownProcessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ShutdownProcessResponse(struct soap *soap, _MultiXTpm__ShutdownProcessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ShutdownProcessResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__ShutdownProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ShutdownProcessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ShutdownProcessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownProcessResponse;
		if (size)
			*size = sizeof(_MultiXTpm__ShutdownProcessResponse);
		((_MultiXTpm__ShutdownProcessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownProcessResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ShutdownProcessResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ShutdownProcessResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ShutdownProcessResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ShutdownProcessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ShutdownProcessResponse %p -> %p\n", q, p));
	*(_MultiXTpm__ShutdownProcessResponse*)p = *(_MultiXTpm__ShutdownProcessResponse*)q;
}

void _MultiXTpm__ShutdownProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__ShutdownProcess::ProcessID = NULL;
	soap_default_bool(soap, &this->_MultiXTpm__ShutdownProcess::bForce);
	/* transient soap skipped */
}

void _MultiXTpm__ShutdownProcess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, &this->_MultiXTpm__ShutdownProcess::ProcessID);
	/* transient soap skipped */
}

int _MultiXTpm__ShutdownProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__ShutdownProcess);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__ShutdownProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__ShutdownProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__ShutdownProcess(struct soap *soap, const char *tag, int id, const _MultiXTpm__ShutdownProcess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__ShutdownProcess), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:ProcessID", -1, &(a->_MultiXTpm__ShutdownProcess::ProcessID), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:bForce", -1, &(a->_MultiXTpm__ShutdownProcess::bForce), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__ShutdownProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__ShutdownProcess(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownProcess * SOAP_FMAC4 soap_get__MultiXTpm__ShutdownProcess(struct soap *soap, _MultiXTpm__ShutdownProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__ShutdownProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__ShutdownProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__ShutdownProcess(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownProcess * SOAP_FMAC4 soap_in__MultiXTpm__ShutdownProcess(struct soap *soap, const char *tag, _MultiXTpm__ShutdownProcess *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__ShutdownProcess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__ShutdownProcess, sizeof(_MultiXTpm__ShutdownProcess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__ShutdownProcess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__ShutdownProcess *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ProcessID1 = 1, soap_flag_bForce1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:ProcessID", &(a->_MultiXTpm__ShutdownProcess::ProcessID), "MultiXTpm:ArrayOfInt1"))
				{	soap_flag_ProcessID1--;
					continue;
				}
			if (soap_flag_bForce1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:bForce", &(a->_MultiXTpm__ShutdownProcess::bForce), "xsd:boolean"))
				{	soap_flag_bForce1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__ShutdownProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__ShutdownProcess, 0, sizeof(_MultiXTpm__ShutdownProcess), 0, soap_copy__MultiXTpm__ShutdownProcess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bForce1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__ShutdownProcess * SOAP_FMAC6 soap_new__MultiXTpm__ShutdownProcess(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__ShutdownProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__ShutdownProcess(struct soap *soap, _MultiXTpm__ShutdownProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__ShutdownProcess * SOAP_FMAC4 soap_instantiate__MultiXTpm__ShutdownProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__ShutdownProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__ShutdownProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownProcess;
		if (size)
			*size = sizeof(_MultiXTpm__ShutdownProcess);
		((_MultiXTpm__ShutdownProcess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__ShutdownProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__ShutdownProcess);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__ShutdownProcess*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__ShutdownProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__ShutdownProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__ShutdownProcess %p -> %p\n", q, p));
	*(_MultiXTpm__ShutdownProcess*)p = *(_MultiXTpm__ShutdownProcess*)q;
}

void _MultiXTpm__StartGroupResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__StartGroupResponse::StartGroupResult);
	/* transient soap skipped */
}

void _MultiXTpm__StartGroupResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__StartGroupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__StartGroupResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__StartGroupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__StartGroupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__StartGroupResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__StartGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__StartGroupResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:StartGroupResult");
	if (soap_out_bool(soap, "MultiXTpm:StartGroupResult", -1, &(a->_MultiXTpm__StartGroupResponse::StartGroupResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__StartGroupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__StartGroupResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__StartGroupResponse * SOAP_FMAC4 soap_get__MultiXTpm__StartGroupResponse(struct soap *soap, _MultiXTpm__StartGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__StartGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__StartGroupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__StartGroupResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__StartGroupResponse * SOAP_FMAC4 soap_in__MultiXTpm__StartGroupResponse(struct soap *soap, const char *tag, _MultiXTpm__StartGroupResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__StartGroupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__StartGroupResponse, sizeof(_MultiXTpm__StartGroupResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__StartGroupResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__StartGroupResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_StartGroupResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartGroupResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:StartGroupResult", &(a->_MultiXTpm__StartGroupResponse::StartGroupResult), "xsd:boolean"))
				{	soap_flag_StartGroupResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:StartGroupResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__StartGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__StartGroupResponse, 0, sizeof(_MultiXTpm__StartGroupResponse), 0, soap_copy__MultiXTpm__StartGroupResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartGroupResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__StartGroupResponse * SOAP_FMAC6 soap_new__MultiXTpm__StartGroupResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__StartGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__StartGroupResponse(struct soap *soap, _MultiXTpm__StartGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__StartGroupResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__StartGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__StartGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__StartGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__StartGroupResponse;
		if (size)
			*size = sizeof(_MultiXTpm__StartGroupResponse);
		((_MultiXTpm__StartGroupResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__StartGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__StartGroupResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__StartGroupResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__StartGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__StartGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__StartGroupResponse %p -> %p\n", q, p));
	*(_MultiXTpm__StartGroupResponse*)p = *(_MultiXTpm__StartGroupResponse*)q;
}

void _MultiXTpm__StartGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__StartGroup::GroupID = NULL;
	/* transient soap skipped */
}

void _MultiXTpm__StartGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, &this->_MultiXTpm__StartGroup::GroupID);
	/* transient soap skipped */
}

int _MultiXTpm__StartGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__StartGroup);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__StartGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__StartGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__StartGroup(struct soap *soap, const char *tag, int id, const _MultiXTpm__StartGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__StartGroup), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:GroupID", -1, &(a->_MultiXTpm__StartGroup::GroupID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__StartGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__StartGroup(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__StartGroup * SOAP_FMAC4 soap_get__MultiXTpm__StartGroup(struct soap *soap, _MultiXTpm__StartGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__StartGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__StartGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__StartGroup(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__StartGroup * SOAP_FMAC4 soap_in__MultiXTpm__StartGroup(struct soap *soap, const char *tag, _MultiXTpm__StartGroup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__StartGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__StartGroup, sizeof(_MultiXTpm__StartGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__StartGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__StartGroup *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GroupID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GroupID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:GroupID", &(a->_MultiXTpm__StartGroup::GroupID), "MultiXTpm:ArrayOfInt1"))
				{	soap_flag_GroupID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__StartGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__StartGroup, 0, sizeof(_MultiXTpm__StartGroup), 0, soap_copy__MultiXTpm__StartGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__StartGroup * SOAP_FMAC6 soap_new__MultiXTpm__StartGroup(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__StartGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__StartGroup(struct soap *soap, _MultiXTpm__StartGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__StartGroup * SOAP_FMAC4 soap_instantiate__MultiXTpm__StartGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__StartGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__StartGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__StartGroup;
		if (size)
			*size = sizeof(_MultiXTpm__StartGroup);
		((_MultiXTpm__StartGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__StartGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__StartGroup);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__StartGroup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__StartGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__StartGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__StartGroup %p -> %p\n", q, p));
	*(_MultiXTpm__StartGroup*)p = *(_MultiXTpm__StartGroup*)q;
}

void _MultiXTpm__StartProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__StartProcessResponse::StartProcessResult);
	/* transient soap skipped */
}

void _MultiXTpm__StartProcessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__StartProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__StartProcessResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__StartProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__StartProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__StartProcessResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__StartProcessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__StartProcessResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:StartProcessResult");
	if (soap_out_bool(soap, "MultiXTpm:StartProcessResult", -1, &(a->_MultiXTpm__StartProcessResponse::StartProcessResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__StartProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__StartProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__StartProcessResponse * SOAP_FMAC4 soap_get__MultiXTpm__StartProcessResponse(struct soap *soap, _MultiXTpm__StartProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__StartProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__StartProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__StartProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__StartProcessResponse * SOAP_FMAC4 soap_in__MultiXTpm__StartProcessResponse(struct soap *soap, const char *tag, _MultiXTpm__StartProcessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__StartProcessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__StartProcessResponse, sizeof(_MultiXTpm__StartProcessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__StartProcessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__StartProcessResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_StartProcessResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartProcessResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:StartProcessResult", &(a->_MultiXTpm__StartProcessResponse::StartProcessResult), "xsd:boolean"))
				{	soap_flag_StartProcessResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:StartProcessResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__StartProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__StartProcessResponse, 0, sizeof(_MultiXTpm__StartProcessResponse), 0, soap_copy__MultiXTpm__StartProcessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartProcessResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__StartProcessResponse * SOAP_FMAC6 soap_new__MultiXTpm__StartProcessResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__StartProcessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__StartProcessResponse(struct soap *soap, _MultiXTpm__StartProcessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__StartProcessResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__StartProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__StartProcessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__StartProcessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__StartProcessResponse;
		if (size)
			*size = sizeof(_MultiXTpm__StartProcessResponse);
		((_MultiXTpm__StartProcessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__StartProcessResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__StartProcessResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__StartProcessResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__StartProcessResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__StartProcessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__StartProcessResponse %p -> %p\n", q, p));
	*(_MultiXTpm__StartProcessResponse*)p = *(_MultiXTpm__StartProcessResponse*)q;
}

void _MultiXTpm__StartProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__StartProcess::ProcessID = NULL;
	/* transient soap skipped */
}

void _MultiXTpm__StartProcess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, &this->_MultiXTpm__StartProcess::ProcessID);
	/* transient soap skipped */
}

int _MultiXTpm__StartProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__StartProcess);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__StartProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__StartProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__StartProcess(struct soap *soap, const char *tag, int id, const _MultiXTpm__StartProcess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__StartProcess), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:ProcessID", -1, &(a->_MultiXTpm__StartProcess::ProcessID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__StartProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__StartProcess(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__StartProcess * SOAP_FMAC4 soap_get__MultiXTpm__StartProcess(struct soap *soap, _MultiXTpm__StartProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__StartProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__StartProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__StartProcess(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__StartProcess * SOAP_FMAC4 soap_in__MultiXTpm__StartProcess(struct soap *soap, const char *tag, _MultiXTpm__StartProcess *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__StartProcess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__StartProcess, sizeof(_MultiXTpm__StartProcess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__StartProcess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__StartProcess *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ProcessID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:ProcessID", &(a->_MultiXTpm__StartProcess::ProcessID), "MultiXTpm:ArrayOfInt1"))
				{	soap_flag_ProcessID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__StartProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__StartProcess, 0, sizeof(_MultiXTpm__StartProcess), 0, soap_copy__MultiXTpm__StartProcess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__StartProcess * SOAP_FMAC6 soap_new__MultiXTpm__StartProcess(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__StartProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__StartProcess(struct soap *soap, _MultiXTpm__StartProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__StartProcess * SOAP_FMAC4 soap_instantiate__MultiXTpm__StartProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__StartProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__StartProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__StartProcess;
		if (size)
			*size = sizeof(_MultiXTpm__StartProcess);
		((_MultiXTpm__StartProcess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__StartProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__StartProcess);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__StartProcess*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__StartProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__StartProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__StartProcess %p -> %p\n", q, p));
	*(_MultiXTpm__StartProcess*)p = *(_MultiXTpm__StartProcess*)q;
}

void _MultiXTpm__RestartGroupResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__RestartGroupResponse::RestartGroupResult);
	/* transient soap skipped */
}

void _MultiXTpm__RestartGroupResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__RestartGroupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__RestartGroupResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__RestartGroupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__RestartGroupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__RestartGroupResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__RestartGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__RestartGroupResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:RestartGroupResult");
	if (soap_out_bool(soap, "MultiXTpm:RestartGroupResult", -1, &(a->_MultiXTpm__RestartGroupResponse::RestartGroupResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__RestartGroupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__RestartGroupResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__RestartGroupResponse * SOAP_FMAC4 soap_get__MultiXTpm__RestartGroupResponse(struct soap *soap, _MultiXTpm__RestartGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__RestartGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__RestartGroupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__RestartGroupResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__RestartGroupResponse * SOAP_FMAC4 soap_in__MultiXTpm__RestartGroupResponse(struct soap *soap, const char *tag, _MultiXTpm__RestartGroupResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__RestartGroupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__RestartGroupResponse, sizeof(_MultiXTpm__RestartGroupResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__RestartGroupResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__RestartGroupResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_RestartGroupResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RestartGroupResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:RestartGroupResult", &(a->_MultiXTpm__RestartGroupResponse::RestartGroupResult), "xsd:boolean"))
				{	soap_flag_RestartGroupResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:RestartGroupResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__RestartGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__RestartGroupResponse, 0, sizeof(_MultiXTpm__RestartGroupResponse), 0, soap_copy__MultiXTpm__RestartGroupResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RestartGroupResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__RestartGroupResponse * SOAP_FMAC6 soap_new__MultiXTpm__RestartGroupResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__RestartGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__RestartGroupResponse(struct soap *soap, _MultiXTpm__RestartGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__RestartGroupResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__RestartGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__RestartGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__RestartGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__RestartGroupResponse;
		if (size)
			*size = sizeof(_MultiXTpm__RestartGroupResponse);
		((_MultiXTpm__RestartGroupResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__RestartGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__RestartGroupResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__RestartGroupResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__RestartGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__RestartGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__RestartGroupResponse %p -> %p\n", q, p));
	*(_MultiXTpm__RestartGroupResponse*)p = *(_MultiXTpm__RestartGroupResponse*)q;
}

void _MultiXTpm__RestartGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__RestartGroup::GroupID = NULL;
	soap_default_bool(soap, &this->_MultiXTpm__RestartGroup::bForce);
	/* transient soap skipped */
}

void _MultiXTpm__RestartGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, &this->_MultiXTpm__RestartGroup::GroupID);
	/* transient soap skipped */
}

int _MultiXTpm__RestartGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__RestartGroup);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__RestartGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__RestartGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__RestartGroup(struct soap *soap, const char *tag, int id, const _MultiXTpm__RestartGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__RestartGroup), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:GroupID", -1, &(a->_MultiXTpm__RestartGroup::GroupID), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:bForce", -1, &(a->_MultiXTpm__RestartGroup::bForce), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__RestartGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__RestartGroup(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__RestartGroup * SOAP_FMAC4 soap_get__MultiXTpm__RestartGroup(struct soap *soap, _MultiXTpm__RestartGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__RestartGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__RestartGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__RestartGroup(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__RestartGroup * SOAP_FMAC4 soap_in__MultiXTpm__RestartGroup(struct soap *soap, const char *tag, _MultiXTpm__RestartGroup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__RestartGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__RestartGroup, sizeof(_MultiXTpm__RestartGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__RestartGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__RestartGroup *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GroupID1 = 1, soap_flag_bForce1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GroupID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:GroupID", &(a->_MultiXTpm__RestartGroup::GroupID), "MultiXTpm:ArrayOfInt1"))
				{	soap_flag_GroupID1--;
					continue;
				}
			if (soap_flag_bForce1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:bForce", &(a->_MultiXTpm__RestartGroup::bForce), "xsd:boolean"))
				{	soap_flag_bForce1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__RestartGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__RestartGroup, 0, sizeof(_MultiXTpm__RestartGroup), 0, soap_copy__MultiXTpm__RestartGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bForce1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__RestartGroup * SOAP_FMAC6 soap_new__MultiXTpm__RestartGroup(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__RestartGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__RestartGroup(struct soap *soap, _MultiXTpm__RestartGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__RestartGroup * SOAP_FMAC4 soap_instantiate__MultiXTpm__RestartGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__RestartGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__RestartGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__RestartGroup;
		if (size)
			*size = sizeof(_MultiXTpm__RestartGroup);
		((_MultiXTpm__RestartGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__RestartGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__RestartGroup);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__RestartGroup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__RestartGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__RestartGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__RestartGroup %p -> %p\n", q, p));
	*(_MultiXTpm__RestartGroup*)p = *(_MultiXTpm__RestartGroup*)q;
}

void _MultiXTpm__RestartProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__RestartProcessResponse::RestartProcessResult);
	/* transient soap skipped */
}

void _MultiXTpm__RestartProcessResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__RestartProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__RestartProcessResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__RestartProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__RestartProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__RestartProcessResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__RestartProcessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__RestartProcessResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:RestartProcessResult");
	if (soap_out_bool(soap, "MultiXTpm:RestartProcessResult", -1, &(a->_MultiXTpm__RestartProcessResponse::RestartProcessResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__RestartProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__RestartProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__RestartProcessResponse * SOAP_FMAC4 soap_get__MultiXTpm__RestartProcessResponse(struct soap *soap, _MultiXTpm__RestartProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__RestartProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__RestartProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__RestartProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__RestartProcessResponse * SOAP_FMAC4 soap_in__MultiXTpm__RestartProcessResponse(struct soap *soap, const char *tag, _MultiXTpm__RestartProcessResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__RestartProcessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__RestartProcessResponse, sizeof(_MultiXTpm__RestartProcessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__RestartProcessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__RestartProcessResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_RestartProcessResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RestartProcessResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:RestartProcessResult", &(a->_MultiXTpm__RestartProcessResponse::RestartProcessResult), "xsd:boolean"))
				{	soap_flag_RestartProcessResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:RestartProcessResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__RestartProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__RestartProcessResponse, 0, sizeof(_MultiXTpm__RestartProcessResponse), 0, soap_copy__MultiXTpm__RestartProcessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RestartProcessResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__RestartProcessResponse * SOAP_FMAC6 soap_new__MultiXTpm__RestartProcessResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__RestartProcessResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__RestartProcessResponse(struct soap *soap, _MultiXTpm__RestartProcessResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__RestartProcessResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__RestartProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__RestartProcessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__RestartProcessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__RestartProcessResponse;
		if (size)
			*size = sizeof(_MultiXTpm__RestartProcessResponse);
		((_MultiXTpm__RestartProcessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__RestartProcessResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__RestartProcessResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__RestartProcessResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__RestartProcessResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__RestartProcessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__RestartProcessResponse %p -> %p\n", q, p));
	*(_MultiXTpm__RestartProcessResponse*)p = *(_MultiXTpm__RestartProcessResponse*)q;
}

void _MultiXTpm__RestartProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__RestartProcess::ProcessID = NULL;
	soap_default_bool(soap, &this->_MultiXTpm__RestartProcess::bForce);
	/* transient soap skipped */
}

void _MultiXTpm__RestartProcess::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt1(soap, &this->_MultiXTpm__RestartProcess::ProcessID);
	/* transient soap skipped */
}

int _MultiXTpm__RestartProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__RestartProcess);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__RestartProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__RestartProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__RestartProcess(struct soap *soap, const char *tag, int id, const _MultiXTpm__RestartProcess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__RestartProcess), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:ProcessID", -1, &(a->_MultiXTpm__RestartProcess::ProcessID), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:bForce", -1, &(a->_MultiXTpm__RestartProcess::bForce), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__RestartProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__RestartProcess(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__RestartProcess * SOAP_FMAC4 soap_get__MultiXTpm__RestartProcess(struct soap *soap, _MultiXTpm__RestartProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__RestartProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__RestartProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__RestartProcess(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__RestartProcess * SOAP_FMAC4 soap_in__MultiXTpm__RestartProcess(struct soap *soap, const char *tag, _MultiXTpm__RestartProcess *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__RestartProcess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__RestartProcess, sizeof(_MultiXTpm__RestartProcess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__RestartProcess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__RestartProcess *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ProcessID1 = 1, soap_flag_bForce1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProcessID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, "MultiXTpm:ProcessID", &(a->_MultiXTpm__RestartProcess::ProcessID), "MultiXTpm:ArrayOfInt1"))
				{	soap_flag_ProcessID1--;
					continue;
				}
			if (soap_flag_bForce1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:bForce", &(a->_MultiXTpm__RestartProcess::bForce), "xsd:boolean"))
				{	soap_flag_bForce1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__RestartProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__RestartProcess, 0, sizeof(_MultiXTpm__RestartProcess), 0, soap_copy__MultiXTpm__RestartProcess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bForce1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__RestartProcess * SOAP_FMAC6 soap_new__MultiXTpm__RestartProcess(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__RestartProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__RestartProcess(struct soap *soap, _MultiXTpm__RestartProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__RestartProcess * SOAP_FMAC4 soap_instantiate__MultiXTpm__RestartProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__RestartProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__RestartProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__RestartProcess;
		if (size)
			*size = sizeof(_MultiXTpm__RestartProcess);
		((_MultiXTpm__RestartProcess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__RestartProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__RestartProcess);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__RestartProcess*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__RestartProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__RestartProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__RestartProcess %p -> %p\n", q, p));
	*(_MultiXTpm__RestartProcess*)p = *(_MultiXTpm__RestartProcess*)q;
}

void _MultiXTpm__GetSystemStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__GetSystemStatusResponse::GetSystemStatusResult = NULL;
	this->_MultiXTpm__GetSystemStatusResponse::Config = NULL;
	/* transient soap skipped */
}

void _MultiXTpm__GetSystemStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__SystemStatus(soap, &this->_MultiXTpm__GetSystemStatusResponse::GetSystemStatusResult);
	soap_serialize_PointerToMultiXTpm__ConfigData(soap, &this->_MultiXTpm__GetSystemStatusResponse::Config);
	/* transient soap skipped */
}

int _MultiXTpm__GetSystemStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__GetSystemStatusResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__GetSystemStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__GetSystemStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__GetSystemStatusResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__GetSystemStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__GetSystemStatusResponse), type))
		return soap->error;
	if (a->GetSystemStatusResult)
		soap_element_result(soap, "MultiXTpm:GetSystemStatusResult");
	if (soap_out_PointerToMultiXTpm__SystemStatus(soap, "MultiXTpm:GetSystemStatusResult", -1, &(a->_MultiXTpm__GetSystemStatusResponse::GetSystemStatusResult), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ConfigData(soap, "MultiXTpm:Config", -1, &(a->_MultiXTpm__GetSystemStatusResponse::Config), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__GetSystemStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__GetSystemStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__GetSystemStatusResponse * SOAP_FMAC4 soap_get__MultiXTpm__GetSystemStatusResponse(struct soap *soap, _MultiXTpm__GetSystemStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__GetSystemStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__GetSystemStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__GetSystemStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__GetSystemStatusResponse * SOAP_FMAC4 soap_in__MultiXTpm__GetSystemStatusResponse(struct soap *soap, const char *tag, _MultiXTpm__GetSystemStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__GetSystemStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__GetSystemStatusResponse, sizeof(_MultiXTpm__GetSystemStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__GetSystemStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__GetSystemStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetSystemStatusResult1 = 1, soap_flag_Config1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetSystemStatusResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__SystemStatus(soap, "MultiXTpm:GetSystemStatusResult", &(a->_MultiXTpm__GetSystemStatusResponse::GetSystemStatusResult), "MultiXTpm:SystemStatus"))
				{	soap_flag_GetSystemStatusResult1--;
					continue;
				}
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ConfigData(soap, "MultiXTpm:Config", &(a->_MultiXTpm__GetSystemStatusResponse::Config), "MultiXTpm:ConfigData"))
				{	soap_flag_Config1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:GetSystemStatusResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__GetSystemStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__GetSystemStatusResponse, 0, sizeof(_MultiXTpm__GetSystemStatusResponse), 0, soap_copy__MultiXTpm__GetSystemStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__GetSystemStatusResponse * SOAP_FMAC6 soap_new__MultiXTpm__GetSystemStatusResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__GetSystemStatusResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__GetSystemStatusResponse(struct soap *soap, _MultiXTpm__GetSystemStatusResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__GetSystemStatusResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__GetSystemStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__GetSystemStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__GetSystemStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__GetSystemStatusResponse;
		if (size)
			*size = sizeof(_MultiXTpm__GetSystemStatusResponse);
		((_MultiXTpm__GetSystemStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__GetSystemStatusResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__GetSystemStatusResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__GetSystemStatusResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__GetSystemStatusResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__GetSystemStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__GetSystemStatusResponse %p -> %p\n", q, p));
	*(_MultiXTpm__GetSystemStatusResponse*)p = *(_MultiXTpm__GetSystemStatusResponse*)q;
}

void _MultiXTpm__GetSystemStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->_MultiXTpm__GetSystemStatus::LastConfigTime);
	/* transient soap skipped */
}

void _MultiXTpm__GetSystemStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__GetSystemStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__GetSystemStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__GetSystemStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__GetSystemStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__GetSystemStatus(struct soap *soap, const char *tag, int id, const _MultiXTpm__GetSystemStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__GetSystemStatus), type))
		return soap->error;
	if (soap_out_time(soap, "MultiXTpm:LastConfigTime", -1, &(a->_MultiXTpm__GetSystemStatus::LastConfigTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__GetSystemStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__GetSystemStatus(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__GetSystemStatus * SOAP_FMAC4 soap_get__MultiXTpm__GetSystemStatus(struct soap *soap, _MultiXTpm__GetSystemStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__GetSystemStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__GetSystemStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__GetSystemStatus(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__GetSystemStatus * SOAP_FMAC4 soap_in__MultiXTpm__GetSystemStatus(struct soap *soap, const char *tag, _MultiXTpm__GetSystemStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__GetSystemStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__GetSystemStatus, sizeof(_MultiXTpm__GetSystemStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__GetSystemStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__GetSystemStatus *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_LastConfigTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LastConfigTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "MultiXTpm:LastConfigTime", &(a->_MultiXTpm__GetSystemStatus::LastConfigTime), "xsd:dateTime"))
				{	soap_flag_LastConfigTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__GetSystemStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__GetSystemStatus, 0, sizeof(_MultiXTpm__GetSystemStatus), 0, soap_copy__MultiXTpm__GetSystemStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LastConfigTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__GetSystemStatus * SOAP_FMAC6 soap_new__MultiXTpm__GetSystemStatus(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__GetSystemStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__GetSystemStatus(struct soap *soap, _MultiXTpm__GetSystemStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__GetSystemStatus * SOAP_FMAC4 soap_instantiate__MultiXTpm__GetSystemStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__GetSystemStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__GetSystemStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__GetSystemStatus;
		if (size)
			*size = sizeof(_MultiXTpm__GetSystemStatus);
		((_MultiXTpm__GetSystemStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__GetSystemStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__GetSystemStatus);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__GetSystemStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__GetSystemStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__GetSystemStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__GetSystemStatus %p -> %p\n", q, p));
	*(_MultiXTpm__GetSystemStatus*)p = *(_MultiXTpm__GetSystemStatus*)q;
}

void _MultiXTpm__UpdateConfigResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_MultiXTpm__UpdateConfigResponse::UpdateConfigResult);
	this->_MultiXTpm__UpdateConfigResponse::Config = NULL;
	/* transient soap skipped */
}

void _MultiXTpm__UpdateConfigResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ConfigData(soap, &this->_MultiXTpm__UpdateConfigResponse::Config);
	/* transient soap skipped */
}

int _MultiXTpm__UpdateConfigResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__UpdateConfigResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__UpdateConfigResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__UpdateConfigResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__UpdateConfigResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__UpdateConfigResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__UpdateConfigResponse), type))
		return soap->error;
	soap_element_result(soap, "MultiXTpm:UpdateConfigResult");
	if (soap_out_bool(soap, "MultiXTpm:UpdateConfigResult", -1, &(a->_MultiXTpm__UpdateConfigResponse::UpdateConfigResult), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ConfigData(soap, "MultiXTpm:Config", -1, &(a->_MultiXTpm__UpdateConfigResponse::Config), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__UpdateConfigResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__UpdateConfigResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__UpdateConfigResponse * SOAP_FMAC4 soap_get__MultiXTpm__UpdateConfigResponse(struct soap *soap, _MultiXTpm__UpdateConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__UpdateConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__UpdateConfigResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__UpdateConfigResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__UpdateConfigResponse * SOAP_FMAC4 soap_in__MultiXTpm__UpdateConfigResponse(struct soap *soap, const char *tag, _MultiXTpm__UpdateConfigResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__UpdateConfigResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__UpdateConfigResponse, sizeof(_MultiXTpm__UpdateConfigResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__UpdateConfigResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__UpdateConfigResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_UpdateConfigResult1 = 1, soap_flag_Config1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateConfigResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:UpdateConfigResult", &(a->_MultiXTpm__UpdateConfigResponse::UpdateConfigResult), "xsd:boolean"))
				{	soap_flag_UpdateConfigResult1--;
					continue;
				}
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ConfigData(soap, "MultiXTpm:Config", &(a->_MultiXTpm__UpdateConfigResponse::Config), "MultiXTpm:ConfigData"))
				{	soap_flag_Config1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:UpdateConfigResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__UpdateConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__UpdateConfigResponse, 0, sizeof(_MultiXTpm__UpdateConfigResponse), 0, soap_copy__MultiXTpm__UpdateConfigResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UpdateConfigResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__UpdateConfigResponse * SOAP_FMAC6 soap_new__MultiXTpm__UpdateConfigResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__UpdateConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__UpdateConfigResponse(struct soap *soap, _MultiXTpm__UpdateConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__UpdateConfigResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__UpdateConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__UpdateConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__UpdateConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__UpdateConfigResponse;
		if (size)
			*size = sizeof(_MultiXTpm__UpdateConfigResponse);
		((_MultiXTpm__UpdateConfigResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__UpdateConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__UpdateConfigResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__UpdateConfigResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__UpdateConfigResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__UpdateConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__UpdateConfigResponse %p -> %p\n", q, p));
	*(_MultiXTpm__UpdateConfigResponse*)p = *(_MultiXTpm__UpdateConfigResponse*)q;
}

void _MultiXTpm__UpdateConfig::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__UpdateConfig::Config = NULL;
	soap_default_bool(soap, &this->_MultiXTpm__UpdateConfig::SaveToDisk);
	/* transient soap skipped */
}

void _MultiXTpm__UpdateConfig::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ConfigData(soap, &this->_MultiXTpm__UpdateConfig::Config);
	/* transient soap skipped */
}

int _MultiXTpm__UpdateConfig::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__UpdateConfig);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__UpdateConfig::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__UpdateConfig(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__UpdateConfig(struct soap *soap, const char *tag, int id, const _MultiXTpm__UpdateConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__UpdateConfig), type))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ConfigData(soap, "MultiXTpm:Config", -1, &(a->_MultiXTpm__UpdateConfig::Config), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:SaveToDisk", -1, &(a->_MultiXTpm__UpdateConfig::SaveToDisk), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__UpdateConfig::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__UpdateConfig(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__UpdateConfig * SOAP_FMAC4 soap_get__MultiXTpm__UpdateConfig(struct soap *soap, _MultiXTpm__UpdateConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__UpdateConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__UpdateConfig::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__UpdateConfig(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__UpdateConfig * SOAP_FMAC4 soap_in__MultiXTpm__UpdateConfig(struct soap *soap, const char *tag, _MultiXTpm__UpdateConfig *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__UpdateConfig *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__UpdateConfig, sizeof(_MultiXTpm__UpdateConfig), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__UpdateConfig)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__UpdateConfig *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Config1 = 1, soap_flag_SaveToDisk1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ConfigData(soap, "MultiXTpm:Config", &(a->_MultiXTpm__UpdateConfig::Config), "MultiXTpm:ConfigData"))
				{	soap_flag_Config1--;
					continue;
				}
			if (soap_flag_SaveToDisk1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:SaveToDisk", &(a->_MultiXTpm__UpdateConfig::SaveToDisk), "xsd:boolean"))
				{	soap_flag_SaveToDisk1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__UpdateConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__UpdateConfig, 0, sizeof(_MultiXTpm__UpdateConfig), 0, soap_copy__MultiXTpm__UpdateConfig);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SaveToDisk1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__UpdateConfig * SOAP_FMAC6 soap_new__MultiXTpm__UpdateConfig(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__UpdateConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__UpdateConfig(struct soap *soap, _MultiXTpm__UpdateConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__UpdateConfig * SOAP_FMAC4 soap_instantiate__MultiXTpm__UpdateConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__UpdateConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__UpdateConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__UpdateConfig;
		if (size)
			*size = sizeof(_MultiXTpm__UpdateConfig);
		((_MultiXTpm__UpdateConfig*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__UpdateConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__UpdateConfig);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__UpdateConfig*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__UpdateConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__UpdateConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__UpdateConfig %p -> %p\n", q, p));
	*(_MultiXTpm__UpdateConfig*)p = *(_MultiXTpm__UpdateConfig*)q;
}

void _MultiXTpm__GetConfigResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_MultiXTpm__GetConfigResponse::GetConfigResult = NULL;
	/* transient soap skipped */
}

void _MultiXTpm__GetConfigResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ConfigData(soap, &this->_MultiXTpm__GetConfigResponse::GetConfigResult);
	/* transient soap skipped */
}

int _MultiXTpm__GetConfigResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__GetConfigResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__GetConfigResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__GetConfigResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__GetConfigResponse(struct soap *soap, const char *tag, int id, const _MultiXTpm__GetConfigResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__GetConfigResponse), type))
		return soap->error;
	if (a->GetConfigResult)
		soap_element_result(soap, "MultiXTpm:GetConfigResult");
	if (soap_out_PointerToMultiXTpm__ConfigData(soap, "MultiXTpm:GetConfigResult", -1, &(a->_MultiXTpm__GetConfigResponse::GetConfigResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__GetConfigResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__GetConfigResponse(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__GetConfigResponse * SOAP_FMAC4 soap_get__MultiXTpm__GetConfigResponse(struct soap *soap, _MultiXTpm__GetConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__GetConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__GetConfigResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__GetConfigResponse(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__GetConfigResponse * SOAP_FMAC4 soap_in__MultiXTpm__GetConfigResponse(struct soap *soap, const char *tag, _MultiXTpm__GetConfigResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__GetConfigResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__GetConfigResponse, sizeof(_MultiXTpm__GetConfigResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__GetConfigResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__GetConfigResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetConfigResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetConfigResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ConfigData(soap, "MultiXTpm:GetConfigResult", &(a->_MultiXTpm__GetConfigResponse::GetConfigResult), "MultiXTpm:ConfigData"))
				{	soap_flag_GetConfigResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "MultiXTpm:GetConfigResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__GetConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__GetConfigResponse, 0, sizeof(_MultiXTpm__GetConfigResponse), 0, soap_copy__MultiXTpm__GetConfigResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__GetConfigResponse * SOAP_FMAC6 soap_new__MultiXTpm__GetConfigResponse(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__GetConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__GetConfigResponse(struct soap *soap, _MultiXTpm__GetConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__GetConfigResponse * SOAP_FMAC4 soap_instantiate__MultiXTpm__GetConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__GetConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__GetConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__GetConfigResponse;
		if (size)
			*size = sizeof(_MultiXTpm__GetConfigResponse);
		((_MultiXTpm__GetConfigResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__GetConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__GetConfigResponse);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__GetConfigResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__GetConfigResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__GetConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__GetConfigResponse %p -> %p\n", q, p));
	*(_MultiXTpm__GetConfigResponse*)p = *(_MultiXTpm__GetConfigResponse*)q;
}

void _MultiXTpm__GetConfig::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _MultiXTpm__GetConfig::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _MultiXTpm__GetConfig::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__MultiXTpm__GetConfig);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _MultiXTpm__GetConfig::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__MultiXTpm__GetConfig(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__MultiXTpm__GetConfig(struct soap *soap, const char *tag, int id, const _MultiXTpm__GetConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__MultiXTpm__GetConfig), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_MultiXTpm__GetConfig::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__MultiXTpm__GetConfig(soap, this, tag, type);
}

SOAP_FMAC3 _MultiXTpm__GetConfig * SOAP_FMAC4 soap_get__MultiXTpm__GetConfig(struct soap *soap, _MultiXTpm__GetConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in__MultiXTpm__GetConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_MultiXTpm__GetConfig::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__MultiXTpm__GetConfig(soap, tag, this, type);
}

SOAP_FMAC3 _MultiXTpm__GetConfig * SOAP_FMAC4 soap_in__MultiXTpm__GetConfig(struct soap *soap, const char *tag, _MultiXTpm__GetConfig *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_MultiXTpm__GetConfig *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__MultiXTpm__GetConfig, sizeof(_MultiXTpm__GetConfig), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__MultiXTpm__GetConfig)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_MultiXTpm__GetConfig *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_MultiXTpm__GetConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__MultiXTpm__GetConfig, 0, sizeof(_MultiXTpm__GetConfig), 0, soap_copy__MultiXTpm__GetConfig);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _MultiXTpm__GetConfig * SOAP_FMAC6 soap_new__MultiXTpm__GetConfig(struct soap *soap, int n)
{	return soap_instantiate__MultiXTpm__GetConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__MultiXTpm__GetConfig(struct soap *soap, _MultiXTpm__GetConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _MultiXTpm__GetConfig * SOAP_FMAC4 soap_instantiate__MultiXTpm__GetConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__MultiXTpm__GetConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__MultiXTpm__GetConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _MultiXTpm__GetConfig;
		if (size)
			*size = sizeof(_MultiXTpm__GetConfig);
		((_MultiXTpm__GetConfig*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _MultiXTpm__GetConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_MultiXTpm__GetConfig);
		for (int i = 0; i < n; i++)
			((_MultiXTpm__GetConfig*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_MultiXTpm__GetConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__MultiXTpm__GetConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _MultiXTpm__GetConfig %p -> %p\n", q, p));
	*(_MultiXTpm__GetConfig*)p = *(_MultiXTpm__GetConfig*)q;
}

void MultiXTpm__ArrayOfInt1::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->MultiXTpm__ArrayOfInt1::int_);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfInt1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->MultiXTpm__ArrayOfInt1::int_);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfInt1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfInt1);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfInt1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfInt1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfInt1(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfInt1 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfInt1), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "MultiXTpm:int", -1, &(a->MultiXTpm__ArrayOfInt1::int_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfInt1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfInt1(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfInt1 * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfInt1(struct soap *soap, MultiXTpm__ArrayOfInt1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfInt1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfInt1::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfInt1(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfInt1 * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfInt1(struct soap *soap, const char *tag, MultiXTpm__ArrayOfInt1 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfInt1 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfInt1, sizeof(MultiXTpm__ArrayOfInt1), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfInt1)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfInt1 *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "MultiXTpm:int", &(a->MultiXTpm__ArrayOfInt1::int_), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfInt1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfInt1, 0, sizeof(MultiXTpm__ArrayOfInt1), 0, soap_copy_MultiXTpm__ArrayOfInt1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfInt1 * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfInt1(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfInt1(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfInt1(struct soap *soap, MultiXTpm__ArrayOfInt1 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfInt1 * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfInt1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfInt1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfInt1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfInt1;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfInt1);
		((MultiXTpm__ArrayOfInt1*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfInt1[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfInt1);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfInt1*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfInt1*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfInt1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfInt1 %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfInt1*)p = *(MultiXTpm__ArrayOfInt1*)q;
}

void MultiXTpm__ProcessStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->MultiXTpm__ProcessStatus::ID);
	this->MultiXTpm__ProcessStatus::MultiXVersion = NULL;
	this->MultiXTpm__ProcessStatus::AppVersion = NULL;
	soap_default_int(soap, &this->MultiXTpm__ProcessStatus::ProcessClassID);
	soap_default_bool(soap, &this->MultiXTpm__ProcessStatus::IsReady);
	soap_default_MultiXTpm__ProcessControlStatus(soap, &this->MultiXTpm__ProcessStatus::ControlStatus);
	soap_default_int(soap, &this->MultiXTpm__ProcessStatus::SessionsCount);
	soap_default_int(soap, &this->MultiXTpm__ProcessStatus::OutQueueSize);
	soap_default_time(soap, &this->MultiXTpm__ProcessStatus::LastMsgTime);
	/* transient soap skipped */
}

void MultiXTpm__ProcessStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__ProcessStatus::MultiXVersion);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__ProcessStatus::AppVersion);
	/* transient soap skipped */
}

int MultiXTpm__ProcessStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ProcessStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ProcessStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ProcessStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ProcessStatus(struct soap *soap, const char *tag, int id, const MultiXTpm__ProcessStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ProcessStatus), type))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:ID", -1, &(a->MultiXTpm__ProcessStatus::ID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:MultiXVersion", -1, &(a->MultiXTpm__ProcessStatus::MultiXVersion), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:AppVersion", -1, &(a->MultiXTpm__ProcessStatus::AppVersion), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:ProcessClassID", -1, &(a->MultiXTpm__ProcessStatus::ProcessClassID), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:IsReady", -1, &(a->MultiXTpm__ProcessStatus::IsReady), ""))
		return soap->error;
	if (soap_out_MultiXTpm__ProcessControlStatus(soap, "MultiXTpm:ControlStatus", -1, &(a->MultiXTpm__ProcessStatus::ControlStatus), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:SessionsCount", -1, &(a->MultiXTpm__ProcessStatus::SessionsCount), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:OutQueueSize", -1, &(a->MultiXTpm__ProcessStatus::OutQueueSize), ""))
		return soap->error;
	if (soap_out_time(soap, "MultiXTpm:LastMsgTime", -1, &(a->MultiXTpm__ProcessStatus::LastMsgTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ProcessStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ProcessStatus(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ProcessStatus * SOAP_FMAC4 soap_get_MultiXTpm__ProcessStatus(struct soap *soap, MultiXTpm__ProcessStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ProcessStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ProcessStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ProcessStatus(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ProcessStatus * SOAP_FMAC4 soap_in_MultiXTpm__ProcessStatus(struct soap *soap, const char *tag, MultiXTpm__ProcessStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ProcessStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ProcessStatus, sizeof(MultiXTpm__ProcessStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ProcessStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ProcessStatus *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ID1 = 1, soap_flag_MultiXVersion1 = 1, soap_flag_AppVersion1 = 1, soap_flag_ProcessClassID1 = 1, soap_flag_IsReady1 = 1, soap_flag_ControlStatus1 = 1, soap_flag_SessionsCount1 = 1, soap_flag_OutQueueSize1 = 1, soap_flag_LastMsgTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:ID", &(a->MultiXTpm__ProcessStatus::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_MultiXVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:MultiXVersion", &(a->MultiXTpm__ProcessStatus::MultiXVersion), "xsd:string"))
				{	soap_flag_MultiXVersion1--;
					continue;
				}
			if (soap_flag_AppVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:AppVersion", &(a->MultiXTpm__ProcessStatus::AppVersion), "xsd:string"))
				{	soap_flag_AppVersion1--;
					continue;
				}
			if (soap_flag_ProcessClassID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:ProcessClassID", &(a->MultiXTpm__ProcessStatus::ProcessClassID), "xsd:int"))
				{	soap_flag_ProcessClassID1--;
					continue;
				}
			if (soap_flag_IsReady1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:IsReady", &(a->MultiXTpm__ProcessStatus::IsReady), "xsd:boolean"))
				{	soap_flag_IsReady1--;
					continue;
				}
			if (soap_flag_ControlStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_MultiXTpm__ProcessControlStatus(soap, "MultiXTpm:ControlStatus", &(a->MultiXTpm__ProcessStatus::ControlStatus), "MultiXTpm:ProcessControlStatus"))
				{	soap_flag_ControlStatus1--;
					continue;
				}
			if (soap_flag_SessionsCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:SessionsCount", &(a->MultiXTpm__ProcessStatus::SessionsCount), "xsd:int"))
				{	soap_flag_SessionsCount1--;
					continue;
				}
			if (soap_flag_OutQueueSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:OutQueueSize", &(a->MultiXTpm__ProcessStatus::OutQueueSize), "xsd:int"))
				{	soap_flag_OutQueueSize1--;
					continue;
				}
			if (soap_flag_LastMsgTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "MultiXTpm:LastMsgTime", &(a->MultiXTpm__ProcessStatus::LastMsgTime), "xsd:dateTime"))
				{	soap_flag_LastMsgTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ProcessStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ProcessStatus, 0, sizeof(MultiXTpm__ProcessStatus), 0, soap_copy_MultiXTpm__ProcessStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_ProcessClassID1 > 0 || soap_flag_IsReady1 > 0 || soap_flag_ControlStatus1 > 0 || soap_flag_SessionsCount1 > 0 || soap_flag_OutQueueSize1 > 0 || soap_flag_LastMsgTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ProcessStatus * SOAP_FMAC6 soap_new_MultiXTpm__ProcessStatus(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ProcessStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ProcessStatus(struct soap *soap, MultiXTpm__ProcessStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ProcessStatus * SOAP_FMAC4 soap_instantiate_MultiXTpm__ProcessStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ProcessStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ProcessStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ProcessStatus;
		if (size)
			*size = sizeof(MultiXTpm__ProcessStatus);
		((MultiXTpm__ProcessStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ProcessStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ProcessStatus);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ProcessStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ProcessStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ProcessStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ProcessStatus %p -> %p\n", q, p));
	*(MultiXTpm__ProcessStatus*)p = *(MultiXTpm__ProcessStatus*)q;
}

void MultiXTpm__ArrayOfProcessStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(soap, &this->MultiXTpm__ArrayOfProcessStatus::ProcessStatus);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfProcessStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(soap, &this->MultiXTpm__ArrayOfProcessStatus::ProcessStatus);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfProcessStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfProcessStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfProcessStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfProcessStatus(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfProcessStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(soap, "MultiXTpm:ProcessStatus", -1, &(a->MultiXTpm__ArrayOfProcessStatus::ProcessStatus), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfProcessStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfProcessStatus(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfProcessStatus * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfProcessStatus(struct soap *soap, MultiXTpm__ArrayOfProcessStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfProcessStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfProcessStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfProcessStatus(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfProcessStatus * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfProcessStatus(struct soap *soap, const char *tag, MultiXTpm__ArrayOfProcessStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfProcessStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus, sizeof(MultiXTpm__ArrayOfProcessStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfProcessStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(soap, "MultiXTpm:ProcessStatus", &(a->MultiXTpm__ArrayOfProcessStatus::ProcessStatus), "MultiXTpm:ProcessStatus"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfProcessStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus, 0, sizeof(MultiXTpm__ArrayOfProcessStatus), 0, soap_copy_MultiXTpm__ArrayOfProcessStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfProcessStatus * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfProcessStatus(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfProcessStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfProcessStatus(struct soap *soap, MultiXTpm__ArrayOfProcessStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfProcessStatus * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfProcessStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfProcessStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfProcessStatus;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfProcessStatus);
		((MultiXTpm__ArrayOfProcessStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfProcessStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfProcessStatus);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfProcessStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfProcessStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfProcessStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfProcessStatus %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfProcessStatus*)p = *(MultiXTpm__ArrayOfProcessStatus*)q;
}

void MultiXTpm__GroupStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->MultiXTpm__GroupStatus::ID);
	soap_default_int(soap, &this->MultiXTpm__GroupStatus::SessionsCount);
	soap_default_int(soap, &this->MultiXTpm__GroupStatus::OutQueueSize);
	soap_default_int(soap, &this->MultiXTpm__GroupStatus::QueuedItemsSize);
	soap_default_int(soap, &this->MultiXTpm__GroupStatus::MaxProcessQueueEntries);
	this->MultiXTpm__GroupStatus::ProcessIDs = NULL;
	/* transient soap skipped */
}

void MultiXTpm__GroupStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToMultiXTpm__ArrayOfInt(soap, &this->MultiXTpm__GroupStatus::ProcessIDs);
	/* transient soap skipped */
}

int MultiXTpm__GroupStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__GroupStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__GroupStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__GroupStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__GroupStatus(struct soap *soap, const char *tag, int id, const MultiXTpm__GroupStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__GroupStatus), type))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:ID", -1, &(a->MultiXTpm__GroupStatus::ID), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:SessionsCount", -1, &(a->MultiXTpm__GroupStatus::SessionsCount), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:OutQueueSize", -1, &(a->MultiXTpm__GroupStatus::OutQueueSize), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:QueuedItemsSize", -1, &(a->MultiXTpm__GroupStatus::QueuedItemsSize), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:MaxProcessQueueEntries", -1, &(a->MultiXTpm__GroupStatus::MaxProcessQueueEntries), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt(soap, "MultiXTpm:ProcessIDs", -1, &(a->MultiXTpm__GroupStatus::ProcessIDs), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__GroupStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__GroupStatus(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__GroupStatus * SOAP_FMAC4 soap_get_MultiXTpm__GroupStatus(struct soap *soap, MultiXTpm__GroupStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__GroupStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__GroupStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__GroupStatus(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__GroupStatus * SOAP_FMAC4 soap_in_MultiXTpm__GroupStatus(struct soap *soap, const char *tag, MultiXTpm__GroupStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__GroupStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__GroupStatus, sizeof(MultiXTpm__GroupStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__GroupStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__GroupStatus *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ID1 = 1, soap_flag_SessionsCount1 = 1, soap_flag_OutQueueSize1 = 1, soap_flag_QueuedItemsSize1 = 1, soap_flag_MaxProcessQueueEntries1 = 1, soap_flag_ProcessIDs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:ID", &(a->MultiXTpm__GroupStatus::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_SessionsCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:SessionsCount", &(a->MultiXTpm__GroupStatus::SessionsCount), "xsd:int"))
				{	soap_flag_SessionsCount1--;
					continue;
				}
			if (soap_flag_OutQueueSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:OutQueueSize", &(a->MultiXTpm__GroupStatus::OutQueueSize), "xsd:int"))
				{	soap_flag_OutQueueSize1--;
					continue;
				}
			if (soap_flag_QueuedItemsSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:QueuedItemsSize", &(a->MultiXTpm__GroupStatus::QueuedItemsSize), "xsd:int"))
				{	soap_flag_QueuedItemsSize1--;
					continue;
				}
			if (soap_flag_MaxProcessQueueEntries1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:MaxProcessQueueEntries", &(a->MultiXTpm__GroupStatus::MaxProcessQueueEntries), "xsd:int"))
				{	soap_flag_MaxProcessQueueEntries1--;
					continue;
				}
			if (soap_flag_ProcessIDs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt(soap, "MultiXTpm:ProcessIDs", &(a->MultiXTpm__GroupStatus::ProcessIDs), "MultiXTpm:ArrayOfInt"))
				{	soap_flag_ProcessIDs1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__GroupStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__GroupStatus, 0, sizeof(MultiXTpm__GroupStatus), 0, soap_copy_MultiXTpm__GroupStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_SessionsCount1 > 0 || soap_flag_OutQueueSize1 > 0 || soap_flag_QueuedItemsSize1 > 0 || soap_flag_MaxProcessQueueEntries1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__GroupStatus * SOAP_FMAC6 soap_new_MultiXTpm__GroupStatus(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__GroupStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__GroupStatus(struct soap *soap, MultiXTpm__GroupStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__GroupStatus * SOAP_FMAC4 soap_instantiate_MultiXTpm__GroupStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__GroupStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__GroupStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__GroupStatus;
		if (size)
			*size = sizeof(MultiXTpm__GroupStatus);
		((MultiXTpm__GroupStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__GroupStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__GroupStatus);
		for (int i = 0; i < n; i++)
			((MultiXTpm__GroupStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__GroupStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__GroupStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__GroupStatus %p -> %p\n", q, p));
	*(MultiXTpm__GroupStatus*)p = *(MultiXTpm__GroupStatus*)q;
}

void MultiXTpm__ArrayOfGroupStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(soap, &this->MultiXTpm__ArrayOfGroupStatus::GroupStatus);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfGroupStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(soap, &this->MultiXTpm__ArrayOfGroupStatus::GroupStatus);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfGroupStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfGroupStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfGroupStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfGroupStatus(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfGroupStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(soap, "MultiXTpm:GroupStatus", -1, &(a->MultiXTpm__ArrayOfGroupStatus::GroupStatus), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfGroupStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfGroupStatus(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroupStatus * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfGroupStatus(struct soap *soap, MultiXTpm__ArrayOfGroupStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfGroupStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfGroupStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfGroupStatus(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroupStatus * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfGroupStatus(struct soap *soap, const char *tag, MultiXTpm__ArrayOfGroupStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfGroupStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus, sizeof(MultiXTpm__ArrayOfGroupStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfGroupStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(soap, "MultiXTpm:GroupStatus", &(a->MultiXTpm__ArrayOfGroupStatus::GroupStatus), "MultiXTpm:GroupStatus"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfGroupStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus, 0, sizeof(MultiXTpm__ArrayOfGroupStatus), 0, soap_copy_MultiXTpm__ArrayOfGroupStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfGroupStatus * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfGroupStatus(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfGroupStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfGroupStatus(struct soap *soap, MultiXTpm__ArrayOfGroupStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroupStatus * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfGroupStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfGroupStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfGroupStatus;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfGroupStatus);
		((MultiXTpm__ArrayOfGroupStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfGroupStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfGroupStatus);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfGroupStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfGroupStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfGroupStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfGroupStatus %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfGroupStatus*)p = *(MultiXTpm__ArrayOfGroupStatus*)q;
}

void MultiXTpm__SystemStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->MultiXTpm__SystemStatus::TpmMultiXVersion = NULL;
	this->MultiXTpm__SystemStatus::TpmVersion = NULL;
	this->MultiXTpm__SystemStatus::TpmHostName = NULL;
	this->MultiXTpm__SystemStatus::TpmHostIP = NULL;
	soap_default_int(soap, &this->MultiXTpm__SystemStatus::SessionsCount);
	this->MultiXTpm__SystemStatus::GroupsStatus = NULL;
	this->MultiXTpm__SystemStatus::ProcessesStatus = NULL;
	/* transient soap skipped */
}

void MultiXTpm__SystemStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SystemStatus::TpmMultiXVersion);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SystemStatus::TpmVersion);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SystemStatus::TpmHostName);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SystemStatus::TpmHostIP);
	soap_serialize_PointerToMultiXTpm__ArrayOfGroupStatus(soap, &this->MultiXTpm__SystemStatus::GroupsStatus);
	soap_serialize_PointerToMultiXTpm__ArrayOfProcessStatus(soap, &this->MultiXTpm__SystemStatus::ProcessesStatus);
	/* transient soap skipped */
}

int MultiXTpm__SystemStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__SystemStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__SystemStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__SystemStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__SystemStatus(struct soap *soap, const char *tag, int id, const MultiXTpm__SystemStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__SystemStatus), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:TpmMultiXVersion", -1, &(a->MultiXTpm__SystemStatus::TpmMultiXVersion), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:TpmVersion", -1, &(a->MultiXTpm__SystemStatus::TpmVersion), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:TpmHostName", -1, &(a->MultiXTpm__SystemStatus::TpmHostName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:TpmHostIP", -1, &(a->MultiXTpm__SystemStatus::TpmHostIP), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:SessionsCount", -1, &(a->MultiXTpm__SystemStatus::SessionsCount), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfGroupStatus(soap, "MultiXTpm:GroupsStatus", -1, &(a->MultiXTpm__SystemStatus::GroupsStatus), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfProcessStatus(soap, "MultiXTpm:ProcessesStatus", -1, &(a->MultiXTpm__SystemStatus::ProcessesStatus), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__SystemStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__SystemStatus(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__SystemStatus * SOAP_FMAC4 soap_get_MultiXTpm__SystemStatus(struct soap *soap, MultiXTpm__SystemStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__SystemStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__SystemStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__SystemStatus(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__SystemStatus * SOAP_FMAC4 soap_in_MultiXTpm__SystemStatus(struct soap *soap, const char *tag, MultiXTpm__SystemStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__SystemStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__SystemStatus, sizeof(MultiXTpm__SystemStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__SystemStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__SystemStatus *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_TpmMultiXVersion1 = 1, soap_flag_TpmVersion1 = 1, soap_flag_TpmHostName1 = 1, soap_flag_TpmHostIP1 = 1, soap_flag_SessionsCount1 = 1, soap_flag_GroupsStatus1 = 1, soap_flag_ProcessesStatus1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TpmMultiXVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:TpmMultiXVersion", &(a->MultiXTpm__SystemStatus::TpmMultiXVersion), "xsd:string"))
				{	soap_flag_TpmMultiXVersion1--;
					continue;
				}
			if (soap_flag_TpmVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:TpmVersion", &(a->MultiXTpm__SystemStatus::TpmVersion), "xsd:string"))
				{	soap_flag_TpmVersion1--;
					continue;
				}
			if (soap_flag_TpmHostName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:TpmHostName", &(a->MultiXTpm__SystemStatus::TpmHostName), "xsd:string"))
				{	soap_flag_TpmHostName1--;
					continue;
				}
			if (soap_flag_TpmHostIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:TpmHostIP", &(a->MultiXTpm__SystemStatus::TpmHostIP), "xsd:string"))
				{	soap_flag_TpmHostIP1--;
					continue;
				}
			if (soap_flag_SessionsCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:SessionsCount", &(a->MultiXTpm__SystemStatus::SessionsCount), "xsd:int"))
				{	soap_flag_SessionsCount1--;
					continue;
				}
			if (soap_flag_GroupsStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfGroupStatus(soap, "MultiXTpm:GroupsStatus", &(a->MultiXTpm__SystemStatus::GroupsStatus), "MultiXTpm:ArrayOfGroupStatus"))
				{	soap_flag_GroupsStatus1--;
					continue;
				}
			if (soap_flag_ProcessesStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfProcessStatus(soap, "MultiXTpm:ProcessesStatus", &(a->MultiXTpm__SystemStatus::ProcessesStatus), "MultiXTpm:ArrayOfProcessStatus"))
				{	soap_flag_ProcessesStatus1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__SystemStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__SystemStatus, 0, sizeof(MultiXTpm__SystemStatus), 0, soap_copy_MultiXTpm__SystemStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SessionsCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__SystemStatus * SOAP_FMAC6 soap_new_MultiXTpm__SystemStatus(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__SystemStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__SystemStatus(struct soap *soap, MultiXTpm__SystemStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__SystemStatus * SOAP_FMAC4 soap_instantiate_MultiXTpm__SystemStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__SystemStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__SystemStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__SystemStatus;
		if (size)
			*size = sizeof(MultiXTpm__SystemStatus);
		((MultiXTpm__SystemStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__SystemStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__SystemStatus);
		for (int i = 0; i < n; i++)
			((MultiXTpm__SystemStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__SystemStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__SystemStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__SystemStatus %p -> %p\n", q, p));
	*(MultiXTpm__SystemStatus*)p = *(MultiXTpm__SystemStatus*)q;
}

void MultiXTpm__GroupForwardFlags::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->MultiXTpm__GroupForwardFlags::GroupID);
	soap_default_bool(soap, &this->MultiXTpm__GroupForwardFlags::ResponseRequired);
	soap_default_bool(soap, &this->MultiXTpm__GroupForwardFlags::IgnoreResponse);
	soap_default_bool(soap, &this->MultiXTpm__GroupForwardFlags::ForwardToAll);
	/* transient soap skipped */
}

void MultiXTpm__GroupForwardFlags::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int MultiXTpm__GroupForwardFlags::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__GroupForwardFlags);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__GroupForwardFlags::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__GroupForwardFlags(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__GroupForwardFlags(struct soap *soap, const char *tag, int id, const MultiXTpm__GroupForwardFlags *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__GroupForwardFlags), type))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:GroupID", -1, &(a->MultiXTpm__GroupForwardFlags::GroupID), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ResponseRequired", -1, &(a->MultiXTpm__GroupForwardFlags::ResponseRequired), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:IgnoreResponse", -1, &(a->MultiXTpm__GroupForwardFlags::IgnoreResponse), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ForwardToAll", -1, &(a->MultiXTpm__GroupForwardFlags::ForwardToAll), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__GroupForwardFlags::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__GroupForwardFlags(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__GroupForwardFlags * SOAP_FMAC4 soap_get_MultiXTpm__GroupForwardFlags(struct soap *soap, MultiXTpm__GroupForwardFlags *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__GroupForwardFlags(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__GroupForwardFlags::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__GroupForwardFlags(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__GroupForwardFlags * SOAP_FMAC4 soap_in_MultiXTpm__GroupForwardFlags(struct soap *soap, const char *tag, MultiXTpm__GroupForwardFlags *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__GroupForwardFlags *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__GroupForwardFlags, sizeof(MultiXTpm__GroupForwardFlags), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__GroupForwardFlags)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__GroupForwardFlags *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GroupID1 = 1, soap_flag_ResponseRequired1 = 1, soap_flag_IgnoreResponse1 = 1, soap_flag_ForwardToAll1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GroupID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:GroupID", &(a->MultiXTpm__GroupForwardFlags::GroupID), "xsd:int"))
				{	soap_flag_GroupID1--;
					continue;
				}
			if (soap_flag_ResponseRequired1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ResponseRequired", &(a->MultiXTpm__GroupForwardFlags::ResponseRequired), "xsd:boolean"))
				{	soap_flag_ResponseRequired1--;
					continue;
				}
			if (soap_flag_IgnoreResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:IgnoreResponse", &(a->MultiXTpm__GroupForwardFlags::IgnoreResponse), "xsd:boolean"))
				{	soap_flag_IgnoreResponse1--;
					continue;
				}
			if (soap_flag_ForwardToAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ForwardToAll", &(a->MultiXTpm__GroupForwardFlags::ForwardToAll), "xsd:boolean"))
				{	soap_flag_ForwardToAll1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__GroupForwardFlags *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__GroupForwardFlags, 0, sizeof(MultiXTpm__GroupForwardFlags), 0, soap_copy_MultiXTpm__GroupForwardFlags);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GroupID1 > 0 || soap_flag_ResponseRequired1 > 0 || soap_flag_IgnoreResponse1 > 0 || soap_flag_ForwardToAll1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__GroupForwardFlags * SOAP_FMAC6 soap_new_MultiXTpm__GroupForwardFlags(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__GroupForwardFlags(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__GroupForwardFlags(struct soap *soap, MultiXTpm__GroupForwardFlags *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__GroupForwardFlags * SOAP_FMAC4 soap_instantiate_MultiXTpm__GroupForwardFlags(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__GroupForwardFlags(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__GroupForwardFlags, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__GroupForwardFlags;
		if (size)
			*size = sizeof(MultiXTpm__GroupForwardFlags);
		((MultiXTpm__GroupForwardFlags*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__GroupForwardFlags[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__GroupForwardFlags);
		for (int i = 0; i < n; i++)
			((MultiXTpm__GroupForwardFlags*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__GroupForwardFlags*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__GroupForwardFlags(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__GroupForwardFlags %p -> %p\n", q, p));
	*(MultiXTpm__GroupForwardFlags*)p = *(MultiXTpm__GroupForwardFlags*)q;
}

void MultiXTpm__ArrayOfGroupForwardFlags::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(soap, &this->MultiXTpm__ArrayOfGroupForwardFlags::Flags);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfGroupForwardFlags::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(soap, &this->MultiXTpm__ArrayOfGroupForwardFlags::Flags);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfGroupForwardFlags::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfGroupForwardFlags::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfGroupForwardFlags(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfGroupForwardFlags *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(soap, "MultiXTpm:Flags", -1, &(a->MultiXTpm__ArrayOfGroupForwardFlags::Flags), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfGroupForwardFlags::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfGroupForwardFlags(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroupForwardFlags * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, MultiXTpm__ArrayOfGroupForwardFlags *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfGroupForwardFlags(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfGroupForwardFlags::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfGroupForwardFlags(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroupForwardFlags * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, const char *tag, MultiXTpm__ArrayOfGroupForwardFlags *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfGroupForwardFlags *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags, sizeof(MultiXTpm__ArrayOfGroupForwardFlags), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfGroupForwardFlags *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(soap, "MultiXTpm:Flags", &(a->MultiXTpm__ArrayOfGroupForwardFlags::Flags), "MultiXTpm:GroupForwardFlags"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfGroupForwardFlags *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags, 0, sizeof(MultiXTpm__ArrayOfGroupForwardFlags), 0, soap_copy_MultiXTpm__ArrayOfGroupForwardFlags);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfGroupForwardFlags * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfGroupForwardFlags(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, MultiXTpm__ArrayOfGroupForwardFlags *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroupForwardFlags * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfGroupForwardFlags(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfGroupForwardFlags;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfGroupForwardFlags);
		((MultiXTpm__ArrayOfGroupForwardFlags*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfGroupForwardFlags[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfGroupForwardFlags);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfGroupForwardFlags*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfGroupForwardFlags*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfGroupForwardFlags %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfGroupForwardFlags*)p = *(MultiXTpm__ArrayOfGroupForwardFlags*)q;
}

void MultiXTpm__Message::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->MultiXTpm__Message::ID);
	this->MultiXTpm__Message::Description = NULL;
	soap_default_bool(soap, &this->MultiXTpm__Message::Stateful);
	soap_default_bool(soap, &this->MultiXTpm__Message::DbProtected);
	soap_default_int(soap, &this->MultiXTpm__Message::Timeout);
	soap_default_int(soap, &this->MultiXTpm__Message::Priority);
	this->MultiXTpm__Message::WSURL = NULL;
	this->MultiXTpm__Message::WSSoapAction = NULL;
	this->MultiXTpm__Message::WSDllFile = NULL;
	this->MultiXTpm__Message::WSDllFunction = NULL;
	this->MultiXTpm__Message::ForwardFlags = NULL;
	/* transient soap skipped */
}

void MultiXTpm__Message::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Message::Description);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Message::WSURL);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Message::WSSoapAction);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Message::WSDllFile);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Message::WSDllFunction);
	soap_serialize_PointerToMultiXTpm__ArrayOfGroupForwardFlags(soap, &this->MultiXTpm__Message::ForwardFlags);
	/* transient soap skipped */
}

int MultiXTpm__Message::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__Message);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__Message::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__Message(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__Message(struct soap *soap, const char *tag, int id, const MultiXTpm__Message *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__Message), type))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:ID", -1, &(a->MultiXTpm__Message::ID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:Description", -1, &(a->MultiXTpm__Message::Description), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:Stateful", -1, &(a->MultiXTpm__Message::Stateful), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:DbProtected", -1, &(a->MultiXTpm__Message::DbProtected), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:Timeout", -1, &(a->MultiXTpm__Message::Timeout), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:Priority", -1, &(a->MultiXTpm__Message::Priority), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:WSURL", -1, &(a->MultiXTpm__Message::WSURL), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:WSSoapAction", -1, &(a->MultiXTpm__Message::WSSoapAction), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:WSDllFile", -1, &(a->MultiXTpm__Message::WSDllFile), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:WSDllFunction", -1, &(a->MultiXTpm__Message::WSDllFunction), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfGroupForwardFlags(soap, "MultiXTpm:ForwardFlags", -1, &(a->MultiXTpm__Message::ForwardFlags), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__Message::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__Message(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__Message * SOAP_FMAC4 soap_get_MultiXTpm__Message(struct soap *soap, MultiXTpm__Message *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__Message::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__Message(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__Message * SOAP_FMAC4 soap_in_MultiXTpm__Message(struct soap *soap, const char *tag, MultiXTpm__Message *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__Message *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__Message, sizeof(MultiXTpm__Message), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__Message)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__Message *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ID1 = 1, soap_flag_Description1 = 1, soap_flag_Stateful1 = 1, soap_flag_DbProtected1 = 1, soap_flag_Timeout1 = 1, soap_flag_Priority1 = 1, soap_flag_WSURL1 = 1, soap_flag_WSSoapAction1 = 1, soap_flag_WSDllFile1 = 1, soap_flag_WSDllFunction1 = 1, soap_flag_ForwardFlags1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:ID", &(a->MultiXTpm__Message::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:Description", &(a->MultiXTpm__Message::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Stateful1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:Stateful", &(a->MultiXTpm__Message::Stateful), "xsd:boolean"))
				{	soap_flag_Stateful1--;
					continue;
				}
			if (soap_flag_DbProtected1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:DbProtected", &(a->MultiXTpm__Message::DbProtected), "xsd:boolean"))
				{	soap_flag_DbProtected1--;
					continue;
				}
			if (soap_flag_Timeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:Timeout", &(a->MultiXTpm__Message::Timeout), "xsd:int"))
				{	soap_flag_Timeout1--;
					continue;
				}
			if (soap_flag_Priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:Priority", &(a->MultiXTpm__Message::Priority), "xsd:int"))
				{	soap_flag_Priority1--;
					continue;
				}
			if (soap_flag_WSURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:WSURL", &(a->MultiXTpm__Message::WSURL), "xsd:string"))
				{	soap_flag_WSURL1--;
					continue;
				}
			if (soap_flag_WSSoapAction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:WSSoapAction", &(a->MultiXTpm__Message::WSSoapAction), "xsd:string"))
				{	soap_flag_WSSoapAction1--;
					continue;
				}
			if (soap_flag_WSDllFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:WSDllFile", &(a->MultiXTpm__Message::WSDllFile), "xsd:string"))
				{	soap_flag_WSDllFile1--;
					continue;
				}
			if (soap_flag_WSDllFunction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:WSDllFunction", &(a->MultiXTpm__Message::WSDllFunction), "xsd:string"))
				{	soap_flag_WSDllFunction1--;
					continue;
				}
			if (soap_flag_ForwardFlags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfGroupForwardFlags(soap, "MultiXTpm:ForwardFlags", &(a->MultiXTpm__Message::ForwardFlags), "MultiXTpm:ArrayOfGroupForwardFlags"))
				{	soap_flag_ForwardFlags1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__Message, 0, sizeof(MultiXTpm__Message), 0, soap_copy_MultiXTpm__Message);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_Stateful1 > 0 || soap_flag_DbProtected1 > 0 || soap_flag_Timeout1 > 0 || soap_flag_Priority1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__Message * SOAP_FMAC6 soap_new_MultiXTpm__Message(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__Message(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__Message(struct soap *soap, MultiXTpm__Message *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__Message * SOAP_FMAC4 soap_instantiate_MultiXTpm__Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__Message(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__Message, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__Message;
		if (size)
			*size = sizeof(MultiXTpm__Message);
		((MultiXTpm__Message*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__Message[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__Message);
		for (int i = 0; i < n; i++)
			((MultiXTpm__Message*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__Message*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__Message(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__Message %p -> %p\n", q, p));
	*(MultiXTpm__Message*)p = *(MultiXTpm__Message*)q;
}

void MultiXTpm__ArrayOfMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToMultiXTpm__Message(soap, &this->MultiXTpm__ArrayOfMessage::Message);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__Message(soap, &this->MultiXTpm__ArrayOfMessage::Message);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfMessage);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfMessage(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfMessage), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToMultiXTpm__Message(soap, "MultiXTpm:Message", -1, &(a->MultiXTpm__ArrayOfMessage::Message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfMessage(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfMessage * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfMessage(struct soap *soap, MultiXTpm__ArrayOfMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfMessage(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfMessage * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfMessage(struct soap *soap, const char *tag, MultiXTpm__ArrayOfMessage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfMessage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfMessage, sizeof(MultiXTpm__ArrayOfMessage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfMessage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfMessage *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToMultiXTpm__Message(soap, "MultiXTpm:Message", &(a->MultiXTpm__ArrayOfMessage::Message), "MultiXTpm:Message"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfMessage, 0, sizeof(MultiXTpm__ArrayOfMessage), 0, soap_copy_MultiXTpm__ArrayOfMessage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfMessage * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfMessage(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfMessage(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfMessage(struct soap *soap, MultiXTpm__ArrayOfMessage *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfMessage * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfMessage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfMessage;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfMessage);
		((MultiXTpm__ArrayOfMessage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfMessage[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfMessage);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfMessage*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfMessage*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfMessage %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfMessage*)p = *(MultiXTpm__ArrayOfMessage*)q;
}

void MultiXTpm__Group::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->MultiXTpm__Group::ID);
	this->MultiXTpm__Group::Description = NULL;
	this->MultiXTpm__Group::ProcessClassIDs = NULL;
	/* transient soap skipped */
}

void MultiXTpm__Group::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Group::Description);
	soap_serialize_PointerToMultiXTpm__ArrayOfInt(soap, &this->MultiXTpm__Group::ProcessClassIDs);
	/* transient soap skipped */
}

int MultiXTpm__Group::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__Group);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__Group::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__Group(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__Group(struct soap *soap, const char *tag, int id, const MultiXTpm__Group *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__Group), type))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:ID", -1, &(a->MultiXTpm__Group::ID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:Description", -1, &(a->MultiXTpm__Group::Description), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt(soap, "MultiXTpm:ProcessClassIDs", -1, &(a->MultiXTpm__Group::ProcessClassIDs), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__Group::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__Group(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__Group * SOAP_FMAC4 soap_get_MultiXTpm__Group(struct soap *soap, MultiXTpm__Group *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__Group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__Group::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__Group(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__Group * SOAP_FMAC4 soap_in_MultiXTpm__Group(struct soap *soap, const char *tag, MultiXTpm__Group *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__Group *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__Group, sizeof(MultiXTpm__Group), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__Group)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__Group *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ID1 = 1, soap_flag_Description1 = 1, soap_flag_ProcessClassIDs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:ID", &(a->MultiXTpm__Group::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:Description", &(a->MultiXTpm__Group::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_ProcessClassIDs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt(soap, "MultiXTpm:ProcessClassIDs", &(a->MultiXTpm__Group::ProcessClassIDs), "MultiXTpm:ArrayOfInt"))
				{	soap_flag_ProcessClassIDs1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__Group *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__Group, 0, sizeof(MultiXTpm__Group), 0, soap_copy_MultiXTpm__Group);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__Group * SOAP_FMAC6 soap_new_MultiXTpm__Group(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__Group(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__Group(struct soap *soap, MultiXTpm__Group *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__Group * SOAP_FMAC4 soap_instantiate_MultiXTpm__Group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__Group(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__Group, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__Group;
		if (size)
			*size = sizeof(MultiXTpm__Group);
		((MultiXTpm__Group*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__Group[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__Group);
		for (int i = 0; i < n; i++)
			((MultiXTpm__Group*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__Group*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__Group(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__Group %p -> %p\n", q, p));
	*(MultiXTpm__Group*)p = *(MultiXTpm__Group*)q;
}

void MultiXTpm__ArrayOfGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToMultiXTpm__Group(soap, &this->MultiXTpm__ArrayOfGroup::Group);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__Group(soap, &this->MultiXTpm__ArrayOfGroup::Group);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfGroup);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfGroup(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfGroup), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToMultiXTpm__Group(soap, "MultiXTpm:Group", -1, &(a->MultiXTpm__ArrayOfGroup::Group), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfGroup(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroup * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfGroup(struct soap *soap, MultiXTpm__ArrayOfGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfGroup(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroup * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfGroup(struct soap *soap, const char *tag, MultiXTpm__ArrayOfGroup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfGroup, sizeof(MultiXTpm__ArrayOfGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfGroup *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToMultiXTpm__Group(soap, "MultiXTpm:Group", &(a->MultiXTpm__ArrayOfGroup::Group), "MultiXTpm:Group"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfGroup, 0, sizeof(MultiXTpm__ArrayOfGroup), 0, soap_copy_MultiXTpm__ArrayOfGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfGroup * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfGroup(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfGroup(struct soap *soap, MultiXTpm__ArrayOfGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroup * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfGroup;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfGroup);
		((MultiXTpm__ArrayOfGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfGroup);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfGroup*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfGroup %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfGroup*)p = *(MultiXTpm__ArrayOfGroup*)q;
}

void MultiXTpm__SSLParams::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_MultiXTpm__SSL_USCOREAPI(soap, &this->MultiXTpm__SSLParams::API);
	soap_default_bool(soap, &this->MultiXTpm__SSLParams::ClientAuthenticationRequired);
	soap_default_bool(soap, &this->MultiXTpm__SSLParams::ServerAuthenticationRequired);
	soap_default_bool(soap, &this->MultiXTpm__SSLParams::ServerNameVerificationRequired);
	this->MultiXTpm__SSLParams::TrustStoreFile = NULL;
	this->MultiXTpm__SSLParams::TrustStoreDirectory = NULL;
	this->MultiXTpm__SSLParams::CertificateFile = NULL;
	this->MultiXTpm__SSLParams::PrivateKeyFile = NULL;
	this->MultiXTpm__SSLParams::PrivateKeyPassword = NULL;
	this->MultiXTpm__SSLParams::PrivateKeyPasswordFile = NULL;
	this->MultiXTpm__SSLParams::RSAPrivateKeyFile = NULL;
	this->MultiXTpm__SSLParams::DHFile = NULL;
	/* transient soap skipped */
}

void MultiXTpm__SSLParams::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SSLParams::TrustStoreFile);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SSLParams::TrustStoreDirectory);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SSLParams::CertificateFile);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SSLParams::PrivateKeyFile);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SSLParams::PrivateKeyPassword);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SSLParams::PrivateKeyPasswordFile);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SSLParams::RSAPrivateKeyFile);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__SSLParams::DHFile);
	/* transient soap skipped */
}

int MultiXTpm__SSLParams::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__SSLParams);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__SSLParams::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__SSLParams(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__SSLParams(struct soap *soap, const char *tag, int id, const MultiXTpm__SSLParams *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__SSLParams), type))
		return soap->error;
	if (soap_out_MultiXTpm__SSL_USCOREAPI(soap, "MultiXTpm:API", -1, &(a->MultiXTpm__SSLParams::API), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ClientAuthenticationRequired", -1, &(a->MultiXTpm__SSLParams::ClientAuthenticationRequired), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ServerAuthenticationRequired", -1, &(a->MultiXTpm__SSLParams::ServerAuthenticationRequired), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ServerNameVerificationRequired", -1, &(a->MultiXTpm__SSLParams::ServerNameVerificationRequired), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:TrustStoreFile", -1, &(a->MultiXTpm__SSLParams::TrustStoreFile), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:TrustStoreDirectory", -1, &(a->MultiXTpm__SSLParams::TrustStoreDirectory), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:CertificateFile", -1, &(a->MultiXTpm__SSLParams::CertificateFile), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:PrivateKeyFile", -1, &(a->MultiXTpm__SSLParams::PrivateKeyFile), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:PrivateKeyPassword", -1, &(a->MultiXTpm__SSLParams::PrivateKeyPassword), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:PrivateKeyPasswordFile", -1, &(a->MultiXTpm__SSLParams::PrivateKeyPasswordFile), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:RSAPrivateKeyFile", -1, &(a->MultiXTpm__SSLParams::RSAPrivateKeyFile), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:DHFile", -1, &(a->MultiXTpm__SSLParams::DHFile), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__SSLParams::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__SSLParams(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__SSLParams * SOAP_FMAC4 soap_get_MultiXTpm__SSLParams(struct soap *soap, MultiXTpm__SSLParams *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__SSLParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__SSLParams::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__SSLParams(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__SSLParams * SOAP_FMAC4 soap_in_MultiXTpm__SSLParams(struct soap *soap, const char *tag, MultiXTpm__SSLParams *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__SSLParams *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__SSLParams, sizeof(MultiXTpm__SSLParams), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__SSLParams)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__SSLParams *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_API1 = 1, soap_flag_ClientAuthenticationRequired1 = 1, soap_flag_ServerAuthenticationRequired1 = 1, soap_flag_ServerNameVerificationRequired1 = 1, soap_flag_TrustStoreFile1 = 1, soap_flag_TrustStoreDirectory1 = 1, soap_flag_CertificateFile1 = 1, soap_flag_PrivateKeyFile1 = 1, soap_flag_PrivateKeyPassword1 = 1, soap_flag_PrivateKeyPasswordFile1 = 1, soap_flag_RSAPrivateKeyFile1 = 1, soap_flag_DHFile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_API1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_MultiXTpm__SSL_USCOREAPI(soap, "MultiXTpm:API", &(a->MultiXTpm__SSLParams::API), "MultiXTpm:SSL_API"))
				{	soap_flag_API1--;
					continue;
				}
			if (soap_flag_ClientAuthenticationRequired1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ClientAuthenticationRequired", &(a->MultiXTpm__SSLParams::ClientAuthenticationRequired), "xsd:boolean"))
				{	soap_flag_ClientAuthenticationRequired1--;
					continue;
				}
			if (soap_flag_ServerAuthenticationRequired1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ServerAuthenticationRequired", &(a->MultiXTpm__SSLParams::ServerAuthenticationRequired), "xsd:boolean"))
				{	soap_flag_ServerAuthenticationRequired1--;
					continue;
				}
			if (soap_flag_ServerNameVerificationRequired1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ServerNameVerificationRequired", &(a->MultiXTpm__SSLParams::ServerNameVerificationRequired), "xsd:boolean"))
				{	soap_flag_ServerNameVerificationRequired1--;
					continue;
				}
			if (soap_flag_TrustStoreFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:TrustStoreFile", &(a->MultiXTpm__SSLParams::TrustStoreFile), "xsd:string"))
				{	soap_flag_TrustStoreFile1--;
					continue;
				}
			if (soap_flag_TrustStoreDirectory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:TrustStoreDirectory", &(a->MultiXTpm__SSLParams::TrustStoreDirectory), "xsd:string"))
				{	soap_flag_TrustStoreDirectory1--;
					continue;
				}
			if (soap_flag_CertificateFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:CertificateFile", &(a->MultiXTpm__SSLParams::CertificateFile), "xsd:string"))
				{	soap_flag_CertificateFile1--;
					continue;
				}
			if (soap_flag_PrivateKeyFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:PrivateKeyFile", &(a->MultiXTpm__SSLParams::PrivateKeyFile), "xsd:string"))
				{	soap_flag_PrivateKeyFile1--;
					continue;
				}
			if (soap_flag_PrivateKeyPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:PrivateKeyPassword", &(a->MultiXTpm__SSLParams::PrivateKeyPassword), "xsd:string"))
				{	soap_flag_PrivateKeyPassword1--;
					continue;
				}
			if (soap_flag_PrivateKeyPasswordFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:PrivateKeyPasswordFile", &(a->MultiXTpm__SSLParams::PrivateKeyPasswordFile), "xsd:string"))
				{	soap_flag_PrivateKeyPasswordFile1--;
					continue;
				}
			if (soap_flag_RSAPrivateKeyFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:RSAPrivateKeyFile", &(a->MultiXTpm__SSLParams::RSAPrivateKeyFile), "xsd:string"))
				{	soap_flag_RSAPrivateKeyFile1--;
					continue;
				}
			if (soap_flag_DHFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:DHFile", &(a->MultiXTpm__SSLParams::DHFile), "xsd:string"))
				{	soap_flag_DHFile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__SSLParams *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__SSLParams, 0, sizeof(MultiXTpm__SSLParams), 0, soap_copy_MultiXTpm__SSLParams);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_API1 > 0 || soap_flag_ClientAuthenticationRequired1 > 0 || soap_flag_ServerAuthenticationRequired1 > 0 || soap_flag_ServerNameVerificationRequired1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__SSLParams * SOAP_FMAC6 soap_new_MultiXTpm__SSLParams(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__SSLParams(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__SSLParams(struct soap *soap, MultiXTpm__SSLParams *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__SSLParams * SOAP_FMAC4 soap_instantiate_MultiXTpm__SSLParams(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__SSLParams(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__SSLParams, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__SSLParams;
		if (size)
			*size = sizeof(MultiXTpm__SSLParams);
		((MultiXTpm__SSLParams*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__SSLParams[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__SSLParams);
		for (int i = 0; i < n; i++)
			((MultiXTpm__SSLParams*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__SSLParams*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__SSLParams(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__SSLParams %p -> %p\n", q, p));
	*(MultiXTpm__SSLParams*)p = *(MultiXTpm__SSLParams*)q;
}

void MultiXTpm__Link::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->MultiXTpm__Link::ID);
	this->MultiXTpm__Link::Description = NULL;
	soap_default_MultiXTpm__MultiXLinkType(soap, &this->MultiXTpm__Link::LinkType);
	soap_default_MultiXTpm__MultiXOpenMode(soap, &this->MultiXTpm__Link::OpenMode);
	soap_default_bool(soap, &this->MultiXTpm__Link::Raw);
	this->MultiXTpm__Link::LocalAddress = NULL;
	this->MultiXTpm__Link::LocalPort = NULL;
	this->MultiXTpm__Link::RemoteAddress = NULL;
	this->MultiXTpm__Link::RemotePort = NULL;
	this->MultiXTpm__Link::SSLParams = NULL;
	this->MultiXTpm__Link::Params = NULL;
	/* transient soap skipped */
}

void MultiXTpm__Link::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Link::Description);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Link::LocalAddress);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Link::LocalPort);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Link::RemoteAddress);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Link::RemotePort);
	soap_serialize_PointerToMultiXTpm__SSLParams(soap, &this->MultiXTpm__Link::SSLParams);
	soap_serialize_PointerToMultiXTpm__ArrayOfParam(soap, &this->MultiXTpm__Link::Params);
	/* transient soap skipped */
}

int MultiXTpm__Link::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__Link);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__Link::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__Link(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__Link(struct soap *soap, const char *tag, int id, const MultiXTpm__Link *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__Link), type))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:ID", -1, &(a->MultiXTpm__Link::ID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:Description", -1, &(a->MultiXTpm__Link::Description), ""))
		return soap->error;
	if (soap_out_MultiXTpm__MultiXLinkType(soap, "MultiXTpm:LinkType", -1, &(a->MultiXTpm__Link::LinkType), ""))
		return soap->error;
	if (soap_out_MultiXTpm__MultiXOpenMode(soap, "MultiXTpm:OpenMode", -1, &(a->MultiXTpm__Link::OpenMode), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:Raw", -1, &(a->MultiXTpm__Link::Raw), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:LocalAddress", -1, &(a->MultiXTpm__Link::LocalAddress), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:LocalPort", -1, &(a->MultiXTpm__Link::LocalPort), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:RemoteAddress", -1, &(a->MultiXTpm__Link::RemoteAddress), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:RemotePort", -1, &(a->MultiXTpm__Link::RemotePort), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__SSLParams(soap, "MultiXTpm:SSLParams", -1, &(a->MultiXTpm__Link::SSLParams), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfParam(soap, "MultiXTpm:Params", -1, &(a->MultiXTpm__Link::Params), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__Link::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__Link(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__Link * SOAP_FMAC4 soap_get_MultiXTpm__Link(struct soap *soap, MultiXTpm__Link *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__Link(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__Link::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__Link(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__Link * SOAP_FMAC4 soap_in_MultiXTpm__Link(struct soap *soap, const char *tag, MultiXTpm__Link *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__Link *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__Link, sizeof(MultiXTpm__Link), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__Link)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__Link *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ID1 = 1, soap_flag_Description1 = 1, soap_flag_LinkType1 = 1, soap_flag_OpenMode1 = 1, soap_flag_Raw1 = 1, soap_flag_LocalAddress1 = 1, soap_flag_LocalPort1 = 1, soap_flag_RemoteAddress1 = 1, soap_flag_RemotePort1 = 1, soap_flag_SSLParams1 = 1, soap_flag_Params1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:ID", &(a->MultiXTpm__Link::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:Description", &(a->MultiXTpm__Link::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_LinkType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_MultiXTpm__MultiXLinkType(soap, "MultiXTpm:LinkType", &(a->MultiXTpm__Link::LinkType), "MultiXTpm:MultiXLinkType"))
				{	soap_flag_LinkType1--;
					continue;
				}
			if (soap_flag_OpenMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_MultiXTpm__MultiXOpenMode(soap, "MultiXTpm:OpenMode", &(a->MultiXTpm__Link::OpenMode), "MultiXTpm:MultiXOpenMode"))
				{	soap_flag_OpenMode1--;
					continue;
				}
			if (soap_flag_Raw1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:Raw", &(a->MultiXTpm__Link::Raw), "xsd:boolean"))
				{	soap_flag_Raw1--;
					continue;
				}
			if (soap_flag_LocalAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:LocalAddress", &(a->MultiXTpm__Link::LocalAddress), "xsd:string"))
				{	soap_flag_LocalAddress1--;
					continue;
				}
			if (soap_flag_LocalPort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:LocalPort", &(a->MultiXTpm__Link::LocalPort), "xsd:string"))
				{	soap_flag_LocalPort1--;
					continue;
				}
			if (soap_flag_RemoteAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:RemoteAddress", &(a->MultiXTpm__Link::RemoteAddress), "xsd:string"))
				{	soap_flag_RemoteAddress1--;
					continue;
				}
			if (soap_flag_RemotePort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:RemotePort", &(a->MultiXTpm__Link::RemotePort), "xsd:string"))
				{	soap_flag_RemotePort1--;
					continue;
				}
			if (soap_flag_SSLParams1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__SSLParams(soap, "MultiXTpm:SSLParams", &(a->MultiXTpm__Link::SSLParams), "MultiXTpm:SSLParams"))
				{	soap_flag_SSLParams1--;
					continue;
				}
			if (soap_flag_Params1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfParam(soap, "MultiXTpm:Params", &(a->MultiXTpm__Link::Params), "MultiXTpm:ArrayOfParam"))
				{	soap_flag_Params1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__Link *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__Link, 0, sizeof(MultiXTpm__Link), 0, soap_copy_MultiXTpm__Link);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_LinkType1 > 0 || soap_flag_OpenMode1 > 0 || soap_flag_Raw1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__Link * SOAP_FMAC6 soap_new_MultiXTpm__Link(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__Link(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__Link(struct soap *soap, MultiXTpm__Link *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__Link * SOAP_FMAC4 soap_instantiate_MultiXTpm__Link(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__Link(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__Link, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__Link;
		if (size)
			*size = sizeof(MultiXTpm__Link);
		((MultiXTpm__Link*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__Link[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__Link);
		for (int i = 0; i < n; i++)
			((MultiXTpm__Link*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__Link*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__Link(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__Link %p -> %p\n", q, p));
	*(MultiXTpm__Link*)p = *(MultiXTpm__Link*)q;
}

void MultiXTpm__ArrayOfLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToMultiXTpm__Link(soap, &this->MultiXTpm__ArrayOfLink::Link);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfLink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__Link(soap, &this->MultiXTpm__ArrayOfLink::Link);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfLink);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfLink(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfLink), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToMultiXTpm__Link(soap, "MultiXTpm:Link", -1, &(a->MultiXTpm__ArrayOfLink::Link), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfLink(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfLink * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfLink(struct soap *soap, MultiXTpm__ArrayOfLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfLink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfLink(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfLink * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfLink(struct soap *soap, const char *tag, MultiXTpm__ArrayOfLink *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfLink *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfLink, sizeof(MultiXTpm__ArrayOfLink), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfLink)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfLink *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToMultiXTpm__Link(soap, "MultiXTpm:Link", &(a->MultiXTpm__ArrayOfLink::Link), "MultiXTpm:Link"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfLink, 0, sizeof(MultiXTpm__ArrayOfLink), 0, soap_copy_MultiXTpm__ArrayOfLink);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfLink * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfLink(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfLink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfLink(struct soap *soap, MultiXTpm__ArrayOfLink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfLink * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfLink;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfLink);
		((MultiXTpm__ArrayOfLink*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfLink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfLink);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfLink*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfLink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfLink %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfLink*)p = *(MultiXTpm__ArrayOfLink*)q;
}

void MultiXTpm__ArrayOfInt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->MultiXTpm__ArrayOfInt::ID);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfInt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->MultiXTpm__ArrayOfInt::ID);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfInt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfInt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfInt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfInt(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfInt *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfInt), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "MultiXTpm:ID", -1, &(a->MultiXTpm__ArrayOfInt::ID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfInt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfInt(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfInt * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfInt(struct soap *soap, MultiXTpm__ArrayOfInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfInt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfInt(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfInt * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfInt(struct soap *soap, const char *tag, MultiXTpm__ArrayOfInt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfInt, sizeof(MultiXTpm__ArrayOfInt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfInt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfInt *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "MultiXTpm:ID", &(a->MultiXTpm__ArrayOfInt::ID), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfInt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfInt, 0, sizeof(MultiXTpm__ArrayOfInt), 0, soap_copy_MultiXTpm__ArrayOfInt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfInt * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfInt(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfInt(struct soap *soap, MultiXTpm__ArrayOfInt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfInt * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfInt;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfInt);
		((MultiXTpm__ArrayOfInt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfInt);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfInt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfInt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfInt %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfInt*)p = *(MultiXTpm__ArrayOfInt*)q;
}

void MultiXTpm__Param::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->MultiXTpm__Param::ParamName = NULL;
	this->MultiXTpm__Param::ParamValue = NULL;
	this->MultiXTpm__Param::XmlParamValue = NULL;
	/* transient soap skipped */
}

void MultiXTpm__Param::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Param::ParamName);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__Param::ParamValue);
	soap_serialize_PointerTo_MultiXTpm__Param_XmlParamValue(soap, &this->MultiXTpm__Param::XmlParamValue);
	/* transient soap skipped */
}

int MultiXTpm__Param::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__Param);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__Param::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__Param(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__Param(struct soap *soap, const char *tag, int id, const MultiXTpm__Param *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__Param), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:ParamName", -1, &(a->MultiXTpm__Param::ParamName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:ParamValue", -1, &(a->MultiXTpm__Param::ParamValue), ""))
		return soap->error;
	if (soap_out_PointerTo_MultiXTpm__Param_XmlParamValue(soap, "MultiXTpm:XmlParamValue", -1, &(a->MultiXTpm__Param::XmlParamValue), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__Param::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__Param(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__Param * SOAP_FMAC4 soap_get_MultiXTpm__Param(struct soap *soap, MultiXTpm__Param *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__Param(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__Param::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__Param(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__Param * SOAP_FMAC4 soap_in_MultiXTpm__Param(struct soap *soap, const char *tag, MultiXTpm__Param *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__Param *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__Param, sizeof(MultiXTpm__Param), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__Param)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__Param *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ParamName1 = 1, soap_flag_ParamValue1 = 1, soap_flag_XmlParamValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParamName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:ParamName", &(a->MultiXTpm__Param::ParamName), "xsd:string"))
				{	soap_flag_ParamName1--;
					continue;
				}
			if (soap_flag_ParamValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:ParamValue", &(a->MultiXTpm__Param::ParamValue), "xsd:string"))
				{	soap_flag_ParamValue1--;
					continue;
				}
			if (soap_flag_XmlParamValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__Param_XmlParamValue(soap, "MultiXTpm:XmlParamValue", &(a->MultiXTpm__Param::XmlParamValue), ""))
				{	soap_flag_XmlParamValue1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__Param *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__Param, 0, sizeof(MultiXTpm__Param), 0, soap_copy_MultiXTpm__Param);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__Param * SOAP_FMAC6 soap_new_MultiXTpm__Param(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__Param(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__Param(struct soap *soap, MultiXTpm__Param *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__Param * SOAP_FMAC4 soap_instantiate_MultiXTpm__Param(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__Param(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__Param, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__Param;
		if (size)
			*size = sizeof(MultiXTpm__Param);
		((MultiXTpm__Param*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__Param[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__Param);
		for (int i = 0; i < n; i++)
			((MultiXTpm__Param*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__Param*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__Param(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__Param %p -> %p\n", q, p));
	*(MultiXTpm__Param*)p = *(MultiXTpm__Param*)q;
}

void MultiXTpm__ArrayOfParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToMultiXTpm__Param(soap, &this->MultiXTpm__ArrayOfParam::Param);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__Param(soap, &this->MultiXTpm__ArrayOfParam::Param);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfParam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfParam(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfParam *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfParam), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToMultiXTpm__Param(soap, "MultiXTpm:Param", -1, &(a->MultiXTpm__ArrayOfParam::Param), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfParam(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfParam * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfParam(struct soap *soap, MultiXTpm__ArrayOfParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfParam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfParam(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfParam * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfParam(struct soap *soap, const char *tag, MultiXTpm__ArrayOfParam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfParam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfParam, sizeof(MultiXTpm__ArrayOfParam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfParam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfParam *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToMultiXTpm__Param(soap, "MultiXTpm:Param", &(a->MultiXTpm__ArrayOfParam::Param), "MultiXTpm:Param"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfParam *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfParam, 0, sizeof(MultiXTpm__ArrayOfParam), 0, soap_copy_MultiXTpm__ArrayOfParam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfParam * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfParam(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfParam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfParam(struct soap *soap, MultiXTpm__ArrayOfParam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfParam * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfParam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfParam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfParam;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfParam);
		((MultiXTpm__ArrayOfParam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfParam[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfParam);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfParam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfParam*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfParam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfParam %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfParam*)p = *(MultiXTpm__ArrayOfParam*)q;
}

void MultiXTpm__ProcessClass::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->MultiXTpm__ProcessClass::ID);
	this->MultiXTpm__ProcessClass::Description = NULL;
	this->MultiXTpm__ProcessClass::PasswordToSend = NULL;
	this->MultiXTpm__ProcessClass::ExpectedPassword = NULL;
	this->MultiXTpm__ProcessClass::ExecCmd = NULL;
	this->MultiXTpm__ProcessClass::ClassName = NULL;
	this->MultiXTpm__ProcessClass::AdditionalConfigTextFile = NULL;
	soap_default_int(soap, &this->MultiXTpm__ProcessClass::DebugLevel);
	soap_default_int(soap, &this->MultiXTpm__ProcessClass::DefaultSendTimeout);
	this->MultiXTpm__ProcessClass::ExecParams = NULL;
	soap_default_int(soap, &this->MultiXTpm__ProcessClass::MaxQueueSize);
	soap_default_int(soap, &this->MultiXTpm__ProcessClass::MaxSessions);
	soap_default_int(soap, &this->MultiXTpm__ProcessClass::MaxRecoveryQueueSize);
	soap_default_bool(soap, &this->MultiXTpm__ProcessClass::AutoStart);
	soap_default_int(soap, &this->MultiXTpm__ProcessClass::MinInstances);
	soap_default_int(soap, &this->MultiXTpm__ProcessClass::MaxInstances);
	soap_default_int(soap, &this->MultiXTpm__ProcessClass::StartProcessDelay);
	soap_default_int(soap, &this->MultiXTpm__ProcessClass::InactivityTimer);
	this->MultiXTpm__ProcessClass::Params = NULL;
	this->MultiXTpm__ProcessClass::LinkIDs = NULL;
	/* transient soap skipped */
}

void MultiXTpm__ProcessClass::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__ProcessClass::Description);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__ProcessClass::PasswordToSend);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__ProcessClass::ExpectedPassword);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__ProcessClass::ExecCmd);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__ProcessClass::ClassName);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__ProcessClass::AdditionalConfigTextFile);
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__ProcessClass::ExecParams);
	soap_serialize_PointerToMultiXTpm__ArrayOfParam(soap, &this->MultiXTpm__ProcessClass::Params);
	soap_serialize_PointerToMultiXTpm__ArrayOfInt(soap, &this->MultiXTpm__ProcessClass::LinkIDs);
	/* transient soap skipped */
}

int MultiXTpm__ProcessClass::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ProcessClass);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ProcessClass::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ProcessClass(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ProcessClass(struct soap *soap, const char *tag, int id, const MultiXTpm__ProcessClass *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ProcessClass), type))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:ID", -1, &(a->MultiXTpm__ProcessClass::ID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:Description", -1, &(a->MultiXTpm__ProcessClass::Description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:PasswordToSend", -1, &(a->MultiXTpm__ProcessClass::PasswordToSend), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:ExpectedPassword", -1, &(a->MultiXTpm__ProcessClass::ExpectedPassword), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:ExecCmd", -1, &(a->MultiXTpm__ProcessClass::ExecCmd), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:ClassName", -1, &(a->MultiXTpm__ProcessClass::ClassName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:AdditionalConfigTextFile", -1, &(a->MultiXTpm__ProcessClass::AdditionalConfigTextFile), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:DebugLevel", -1, &(a->MultiXTpm__ProcessClass::DebugLevel), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:DefaultSendTimeout", -1, &(a->MultiXTpm__ProcessClass::DefaultSendTimeout), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:ExecParams", -1, &(a->MultiXTpm__ProcessClass::ExecParams), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:MaxQueueSize", -1, &(a->MultiXTpm__ProcessClass::MaxQueueSize), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:MaxSessions", -1, &(a->MultiXTpm__ProcessClass::MaxSessions), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:MaxRecoveryQueueSize", -1, &(a->MultiXTpm__ProcessClass::MaxRecoveryQueueSize), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:AutoStart", -1, &(a->MultiXTpm__ProcessClass::AutoStart), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:MinInstances", -1, &(a->MultiXTpm__ProcessClass::MinInstances), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:MaxInstances", -1, &(a->MultiXTpm__ProcessClass::MaxInstances), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:StartProcessDelay", -1, &(a->MultiXTpm__ProcessClass::StartProcessDelay), ""))
		return soap->error;
	if (soap_out_int(soap, "MultiXTpm:InactivityTimer", -1, &(a->MultiXTpm__ProcessClass::InactivityTimer), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfParam(soap, "MultiXTpm:Params", -1, &(a->MultiXTpm__ProcessClass::Params), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfInt(soap, "MultiXTpm:LinkIDs", -1, &(a->MultiXTpm__ProcessClass::LinkIDs), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ProcessClass::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ProcessClass(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ProcessClass * SOAP_FMAC4 soap_get_MultiXTpm__ProcessClass(struct soap *soap, MultiXTpm__ProcessClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ProcessClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ProcessClass::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ProcessClass(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ProcessClass * SOAP_FMAC4 soap_in_MultiXTpm__ProcessClass(struct soap *soap, const char *tag, MultiXTpm__ProcessClass *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ProcessClass *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ProcessClass, sizeof(MultiXTpm__ProcessClass), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ProcessClass)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ProcessClass *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ID1 = 1, soap_flag_Description1 = 1, soap_flag_PasswordToSend1 = 1, soap_flag_ExpectedPassword1 = 1, soap_flag_ExecCmd1 = 1, soap_flag_ClassName1 = 1, soap_flag_AdditionalConfigTextFile1 = 1, soap_flag_DebugLevel1 = 1, soap_flag_DefaultSendTimeout1 = 1, soap_flag_ExecParams1 = 1, soap_flag_MaxQueueSize1 = 1, soap_flag_MaxSessions1 = 1, soap_flag_MaxRecoveryQueueSize1 = 1, soap_flag_AutoStart1 = 1, soap_flag_MinInstances1 = 1, soap_flag_MaxInstances1 = 1, soap_flag_StartProcessDelay1 = 1, soap_flag_InactivityTimer1 = 1, soap_flag_Params1 = 1, soap_flag_LinkIDs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:ID", &(a->MultiXTpm__ProcessClass::ID), "xsd:int"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:Description", &(a->MultiXTpm__ProcessClass::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_PasswordToSend1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:PasswordToSend", &(a->MultiXTpm__ProcessClass::PasswordToSend), "xsd:string"))
				{	soap_flag_PasswordToSend1--;
					continue;
				}
			if (soap_flag_ExpectedPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:ExpectedPassword", &(a->MultiXTpm__ProcessClass::ExpectedPassword), "xsd:string"))
				{	soap_flag_ExpectedPassword1--;
					continue;
				}
			if (soap_flag_ExecCmd1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:ExecCmd", &(a->MultiXTpm__ProcessClass::ExecCmd), "xsd:string"))
				{	soap_flag_ExecCmd1--;
					continue;
				}
			if (soap_flag_ClassName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:ClassName", &(a->MultiXTpm__ProcessClass::ClassName), "xsd:string"))
				{	soap_flag_ClassName1--;
					continue;
				}
			if (soap_flag_AdditionalConfigTextFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:AdditionalConfigTextFile", &(a->MultiXTpm__ProcessClass::AdditionalConfigTextFile), "xsd:string"))
				{	soap_flag_AdditionalConfigTextFile1--;
					continue;
				}
			if (soap_flag_DebugLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:DebugLevel", &(a->MultiXTpm__ProcessClass::DebugLevel), "xsd:int"))
				{	soap_flag_DebugLevel1--;
					continue;
				}
			if (soap_flag_DefaultSendTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:DefaultSendTimeout", &(a->MultiXTpm__ProcessClass::DefaultSendTimeout), "xsd:int"))
				{	soap_flag_DefaultSendTimeout1--;
					continue;
				}
			if (soap_flag_ExecParams1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:ExecParams", &(a->MultiXTpm__ProcessClass::ExecParams), "xsd:string"))
				{	soap_flag_ExecParams1--;
					continue;
				}
			if (soap_flag_MaxQueueSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:MaxQueueSize", &(a->MultiXTpm__ProcessClass::MaxQueueSize), "xsd:int"))
				{	soap_flag_MaxQueueSize1--;
					continue;
				}
			if (soap_flag_MaxSessions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:MaxSessions", &(a->MultiXTpm__ProcessClass::MaxSessions), "xsd:int"))
				{	soap_flag_MaxSessions1--;
					continue;
				}
			if (soap_flag_MaxRecoveryQueueSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:MaxRecoveryQueueSize", &(a->MultiXTpm__ProcessClass::MaxRecoveryQueueSize), "xsd:int"))
				{	soap_flag_MaxRecoveryQueueSize1--;
					continue;
				}
			if (soap_flag_AutoStart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:AutoStart", &(a->MultiXTpm__ProcessClass::AutoStart), "xsd:boolean"))
				{	soap_flag_AutoStart1--;
					continue;
				}
			if (soap_flag_MinInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:MinInstances", &(a->MultiXTpm__ProcessClass::MinInstances), "xsd:int"))
				{	soap_flag_MinInstances1--;
					continue;
				}
			if (soap_flag_MaxInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:MaxInstances", &(a->MultiXTpm__ProcessClass::MaxInstances), "xsd:int"))
				{	soap_flag_MaxInstances1--;
					continue;
				}
			if (soap_flag_StartProcessDelay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:StartProcessDelay", &(a->MultiXTpm__ProcessClass::StartProcessDelay), "xsd:int"))
				{	soap_flag_StartProcessDelay1--;
					continue;
				}
			if (soap_flag_InactivityTimer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "MultiXTpm:InactivityTimer", &(a->MultiXTpm__ProcessClass::InactivityTimer), "xsd:int"))
				{	soap_flag_InactivityTimer1--;
					continue;
				}
			if (soap_flag_Params1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfParam(soap, "MultiXTpm:Params", &(a->MultiXTpm__ProcessClass::Params), "MultiXTpm:ArrayOfParam"))
				{	soap_flag_Params1--;
					continue;
				}
			if (soap_flag_LinkIDs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfInt(soap, "MultiXTpm:LinkIDs", &(a->MultiXTpm__ProcessClass::LinkIDs), "MultiXTpm:ArrayOfInt"))
				{	soap_flag_LinkIDs1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ProcessClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ProcessClass, 0, sizeof(MultiXTpm__ProcessClass), 0, soap_copy_MultiXTpm__ProcessClass);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0 || soap_flag_DebugLevel1 > 0 || soap_flag_DefaultSendTimeout1 > 0 || soap_flag_MaxQueueSize1 > 0 || soap_flag_MaxSessions1 > 0 || soap_flag_MaxRecoveryQueueSize1 > 0 || soap_flag_AutoStart1 > 0 || soap_flag_MinInstances1 > 0 || soap_flag_MaxInstances1 > 0 || soap_flag_StartProcessDelay1 > 0 || soap_flag_InactivityTimer1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ProcessClass * SOAP_FMAC6 soap_new_MultiXTpm__ProcessClass(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ProcessClass(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ProcessClass(struct soap *soap, MultiXTpm__ProcessClass *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ProcessClass * SOAP_FMAC4 soap_instantiate_MultiXTpm__ProcessClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ProcessClass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ProcessClass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ProcessClass;
		if (size)
			*size = sizeof(MultiXTpm__ProcessClass);
		((MultiXTpm__ProcessClass*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ProcessClass[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ProcessClass);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ProcessClass*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ProcessClass*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ProcessClass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ProcessClass %p -> %p\n", q, p));
	*(MultiXTpm__ProcessClass*)p = *(MultiXTpm__ProcessClass*)q;
}

void MultiXTpm__ArrayOfProcessClass::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(soap, &this->MultiXTpm__ArrayOfProcessClass::ProcessClass);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfProcessClass::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(soap, &this->MultiXTpm__ArrayOfProcessClass::ProcessClass);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfProcessClass::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfProcessClass);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfProcessClass::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfProcessClass(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfProcessClass(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfProcessClass *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfProcessClass), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(soap, "MultiXTpm:ProcessClass", -1, &(a->MultiXTpm__ArrayOfProcessClass::ProcessClass), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfProcessClass::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfProcessClass(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfProcessClass * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfProcessClass(struct soap *soap, MultiXTpm__ArrayOfProcessClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfProcessClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfProcessClass::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfProcessClass(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfProcessClass * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfProcessClass(struct soap *soap, const char *tag, MultiXTpm__ArrayOfProcessClass *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfProcessClass *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfProcessClass, sizeof(MultiXTpm__ArrayOfProcessClass), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfProcessClass)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfProcessClass *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(soap, "MultiXTpm:ProcessClass", &(a->MultiXTpm__ArrayOfProcessClass::ProcessClass), "MultiXTpm:ProcessClass"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfProcessClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfProcessClass, 0, sizeof(MultiXTpm__ArrayOfProcessClass), 0, soap_copy_MultiXTpm__ArrayOfProcessClass);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfProcessClass * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfProcessClass(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfProcessClass(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfProcessClass(struct soap *soap, MultiXTpm__ArrayOfProcessClass *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfProcessClass * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfProcessClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfProcessClass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfProcessClass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfProcessClass;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfProcessClass);
		((MultiXTpm__ArrayOfProcessClass*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfProcessClass[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfProcessClass);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfProcessClass*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfProcessClass*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfProcessClass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfProcessClass %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfProcessClass*)p = *(MultiXTpm__ArrayOfProcessClass*)q;
}

void MultiXTpm__UserPermission::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->MultiXTpm__UserPermission::UserName = NULL;
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::IsGroup);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::GetWSDL);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::GetConfig);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::UpdateConfig);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::GetSystemStatus);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::RestartProcess);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::RestartGroup);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::StartProcess);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::StartGroup);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::ShutdownProcess);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::ShutdownGroup);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::SuspendGroup);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::SuspendProcess);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::ResumeGroup);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::ResumeProcess);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::RestartAll);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::StartAll);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::ShutdownAll);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::SuspendAll);
	soap_default_bool(soap, &this->MultiXTpm__UserPermission::ResumeAll);
	/* transient soap skipped */
}

void MultiXTpm__UserPermission::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__UserPermission::UserName);
	/* transient soap skipped */
}

int MultiXTpm__UserPermission::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__UserPermission);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__UserPermission::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__UserPermission(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__UserPermission(struct soap *soap, const char *tag, int id, const MultiXTpm__UserPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__UserPermission), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:UserName", -1, &(a->MultiXTpm__UserPermission::UserName), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:IsGroup", -1, &(a->MultiXTpm__UserPermission::IsGroup), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:GetWSDL", -1, &(a->MultiXTpm__UserPermission::GetWSDL), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:GetConfig", -1, &(a->MultiXTpm__UserPermission::GetConfig), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:UpdateConfig", -1, &(a->MultiXTpm__UserPermission::UpdateConfig), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:GetSystemStatus", -1, &(a->MultiXTpm__UserPermission::GetSystemStatus), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:RestartProcess", -1, &(a->MultiXTpm__UserPermission::RestartProcess), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:RestartGroup", -1, &(a->MultiXTpm__UserPermission::RestartGroup), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:StartProcess", -1, &(a->MultiXTpm__UserPermission::StartProcess), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:StartGroup", -1, &(a->MultiXTpm__UserPermission::StartGroup), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ShutdownProcess", -1, &(a->MultiXTpm__UserPermission::ShutdownProcess), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ShutdownGroup", -1, &(a->MultiXTpm__UserPermission::ShutdownGroup), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:SuspendGroup", -1, &(a->MultiXTpm__UserPermission::SuspendGroup), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:SuspendProcess", -1, &(a->MultiXTpm__UserPermission::SuspendProcess), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ResumeGroup", -1, &(a->MultiXTpm__UserPermission::ResumeGroup), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ResumeProcess", -1, &(a->MultiXTpm__UserPermission::ResumeProcess), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:RestartAll", -1, &(a->MultiXTpm__UserPermission::RestartAll), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:StartAll", -1, &(a->MultiXTpm__UserPermission::StartAll), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ShutdownAll", -1, &(a->MultiXTpm__UserPermission::ShutdownAll), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:SuspendAll", -1, &(a->MultiXTpm__UserPermission::SuspendAll), ""))
		return soap->error;
	if (soap_out_bool(soap, "MultiXTpm:ResumeAll", -1, &(a->MultiXTpm__UserPermission::ResumeAll), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__UserPermission::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__UserPermission(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__UserPermission * SOAP_FMAC4 soap_get_MultiXTpm__UserPermission(struct soap *soap, MultiXTpm__UserPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__UserPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__UserPermission::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__UserPermission(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__UserPermission * SOAP_FMAC4 soap_in_MultiXTpm__UserPermission(struct soap *soap, const char *tag, MultiXTpm__UserPermission *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__UserPermission *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__UserPermission, sizeof(MultiXTpm__UserPermission), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__UserPermission)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__UserPermission *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_UserName1 = 1, soap_flag_IsGroup1 = 1, soap_flag_GetWSDL1 = 1, soap_flag_GetConfig1 = 1, soap_flag_UpdateConfig1 = 1, soap_flag_GetSystemStatus1 = 1, soap_flag_RestartProcess1 = 1, soap_flag_RestartGroup1 = 1, soap_flag_StartProcess1 = 1, soap_flag_StartGroup1 = 1, soap_flag_ShutdownProcess1 = 1, soap_flag_ShutdownGroup1 = 1, soap_flag_SuspendGroup1 = 1, soap_flag_SuspendProcess1 = 1, soap_flag_ResumeGroup1 = 1, soap_flag_ResumeProcess1 = 1, soap_flag_RestartAll1 = 1, soap_flag_StartAll1 = 1, soap_flag_ShutdownAll1 = 1, soap_flag_SuspendAll1 = 1, soap_flag_ResumeAll1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:UserName", &(a->MultiXTpm__UserPermission::UserName), "xsd:string"))
				{	soap_flag_UserName1--;
					continue;
				}
			if (soap_flag_IsGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:IsGroup", &(a->MultiXTpm__UserPermission::IsGroup), "xsd:boolean"))
				{	soap_flag_IsGroup1--;
					continue;
				}
			if (soap_flag_GetWSDL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:GetWSDL", &(a->MultiXTpm__UserPermission::GetWSDL), "xsd:boolean"))
				{	soap_flag_GetWSDL1--;
					continue;
				}
			if (soap_flag_GetConfig1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:GetConfig", &(a->MultiXTpm__UserPermission::GetConfig), "xsd:boolean"))
				{	soap_flag_GetConfig1--;
					continue;
				}
			if (soap_flag_UpdateConfig1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:UpdateConfig", &(a->MultiXTpm__UserPermission::UpdateConfig), "xsd:boolean"))
				{	soap_flag_UpdateConfig1--;
					continue;
				}
			if (soap_flag_GetSystemStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:GetSystemStatus", &(a->MultiXTpm__UserPermission::GetSystemStatus), "xsd:boolean"))
				{	soap_flag_GetSystemStatus1--;
					continue;
				}
			if (soap_flag_RestartProcess1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:RestartProcess", &(a->MultiXTpm__UserPermission::RestartProcess), "xsd:boolean"))
				{	soap_flag_RestartProcess1--;
					continue;
				}
			if (soap_flag_RestartGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:RestartGroup", &(a->MultiXTpm__UserPermission::RestartGroup), "xsd:boolean"))
				{	soap_flag_RestartGroup1--;
					continue;
				}
			if (soap_flag_StartProcess1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:StartProcess", &(a->MultiXTpm__UserPermission::StartProcess), "xsd:boolean"))
				{	soap_flag_StartProcess1--;
					continue;
				}
			if (soap_flag_StartGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:StartGroup", &(a->MultiXTpm__UserPermission::StartGroup), "xsd:boolean"))
				{	soap_flag_StartGroup1--;
					continue;
				}
			if (soap_flag_ShutdownProcess1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ShutdownProcess", &(a->MultiXTpm__UserPermission::ShutdownProcess), "xsd:boolean"))
				{	soap_flag_ShutdownProcess1--;
					continue;
				}
			if (soap_flag_ShutdownGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ShutdownGroup", &(a->MultiXTpm__UserPermission::ShutdownGroup), "xsd:boolean"))
				{	soap_flag_ShutdownGroup1--;
					continue;
				}
			if (soap_flag_SuspendGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:SuspendGroup", &(a->MultiXTpm__UserPermission::SuspendGroup), "xsd:boolean"))
				{	soap_flag_SuspendGroup1--;
					continue;
				}
			if (soap_flag_SuspendProcess1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:SuspendProcess", &(a->MultiXTpm__UserPermission::SuspendProcess), "xsd:boolean"))
				{	soap_flag_SuspendProcess1--;
					continue;
				}
			if (soap_flag_ResumeGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ResumeGroup", &(a->MultiXTpm__UserPermission::ResumeGroup), "xsd:boolean"))
				{	soap_flag_ResumeGroup1--;
					continue;
				}
			if (soap_flag_ResumeProcess1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ResumeProcess", &(a->MultiXTpm__UserPermission::ResumeProcess), "xsd:boolean"))
				{	soap_flag_ResumeProcess1--;
					continue;
				}
			if (soap_flag_RestartAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:RestartAll", &(a->MultiXTpm__UserPermission::RestartAll), "xsd:boolean"))
				{	soap_flag_RestartAll1--;
					continue;
				}
			if (soap_flag_StartAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:StartAll", &(a->MultiXTpm__UserPermission::StartAll), "xsd:boolean"))
				{	soap_flag_StartAll1--;
					continue;
				}
			if (soap_flag_ShutdownAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ShutdownAll", &(a->MultiXTpm__UserPermission::ShutdownAll), "xsd:boolean"))
				{	soap_flag_ShutdownAll1--;
					continue;
				}
			if (soap_flag_SuspendAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:SuspendAll", &(a->MultiXTpm__UserPermission::SuspendAll), "xsd:boolean"))
				{	soap_flag_SuspendAll1--;
					continue;
				}
			if (soap_flag_ResumeAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "MultiXTpm:ResumeAll", &(a->MultiXTpm__UserPermission::ResumeAll), "xsd:boolean"))
				{	soap_flag_ResumeAll1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__UserPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__UserPermission, 0, sizeof(MultiXTpm__UserPermission), 0, soap_copy_MultiXTpm__UserPermission);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IsGroup1 > 0 || soap_flag_GetWSDL1 > 0 || soap_flag_GetConfig1 > 0 || soap_flag_UpdateConfig1 > 0 || soap_flag_GetSystemStatus1 > 0 || soap_flag_RestartProcess1 > 0 || soap_flag_RestartGroup1 > 0 || soap_flag_StartProcess1 > 0 || soap_flag_StartGroup1 > 0 || soap_flag_ShutdownProcess1 > 0 || soap_flag_ShutdownGroup1 > 0 || soap_flag_SuspendGroup1 > 0 || soap_flag_SuspendProcess1 > 0 || soap_flag_ResumeGroup1 > 0 || soap_flag_ResumeProcess1 > 0 || soap_flag_RestartAll1 > 0 || soap_flag_StartAll1 > 0 || soap_flag_ShutdownAll1 > 0 || soap_flag_SuspendAll1 > 0 || soap_flag_ResumeAll1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__UserPermission * SOAP_FMAC6 soap_new_MultiXTpm__UserPermission(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__UserPermission(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__UserPermission(struct soap *soap, MultiXTpm__UserPermission *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__UserPermission * SOAP_FMAC4 soap_instantiate_MultiXTpm__UserPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__UserPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__UserPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__UserPermission;
		if (size)
			*size = sizeof(MultiXTpm__UserPermission);
		((MultiXTpm__UserPermission*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__UserPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__UserPermission);
		for (int i = 0; i < n; i++)
			((MultiXTpm__UserPermission*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__UserPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__UserPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__UserPermission %p -> %p\n", q, p));
	*(MultiXTpm__UserPermission*)p = *(MultiXTpm__UserPermission*)q;
}

void MultiXTpm__ArrayOfUserPermission::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(soap, &this->MultiXTpm__ArrayOfUserPermission::UserPermission);
	/* transient soap skipped */
}

void MultiXTpm__ArrayOfUserPermission::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(soap, &this->MultiXTpm__ArrayOfUserPermission::UserPermission);
	/* transient soap skipped */
}

int MultiXTpm__ArrayOfUserPermission::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ArrayOfUserPermission);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ArrayOfUserPermission::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ArrayOfUserPermission(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ArrayOfUserPermission(struct soap *soap, const char *tag, int id, const MultiXTpm__ArrayOfUserPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ArrayOfUserPermission), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(soap, "MultiXTpm:UserPermission", -1, &(a->MultiXTpm__ArrayOfUserPermission::UserPermission), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ArrayOfUserPermission::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ArrayOfUserPermission(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfUserPermission * SOAP_FMAC4 soap_get_MultiXTpm__ArrayOfUserPermission(struct soap *soap, MultiXTpm__ArrayOfUserPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ArrayOfUserPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ArrayOfUserPermission::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ArrayOfUserPermission(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfUserPermission * SOAP_FMAC4 soap_in_MultiXTpm__ArrayOfUserPermission(struct soap *soap, const char *tag, MultiXTpm__ArrayOfUserPermission *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ArrayOfUserPermission *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ArrayOfUserPermission, sizeof(MultiXTpm__ArrayOfUserPermission), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ArrayOfUserPermission)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ArrayOfUserPermission *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(soap, "MultiXTpm:UserPermission", &(a->MultiXTpm__ArrayOfUserPermission::UserPermission), "MultiXTpm:UserPermission"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ArrayOfUserPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ArrayOfUserPermission, 0, sizeof(MultiXTpm__ArrayOfUserPermission), 0, soap_copy_MultiXTpm__ArrayOfUserPermission);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ArrayOfUserPermission * SOAP_FMAC6 soap_new_MultiXTpm__ArrayOfUserPermission(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ArrayOfUserPermission(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ArrayOfUserPermission(struct soap *soap, MultiXTpm__ArrayOfUserPermission *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ArrayOfUserPermission * SOAP_FMAC4 soap_instantiate_MultiXTpm__ArrayOfUserPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ArrayOfUserPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ArrayOfUserPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfUserPermission;
		if (size)
			*size = sizeof(MultiXTpm__ArrayOfUserPermission);
		((MultiXTpm__ArrayOfUserPermission*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ArrayOfUserPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ArrayOfUserPermission);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ArrayOfUserPermission*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ArrayOfUserPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ArrayOfUserPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ArrayOfUserPermission %p -> %p\n", q, p));
	*(MultiXTpm__ArrayOfUserPermission*)p = *(MultiXTpm__ArrayOfUserPermission*)q;
}

void MultiXTpm__ConfigData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->MultiXTpm__ConfigData::LastUpdate);
	this->MultiXTpm__ConfigData::UsersPermissionsFile = NULL;
	this->MultiXTpm__ConfigData::ProcessClasses = NULL;
	this->MultiXTpm__ConfigData::Links = NULL;
	this->MultiXTpm__ConfigData::Groups = NULL;
	this->MultiXTpm__ConfigData::Messages = NULL;
	this->MultiXTpm__ConfigData::UsersPermissions = NULL;
	/* transient soap skipped */
}

void MultiXTpm__ConfigData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->MultiXTpm__ConfigData::UsersPermissionsFile);
	soap_serialize_PointerToMultiXTpm__ArrayOfProcessClass(soap, &this->MultiXTpm__ConfigData::ProcessClasses);
	soap_serialize_PointerToMultiXTpm__ArrayOfLink(soap, &this->MultiXTpm__ConfigData::Links);
	soap_serialize_PointerToMultiXTpm__ArrayOfGroup(soap, &this->MultiXTpm__ConfigData::Groups);
	soap_serialize_PointerToMultiXTpm__ArrayOfMessage(soap, &this->MultiXTpm__ConfigData::Messages);
	soap_serialize_PointerToMultiXTpm__ArrayOfUserPermission(soap, &this->MultiXTpm__ConfigData::UsersPermissions);
	/* transient soap skipped */
}

int MultiXTpm__ConfigData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_MultiXTpm__ConfigData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int MultiXTpm__ConfigData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_MultiXTpm__ConfigData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MultiXTpm__ConfigData(struct soap *soap, const char *tag, int id, const MultiXTpm__ConfigData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_MultiXTpm__ConfigData), type))
		return soap->error;
	if (soap_out_time(soap, "MultiXTpm:LastUpdate", -1, &(a->MultiXTpm__ConfigData::LastUpdate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MultiXTpm:UsersPermissionsFile", -1, &(a->MultiXTpm__ConfigData::UsersPermissionsFile), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfProcessClass(soap, "MultiXTpm:ProcessClasses", -1, &(a->MultiXTpm__ConfigData::ProcessClasses), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfLink(soap, "MultiXTpm:Links", -1, &(a->MultiXTpm__ConfigData::Links), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfGroup(soap, "MultiXTpm:Groups", -1, &(a->MultiXTpm__ConfigData::Groups), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfMessage(soap, "MultiXTpm:Messages", -1, &(a->MultiXTpm__ConfigData::Messages), ""))
		return soap->error;
	if (soap_out_PointerToMultiXTpm__ArrayOfUserPermission(soap, "MultiXTpm:UsersPermissions", -1, &(a->MultiXTpm__ConfigData::UsersPermissions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *MultiXTpm__ConfigData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_MultiXTpm__ConfigData(soap, this, tag, type);
}

SOAP_FMAC3 MultiXTpm__ConfigData * SOAP_FMAC4 soap_get_MultiXTpm__ConfigData(struct soap *soap, MultiXTpm__ConfigData *p, const char *tag, const char *type)
{
	if ((p = soap_in_MultiXTpm__ConfigData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *MultiXTpm__ConfigData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_MultiXTpm__ConfigData(soap, tag, this, type);
}

SOAP_FMAC3 MultiXTpm__ConfigData * SOAP_FMAC4 soap_in_MultiXTpm__ConfigData(struct soap *soap, const char *tag, MultiXTpm__ConfigData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (MultiXTpm__ConfigData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_MultiXTpm__ConfigData, sizeof(MultiXTpm__ConfigData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_MultiXTpm__ConfigData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (MultiXTpm__ConfigData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_LastUpdate1 = 1, soap_flag_UsersPermissionsFile1 = 1, soap_flag_ProcessClasses1 = 1, soap_flag_Links1 = 1, soap_flag_Groups1 = 1, soap_flag_Messages1 = 1, soap_flag_UsersPermissions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LastUpdate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "MultiXTpm:LastUpdate", &(a->MultiXTpm__ConfigData::LastUpdate), "xsd:dateTime"))
				{	soap_flag_LastUpdate1--;
					continue;
				}
			if (soap_flag_UsersPermissionsFile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MultiXTpm:UsersPermissionsFile", &(a->MultiXTpm__ConfigData::UsersPermissionsFile), "xsd:string"))
				{	soap_flag_UsersPermissionsFile1--;
					continue;
				}
			if (soap_flag_ProcessClasses1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfProcessClass(soap, "MultiXTpm:ProcessClasses", &(a->MultiXTpm__ConfigData::ProcessClasses), "MultiXTpm:ArrayOfProcessClass"))
				{	soap_flag_ProcessClasses1--;
					continue;
				}
			if (soap_flag_Links1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfLink(soap, "MultiXTpm:Links", &(a->MultiXTpm__ConfigData::Links), "MultiXTpm:ArrayOfLink"))
				{	soap_flag_Links1--;
					continue;
				}
			if (soap_flag_Groups1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfGroup(soap, "MultiXTpm:Groups", &(a->MultiXTpm__ConfigData::Groups), "MultiXTpm:ArrayOfGroup"))
				{	soap_flag_Groups1--;
					continue;
				}
			if (soap_flag_Messages1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfMessage(soap, "MultiXTpm:Messages", &(a->MultiXTpm__ConfigData::Messages), "MultiXTpm:ArrayOfMessage"))
				{	soap_flag_Messages1--;
					continue;
				}
			if (soap_flag_UsersPermissions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMultiXTpm__ArrayOfUserPermission(soap, "MultiXTpm:UsersPermissions", &(a->MultiXTpm__ConfigData::UsersPermissions), "MultiXTpm:ArrayOfUserPermission"))
				{	soap_flag_UsersPermissions1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (MultiXTpm__ConfigData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MultiXTpm__ConfigData, 0, sizeof(MultiXTpm__ConfigData), 0, soap_copy_MultiXTpm__ConfigData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LastUpdate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 MultiXTpm__ConfigData * SOAP_FMAC6 soap_new_MultiXTpm__ConfigData(struct soap *soap, int n)
{	return soap_instantiate_MultiXTpm__ConfigData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_MultiXTpm__ConfigData(struct soap *soap, MultiXTpm__ConfigData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 MultiXTpm__ConfigData * SOAP_FMAC4 soap_instantiate_MultiXTpm__ConfigData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_MultiXTpm__ConfigData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_MultiXTpm__ConfigData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new MultiXTpm__ConfigData;
		if (size)
			*size = sizeof(MultiXTpm__ConfigData);
		((MultiXTpm__ConfigData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new MultiXTpm__ConfigData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(MultiXTpm__ConfigData);
		for (int i = 0; i < n; i++)
			((MultiXTpm__ConfigData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (MultiXTpm__ConfigData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_MultiXTpm__ConfigData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying MultiXTpm__ConfigData %p -> %p\n", q, p));
	*(MultiXTpm__ConfigData*)p = *(MultiXTpm__ConfigData*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__ResumeAll(struct soap *soap, struct __MultiXTpm12__ResumeAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ResumeAll = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__ResumeAll(struct soap *soap, const struct __MultiXTpm12__ResumeAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ResumeAll(soap, &a->MultiXTpm__ResumeAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__ResumeAll(struct soap *soap, const struct __MultiXTpm12__ResumeAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__ResumeAll(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__ResumeAll(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__ResumeAll *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ResumeAll(soap, "MultiXTpm:ResumeAll", -1, &a->MultiXTpm__ResumeAll, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__ResumeAll * SOAP_FMAC4 soap_get___MultiXTpm12__ResumeAll(struct soap *soap, struct __MultiXTpm12__ResumeAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__ResumeAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__ResumeAll * SOAP_FMAC4 soap_in___MultiXTpm12__ResumeAll(struct soap *soap, const char *tag, struct __MultiXTpm12__ResumeAll *a, const char *type)
{
	short soap_flag_MultiXTpm__ResumeAll = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__ResumeAll *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__ResumeAll, sizeof(struct __MultiXTpm12__ResumeAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__ResumeAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ResumeAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ResumeAll(soap, "MultiXTpm:ResumeAll", &a->MultiXTpm__ResumeAll, ""))
				{	soap_flag_MultiXTpm__ResumeAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__ResumeAll * SOAP_FMAC6 soap_new___MultiXTpm12__ResumeAll(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__ResumeAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__ResumeAll(struct soap *soap, struct __MultiXTpm12__ResumeAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__ResumeAll * SOAP_FMAC4 soap_instantiate___MultiXTpm12__ResumeAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__ResumeAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__ResumeAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__ResumeAll;
		if (size)
			*size = sizeof(struct __MultiXTpm12__ResumeAll);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__ResumeAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__ResumeAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__ResumeAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__ResumeAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__ResumeAll %p -> %p\n", q, p));
	*(struct __MultiXTpm12__ResumeAll*)p = *(struct __MultiXTpm12__ResumeAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__SuspendAll(struct soap *soap, struct __MultiXTpm12__SuspendAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__SuspendAll = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__SuspendAll(struct soap *soap, const struct __MultiXTpm12__SuspendAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__SuspendAll(soap, &a->MultiXTpm__SuspendAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__SuspendAll(struct soap *soap, const struct __MultiXTpm12__SuspendAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__SuspendAll(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__SuspendAll(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__SuspendAll *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__SuspendAll(soap, "MultiXTpm:SuspendAll", -1, &a->MultiXTpm__SuspendAll, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__SuspendAll * SOAP_FMAC4 soap_get___MultiXTpm12__SuspendAll(struct soap *soap, struct __MultiXTpm12__SuspendAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__SuspendAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__SuspendAll * SOAP_FMAC4 soap_in___MultiXTpm12__SuspendAll(struct soap *soap, const char *tag, struct __MultiXTpm12__SuspendAll *a, const char *type)
{
	short soap_flag_MultiXTpm__SuspendAll = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__SuspendAll *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__SuspendAll, sizeof(struct __MultiXTpm12__SuspendAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__SuspendAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__SuspendAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__SuspendAll(soap, "MultiXTpm:SuspendAll", &a->MultiXTpm__SuspendAll, ""))
				{	soap_flag_MultiXTpm__SuspendAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__SuspendAll * SOAP_FMAC6 soap_new___MultiXTpm12__SuspendAll(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__SuspendAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__SuspendAll(struct soap *soap, struct __MultiXTpm12__SuspendAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__SuspendAll * SOAP_FMAC4 soap_instantiate___MultiXTpm12__SuspendAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__SuspendAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__SuspendAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__SuspendAll;
		if (size)
			*size = sizeof(struct __MultiXTpm12__SuspendAll);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__SuspendAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__SuspendAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__SuspendAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__SuspendAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__SuspendAll %p -> %p\n", q, p));
	*(struct __MultiXTpm12__SuspendAll*)p = *(struct __MultiXTpm12__SuspendAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__ShutdownAll(struct soap *soap, struct __MultiXTpm12__ShutdownAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ShutdownAll = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__ShutdownAll(struct soap *soap, const struct __MultiXTpm12__ShutdownAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ShutdownAll(soap, &a->MultiXTpm__ShutdownAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__ShutdownAll(struct soap *soap, const struct __MultiXTpm12__ShutdownAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__ShutdownAll(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__ShutdownAll(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__ShutdownAll *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ShutdownAll(soap, "MultiXTpm:ShutdownAll", -1, &a->MultiXTpm__ShutdownAll, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__ShutdownAll * SOAP_FMAC4 soap_get___MultiXTpm12__ShutdownAll(struct soap *soap, struct __MultiXTpm12__ShutdownAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__ShutdownAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__ShutdownAll * SOAP_FMAC4 soap_in___MultiXTpm12__ShutdownAll(struct soap *soap, const char *tag, struct __MultiXTpm12__ShutdownAll *a, const char *type)
{
	short soap_flag_MultiXTpm__ShutdownAll = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__ShutdownAll *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__ShutdownAll, sizeof(struct __MultiXTpm12__ShutdownAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__ShutdownAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ShutdownAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ShutdownAll(soap, "MultiXTpm:ShutdownAll", &a->MultiXTpm__ShutdownAll, ""))
				{	soap_flag_MultiXTpm__ShutdownAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__ShutdownAll * SOAP_FMAC6 soap_new___MultiXTpm12__ShutdownAll(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__ShutdownAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__ShutdownAll(struct soap *soap, struct __MultiXTpm12__ShutdownAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__ShutdownAll * SOAP_FMAC4 soap_instantiate___MultiXTpm12__ShutdownAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__ShutdownAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__ShutdownAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__ShutdownAll;
		if (size)
			*size = sizeof(struct __MultiXTpm12__ShutdownAll);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__ShutdownAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__ShutdownAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__ShutdownAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__ShutdownAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__ShutdownAll %p -> %p\n", q, p));
	*(struct __MultiXTpm12__ShutdownAll*)p = *(struct __MultiXTpm12__ShutdownAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__StartAll(struct soap *soap, struct __MultiXTpm12__StartAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__StartAll = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__StartAll(struct soap *soap, const struct __MultiXTpm12__StartAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__StartAll(soap, &a->MultiXTpm__StartAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__StartAll(struct soap *soap, const struct __MultiXTpm12__StartAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__StartAll(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__StartAll(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__StartAll *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__StartAll(soap, "MultiXTpm:StartAll", -1, &a->MultiXTpm__StartAll, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__StartAll * SOAP_FMAC4 soap_get___MultiXTpm12__StartAll(struct soap *soap, struct __MultiXTpm12__StartAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__StartAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__StartAll * SOAP_FMAC4 soap_in___MultiXTpm12__StartAll(struct soap *soap, const char *tag, struct __MultiXTpm12__StartAll *a, const char *type)
{
	short soap_flag_MultiXTpm__StartAll = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__StartAll *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__StartAll, sizeof(struct __MultiXTpm12__StartAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__StartAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__StartAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__StartAll(soap, "MultiXTpm:StartAll", &a->MultiXTpm__StartAll, ""))
				{	soap_flag_MultiXTpm__StartAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__StartAll * SOAP_FMAC6 soap_new___MultiXTpm12__StartAll(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__StartAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__StartAll(struct soap *soap, struct __MultiXTpm12__StartAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__StartAll * SOAP_FMAC4 soap_instantiate___MultiXTpm12__StartAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__StartAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__StartAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__StartAll;
		if (size)
			*size = sizeof(struct __MultiXTpm12__StartAll);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__StartAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__StartAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__StartAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__StartAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__StartAll %p -> %p\n", q, p));
	*(struct __MultiXTpm12__StartAll*)p = *(struct __MultiXTpm12__StartAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__RestartAll(struct soap *soap, struct __MultiXTpm12__RestartAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__RestartAll = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__RestartAll(struct soap *soap, const struct __MultiXTpm12__RestartAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__RestartAll(soap, &a->MultiXTpm__RestartAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__RestartAll(struct soap *soap, const struct __MultiXTpm12__RestartAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__RestartAll(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__RestartAll(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__RestartAll *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__RestartAll(soap, "MultiXTpm:RestartAll", -1, &a->MultiXTpm__RestartAll, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__RestartAll * SOAP_FMAC4 soap_get___MultiXTpm12__RestartAll(struct soap *soap, struct __MultiXTpm12__RestartAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__RestartAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__RestartAll * SOAP_FMAC4 soap_in___MultiXTpm12__RestartAll(struct soap *soap, const char *tag, struct __MultiXTpm12__RestartAll *a, const char *type)
{
	short soap_flag_MultiXTpm__RestartAll = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__RestartAll *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__RestartAll, sizeof(struct __MultiXTpm12__RestartAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__RestartAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__RestartAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__RestartAll(soap, "MultiXTpm:RestartAll", &a->MultiXTpm__RestartAll, ""))
				{	soap_flag_MultiXTpm__RestartAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__RestartAll * SOAP_FMAC6 soap_new___MultiXTpm12__RestartAll(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__RestartAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__RestartAll(struct soap *soap, struct __MultiXTpm12__RestartAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__RestartAll * SOAP_FMAC4 soap_instantiate___MultiXTpm12__RestartAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__RestartAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__RestartAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__RestartAll;
		if (size)
			*size = sizeof(struct __MultiXTpm12__RestartAll);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__RestartAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__RestartAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__RestartAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__RestartAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__RestartAll %p -> %p\n", q, p));
	*(struct __MultiXTpm12__RestartAll*)p = *(struct __MultiXTpm12__RestartAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__ResumeProcess(struct soap *soap, struct __MultiXTpm12__ResumeProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ResumeProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__ResumeProcess(struct soap *soap, const struct __MultiXTpm12__ResumeProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ResumeProcess(soap, &a->MultiXTpm__ResumeProcess);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__ResumeProcess(struct soap *soap, const struct __MultiXTpm12__ResumeProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__ResumeProcess(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__ResumeProcess(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__ResumeProcess *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ResumeProcess(soap, "MultiXTpm:ResumeProcess", -1, &a->MultiXTpm__ResumeProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__ResumeProcess * SOAP_FMAC4 soap_get___MultiXTpm12__ResumeProcess(struct soap *soap, struct __MultiXTpm12__ResumeProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__ResumeProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__ResumeProcess * SOAP_FMAC4 soap_in___MultiXTpm12__ResumeProcess(struct soap *soap, const char *tag, struct __MultiXTpm12__ResumeProcess *a, const char *type)
{
	short soap_flag_MultiXTpm__ResumeProcess = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__ResumeProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__ResumeProcess, sizeof(struct __MultiXTpm12__ResumeProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__ResumeProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ResumeProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ResumeProcess(soap, "MultiXTpm:ResumeProcess", &a->MultiXTpm__ResumeProcess, ""))
				{	soap_flag_MultiXTpm__ResumeProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__ResumeProcess * SOAP_FMAC6 soap_new___MultiXTpm12__ResumeProcess(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__ResumeProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__ResumeProcess(struct soap *soap, struct __MultiXTpm12__ResumeProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__ResumeProcess * SOAP_FMAC4 soap_instantiate___MultiXTpm12__ResumeProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__ResumeProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__ResumeProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__ResumeProcess;
		if (size)
			*size = sizeof(struct __MultiXTpm12__ResumeProcess);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__ResumeProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__ResumeProcess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__ResumeProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__ResumeProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__ResumeProcess %p -> %p\n", q, p));
	*(struct __MultiXTpm12__ResumeProcess*)p = *(struct __MultiXTpm12__ResumeProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__ResumeGroup(struct soap *soap, struct __MultiXTpm12__ResumeGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ResumeGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__ResumeGroup(struct soap *soap, const struct __MultiXTpm12__ResumeGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ResumeGroup(soap, &a->MultiXTpm__ResumeGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__ResumeGroup(struct soap *soap, const struct __MultiXTpm12__ResumeGroup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__ResumeGroup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__ResumeGroup(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__ResumeGroup *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ResumeGroup(soap, "MultiXTpm:ResumeGroup", -1, &a->MultiXTpm__ResumeGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__ResumeGroup * SOAP_FMAC4 soap_get___MultiXTpm12__ResumeGroup(struct soap *soap, struct __MultiXTpm12__ResumeGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__ResumeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__ResumeGroup * SOAP_FMAC4 soap_in___MultiXTpm12__ResumeGroup(struct soap *soap, const char *tag, struct __MultiXTpm12__ResumeGroup *a, const char *type)
{
	short soap_flag_MultiXTpm__ResumeGroup = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__ResumeGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__ResumeGroup, sizeof(struct __MultiXTpm12__ResumeGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__ResumeGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ResumeGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ResumeGroup(soap, "MultiXTpm:ResumeGroup", &a->MultiXTpm__ResumeGroup, ""))
				{	soap_flag_MultiXTpm__ResumeGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__ResumeGroup * SOAP_FMAC6 soap_new___MultiXTpm12__ResumeGroup(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__ResumeGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__ResumeGroup(struct soap *soap, struct __MultiXTpm12__ResumeGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__ResumeGroup * SOAP_FMAC4 soap_instantiate___MultiXTpm12__ResumeGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__ResumeGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__ResumeGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__ResumeGroup;
		if (size)
			*size = sizeof(struct __MultiXTpm12__ResumeGroup);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__ResumeGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__ResumeGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__ResumeGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__ResumeGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__ResumeGroup %p -> %p\n", q, p));
	*(struct __MultiXTpm12__ResumeGroup*)p = *(struct __MultiXTpm12__ResumeGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__SuspendProcess(struct soap *soap, struct __MultiXTpm12__SuspendProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__SuspendProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__SuspendProcess(struct soap *soap, const struct __MultiXTpm12__SuspendProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__SuspendProcess(soap, &a->MultiXTpm__SuspendProcess);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__SuspendProcess(struct soap *soap, const struct __MultiXTpm12__SuspendProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__SuspendProcess(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__SuspendProcess(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__SuspendProcess *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__SuspendProcess(soap, "MultiXTpm:SuspendProcess", -1, &a->MultiXTpm__SuspendProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__SuspendProcess * SOAP_FMAC4 soap_get___MultiXTpm12__SuspendProcess(struct soap *soap, struct __MultiXTpm12__SuspendProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__SuspendProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__SuspendProcess * SOAP_FMAC4 soap_in___MultiXTpm12__SuspendProcess(struct soap *soap, const char *tag, struct __MultiXTpm12__SuspendProcess *a, const char *type)
{
	short soap_flag_MultiXTpm__SuspendProcess = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__SuspendProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__SuspendProcess, sizeof(struct __MultiXTpm12__SuspendProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__SuspendProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__SuspendProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__SuspendProcess(soap, "MultiXTpm:SuspendProcess", &a->MultiXTpm__SuspendProcess, ""))
				{	soap_flag_MultiXTpm__SuspendProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__SuspendProcess * SOAP_FMAC6 soap_new___MultiXTpm12__SuspendProcess(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__SuspendProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__SuspendProcess(struct soap *soap, struct __MultiXTpm12__SuspendProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__SuspendProcess * SOAP_FMAC4 soap_instantiate___MultiXTpm12__SuspendProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__SuspendProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__SuspendProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__SuspendProcess;
		if (size)
			*size = sizeof(struct __MultiXTpm12__SuspendProcess);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__SuspendProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__SuspendProcess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__SuspendProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__SuspendProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__SuspendProcess %p -> %p\n", q, p));
	*(struct __MultiXTpm12__SuspendProcess*)p = *(struct __MultiXTpm12__SuspendProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__SuspendGroup(struct soap *soap, struct __MultiXTpm12__SuspendGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__SuspendGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__SuspendGroup(struct soap *soap, const struct __MultiXTpm12__SuspendGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__SuspendGroup(soap, &a->MultiXTpm__SuspendGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__SuspendGroup(struct soap *soap, const struct __MultiXTpm12__SuspendGroup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__SuspendGroup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__SuspendGroup(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__SuspendGroup *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__SuspendGroup(soap, "MultiXTpm:SuspendGroup", -1, &a->MultiXTpm__SuspendGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__SuspendGroup * SOAP_FMAC4 soap_get___MultiXTpm12__SuspendGroup(struct soap *soap, struct __MultiXTpm12__SuspendGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__SuspendGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__SuspendGroup * SOAP_FMAC4 soap_in___MultiXTpm12__SuspendGroup(struct soap *soap, const char *tag, struct __MultiXTpm12__SuspendGroup *a, const char *type)
{
	short soap_flag_MultiXTpm__SuspendGroup = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__SuspendGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__SuspendGroup, sizeof(struct __MultiXTpm12__SuspendGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__SuspendGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__SuspendGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__SuspendGroup(soap, "MultiXTpm:SuspendGroup", &a->MultiXTpm__SuspendGroup, ""))
				{	soap_flag_MultiXTpm__SuspendGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__SuspendGroup * SOAP_FMAC6 soap_new___MultiXTpm12__SuspendGroup(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__SuspendGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__SuspendGroup(struct soap *soap, struct __MultiXTpm12__SuspendGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__SuspendGroup * SOAP_FMAC4 soap_instantiate___MultiXTpm12__SuspendGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__SuspendGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__SuspendGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__SuspendGroup;
		if (size)
			*size = sizeof(struct __MultiXTpm12__SuspendGroup);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__SuspendGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__SuspendGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__SuspendGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__SuspendGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__SuspendGroup %p -> %p\n", q, p));
	*(struct __MultiXTpm12__SuspendGroup*)p = *(struct __MultiXTpm12__SuspendGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__ShutdownGroup(struct soap *soap, struct __MultiXTpm12__ShutdownGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ShutdownGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__ShutdownGroup(struct soap *soap, const struct __MultiXTpm12__ShutdownGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ShutdownGroup(soap, &a->MultiXTpm__ShutdownGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__ShutdownGroup(struct soap *soap, const struct __MultiXTpm12__ShutdownGroup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__ShutdownGroup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__ShutdownGroup(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__ShutdownGroup *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ShutdownGroup(soap, "MultiXTpm:ShutdownGroup", -1, &a->MultiXTpm__ShutdownGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__ShutdownGroup * SOAP_FMAC4 soap_get___MultiXTpm12__ShutdownGroup(struct soap *soap, struct __MultiXTpm12__ShutdownGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__ShutdownGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__ShutdownGroup * SOAP_FMAC4 soap_in___MultiXTpm12__ShutdownGroup(struct soap *soap, const char *tag, struct __MultiXTpm12__ShutdownGroup *a, const char *type)
{
	short soap_flag_MultiXTpm__ShutdownGroup = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__ShutdownGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__ShutdownGroup, sizeof(struct __MultiXTpm12__ShutdownGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__ShutdownGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ShutdownGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ShutdownGroup(soap, "MultiXTpm:ShutdownGroup", &a->MultiXTpm__ShutdownGroup, ""))
				{	soap_flag_MultiXTpm__ShutdownGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__ShutdownGroup * SOAP_FMAC6 soap_new___MultiXTpm12__ShutdownGroup(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__ShutdownGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__ShutdownGroup(struct soap *soap, struct __MultiXTpm12__ShutdownGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__ShutdownGroup * SOAP_FMAC4 soap_instantiate___MultiXTpm12__ShutdownGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__ShutdownGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__ShutdownGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__ShutdownGroup;
		if (size)
			*size = sizeof(struct __MultiXTpm12__ShutdownGroup);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__ShutdownGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__ShutdownGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__ShutdownGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__ShutdownGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__ShutdownGroup %p -> %p\n", q, p));
	*(struct __MultiXTpm12__ShutdownGroup*)p = *(struct __MultiXTpm12__ShutdownGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__ShutdownProcess(struct soap *soap, struct __MultiXTpm12__ShutdownProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ShutdownProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__ShutdownProcess(struct soap *soap, const struct __MultiXTpm12__ShutdownProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ShutdownProcess(soap, &a->MultiXTpm__ShutdownProcess);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__ShutdownProcess(struct soap *soap, const struct __MultiXTpm12__ShutdownProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__ShutdownProcess(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__ShutdownProcess(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__ShutdownProcess *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ShutdownProcess(soap, "MultiXTpm:ShutdownProcess", -1, &a->MultiXTpm__ShutdownProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__ShutdownProcess * SOAP_FMAC4 soap_get___MultiXTpm12__ShutdownProcess(struct soap *soap, struct __MultiXTpm12__ShutdownProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__ShutdownProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__ShutdownProcess * SOAP_FMAC4 soap_in___MultiXTpm12__ShutdownProcess(struct soap *soap, const char *tag, struct __MultiXTpm12__ShutdownProcess *a, const char *type)
{
	short soap_flag_MultiXTpm__ShutdownProcess = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__ShutdownProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__ShutdownProcess, sizeof(struct __MultiXTpm12__ShutdownProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__ShutdownProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ShutdownProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ShutdownProcess(soap, "MultiXTpm:ShutdownProcess", &a->MultiXTpm__ShutdownProcess, ""))
				{	soap_flag_MultiXTpm__ShutdownProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__ShutdownProcess * SOAP_FMAC6 soap_new___MultiXTpm12__ShutdownProcess(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__ShutdownProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__ShutdownProcess(struct soap *soap, struct __MultiXTpm12__ShutdownProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__ShutdownProcess * SOAP_FMAC4 soap_instantiate___MultiXTpm12__ShutdownProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__ShutdownProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__ShutdownProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__ShutdownProcess;
		if (size)
			*size = sizeof(struct __MultiXTpm12__ShutdownProcess);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__ShutdownProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__ShutdownProcess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__ShutdownProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__ShutdownProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__ShutdownProcess %p -> %p\n", q, p));
	*(struct __MultiXTpm12__ShutdownProcess*)p = *(struct __MultiXTpm12__ShutdownProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__StartGroup(struct soap *soap, struct __MultiXTpm12__StartGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__StartGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__StartGroup(struct soap *soap, const struct __MultiXTpm12__StartGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__StartGroup(soap, &a->MultiXTpm__StartGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__StartGroup(struct soap *soap, const struct __MultiXTpm12__StartGroup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__StartGroup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__StartGroup(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__StartGroup *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__StartGroup(soap, "MultiXTpm:StartGroup", -1, &a->MultiXTpm__StartGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__StartGroup * SOAP_FMAC4 soap_get___MultiXTpm12__StartGroup(struct soap *soap, struct __MultiXTpm12__StartGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__StartGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__StartGroup * SOAP_FMAC4 soap_in___MultiXTpm12__StartGroup(struct soap *soap, const char *tag, struct __MultiXTpm12__StartGroup *a, const char *type)
{
	short soap_flag_MultiXTpm__StartGroup = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__StartGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__StartGroup, sizeof(struct __MultiXTpm12__StartGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__StartGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__StartGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__StartGroup(soap, "MultiXTpm:StartGroup", &a->MultiXTpm__StartGroup, ""))
				{	soap_flag_MultiXTpm__StartGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__StartGroup * SOAP_FMAC6 soap_new___MultiXTpm12__StartGroup(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__StartGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__StartGroup(struct soap *soap, struct __MultiXTpm12__StartGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__StartGroup * SOAP_FMAC4 soap_instantiate___MultiXTpm12__StartGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__StartGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__StartGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__StartGroup;
		if (size)
			*size = sizeof(struct __MultiXTpm12__StartGroup);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__StartGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__StartGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__StartGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__StartGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__StartGroup %p -> %p\n", q, p));
	*(struct __MultiXTpm12__StartGroup*)p = *(struct __MultiXTpm12__StartGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__StartProcess(struct soap *soap, struct __MultiXTpm12__StartProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__StartProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__StartProcess(struct soap *soap, const struct __MultiXTpm12__StartProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__StartProcess(soap, &a->MultiXTpm__StartProcess);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__StartProcess(struct soap *soap, const struct __MultiXTpm12__StartProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__StartProcess(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__StartProcess(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__StartProcess *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__StartProcess(soap, "MultiXTpm:StartProcess", -1, &a->MultiXTpm__StartProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__StartProcess * SOAP_FMAC4 soap_get___MultiXTpm12__StartProcess(struct soap *soap, struct __MultiXTpm12__StartProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__StartProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__StartProcess * SOAP_FMAC4 soap_in___MultiXTpm12__StartProcess(struct soap *soap, const char *tag, struct __MultiXTpm12__StartProcess *a, const char *type)
{
	short soap_flag_MultiXTpm__StartProcess = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__StartProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__StartProcess, sizeof(struct __MultiXTpm12__StartProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__StartProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__StartProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__StartProcess(soap, "MultiXTpm:StartProcess", &a->MultiXTpm__StartProcess, ""))
				{	soap_flag_MultiXTpm__StartProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__StartProcess * SOAP_FMAC6 soap_new___MultiXTpm12__StartProcess(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__StartProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__StartProcess(struct soap *soap, struct __MultiXTpm12__StartProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__StartProcess * SOAP_FMAC4 soap_instantiate___MultiXTpm12__StartProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__StartProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__StartProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__StartProcess;
		if (size)
			*size = sizeof(struct __MultiXTpm12__StartProcess);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__StartProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__StartProcess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__StartProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__StartProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__StartProcess %p -> %p\n", q, p));
	*(struct __MultiXTpm12__StartProcess*)p = *(struct __MultiXTpm12__StartProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__RestartGroup(struct soap *soap, struct __MultiXTpm12__RestartGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__RestartGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__RestartGroup(struct soap *soap, const struct __MultiXTpm12__RestartGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__RestartGroup(soap, &a->MultiXTpm__RestartGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__RestartGroup(struct soap *soap, const struct __MultiXTpm12__RestartGroup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__RestartGroup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__RestartGroup(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__RestartGroup *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__RestartGroup(soap, "MultiXTpm:RestartGroup", -1, &a->MultiXTpm__RestartGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__RestartGroup * SOAP_FMAC4 soap_get___MultiXTpm12__RestartGroup(struct soap *soap, struct __MultiXTpm12__RestartGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__RestartGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__RestartGroup * SOAP_FMAC4 soap_in___MultiXTpm12__RestartGroup(struct soap *soap, const char *tag, struct __MultiXTpm12__RestartGroup *a, const char *type)
{
	short soap_flag_MultiXTpm__RestartGroup = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__RestartGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__RestartGroup, sizeof(struct __MultiXTpm12__RestartGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__RestartGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__RestartGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__RestartGroup(soap, "MultiXTpm:RestartGroup", &a->MultiXTpm__RestartGroup, ""))
				{	soap_flag_MultiXTpm__RestartGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__RestartGroup * SOAP_FMAC6 soap_new___MultiXTpm12__RestartGroup(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__RestartGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__RestartGroup(struct soap *soap, struct __MultiXTpm12__RestartGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__RestartGroup * SOAP_FMAC4 soap_instantiate___MultiXTpm12__RestartGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__RestartGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__RestartGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__RestartGroup;
		if (size)
			*size = sizeof(struct __MultiXTpm12__RestartGroup);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__RestartGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__RestartGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__RestartGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__RestartGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__RestartGroup %p -> %p\n", q, p));
	*(struct __MultiXTpm12__RestartGroup*)p = *(struct __MultiXTpm12__RestartGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__RestartProcess(struct soap *soap, struct __MultiXTpm12__RestartProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__RestartProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__RestartProcess(struct soap *soap, const struct __MultiXTpm12__RestartProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__RestartProcess(soap, &a->MultiXTpm__RestartProcess);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__RestartProcess(struct soap *soap, const struct __MultiXTpm12__RestartProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__RestartProcess(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__RestartProcess(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__RestartProcess *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__RestartProcess(soap, "MultiXTpm:RestartProcess", -1, &a->MultiXTpm__RestartProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__RestartProcess * SOAP_FMAC4 soap_get___MultiXTpm12__RestartProcess(struct soap *soap, struct __MultiXTpm12__RestartProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__RestartProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__RestartProcess * SOAP_FMAC4 soap_in___MultiXTpm12__RestartProcess(struct soap *soap, const char *tag, struct __MultiXTpm12__RestartProcess *a, const char *type)
{
	short soap_flag_MultiXTpm__RestartProcess = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__RestartProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__RestartProcess, sizeof(struct __MultiXTpm12__RestartProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__RestartProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__RestartProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__RestartProcess(soap, "MultiXTpm:RestartProcess", &a->MultiXTpm__RestartProcess, ""))
				{	soap_flag_MultiXTpm__RestartProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__RestartProcess * SOAP_FMAC6 soap_new___MultiXTpm12__RestartProcess(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__RestartProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__RestartProcess(struct soap *soap, struct __MultiXTpm12__RestartProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__RestartProcess * SOAP_FMAC4 soap_instantiate___MultiXTpm12__RestartProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__RestartProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__RestartProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__RestartProcess;
		if (size)
			*size = sizeof(struct __MultiXTpm12__RestartProcess);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__RestartProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__RestartProcess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__RestartProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__RestartProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__RestartProcess %p -> %p\n", q, p));
	*(struct __MultiXTpm12__RestartProcess*)p = *(struct __MultiXTpm12__RestartProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__GetSystemStatus(struct soap *soap, struct __MultiXTpm12__GetSystemStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__GetSystemStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__GetSystemStatus(struct soap *soap, const struct __MultiXTpm12__GetSystemStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__GetSystemStatus(soap, &a->MultiXTpm__GetSystemStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__GetSystemStatus(struct soap *soap, const struct __MultiXTpm12__GetSystemStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__GetSystemStatus(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__GetSystemStatus(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__GetSystemStatus *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__GetSystemStatus(soap, "MultiXTpm:GetSystemStatus", -1, &a->MultiXTpm__GetSystemStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__GetSystemStatus * SOAP_FMAC4 soap_get___MultiXTpm12__GetSystemStatus(struct soap *soap, struct __MultiXTpm12__GetSystemStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__GetSystemStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__GetSystemStatus * SOAP_FMAC4 soap_in___MultiXTpm12__GetSystemStatus(struct soap *soap, const char *tag, struct __MultiXTpm12__GetSystemStatus *a, const char *type)
{
	short soap_flag_MultiXTpm__GetSystemStatus = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__GetSystemStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__GetSystemStatus, sizeof(struct __MultiXTpm12__GetSystemStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__GetSystemStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__GetSystemStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__GetSystemStatus(soap, "MultiXTpm:GetSystemStatus", &a->MultiXTpm__GetSystemStatus, ""))
				{	soap_flag_MultiXTpm__GetSystemStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__GetSystemStatus * SOAP_FMAC6 soap_new___MultiXTpm12__GetSystemStatus(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__GetSystemStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__GetSystemStatus(struct soap *soap, struct __MultiXTpm12__GetSystemStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__GetSystemStatus * SOAP_FMAC4 soap_instantiate___MultiXTpm12__GetSystemStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__GetSystemStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__GetSystemStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__GetSystemStatus;
		if (size)
			*size = sizeof(struct __MultiXTpm12__GetSystemStatus);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__GetSystemStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__GetSystemStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__GetSystemStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__GetSystemStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__GetSystemStatus %p -> %p\n", q, p));
	*(struct __MultiXTpm12__GetSystemStatus*)p = *(struct __MultiXTpm12__GetSystemStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__UpdateConfig(struct soap *soap, struct __MultiXTpm12__UpdateConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__UpdateConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__UpdateConfig(struct soap *soap, const struct __MultiXTpm12__UpdateConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__UpdateConfig(soap, &a->MultiXTpm__UpdateConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__UpdateConfig(struct soap *soap, const struct __MultiXTpm12__UpdateConfig *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__UpdateConfig(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__UpdateConfig(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__UpdateConfig *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__UpdateConfig(soap, "MultiXTpm:UpdateConfig", -1, &a->MultiXTpm__UpdateConfig, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__UpdateConfig * SOAP_FMAC4 soap_get___MultiXTpm12__UpdateConfig(struct soap *soap, struct __MultiXTpm12__UpdateConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__UpdateConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__UpdateConfig * SOAP_FMAC4 soap_in___MultiXTpm12__UpdateConfig(struct soap *soap, const char *tag, struct __MultiXTpm12__UpdateConfig *a, const char *type)
{
	short soap_flag_MultiXTpm__UpdateConfig = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__UpdateConfig *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__UpdateConfig, sizeof(struct __MultiXTpm12__UpdateConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__UpdateConfig(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__UpdateConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__UpdateConfig(soap, "MultiXTpm:UpdateConfig", &a->MultiXTpm__UpdateConfig, ""))
				{	soap_flag_MultiXTpm__UpdateConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__UpdateConfig * SOAP_FMAC6 soap_new___MultiXTpm12__UpdateConfig(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__UpdateConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__UpdateConfig(struct soap *soap, struct __MultiXTpm12__UpdateConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__UpdateConfig * SOAP_FMAC4 soap_instantiate___MultiXTpm12__UpdateConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__UpdateConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__UpdateConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__UpdateConfig;
		if (size)
			*size = sizeof(struct __MultiXTpm12__UpdateConfig);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__UpdateConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__UpdateConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__UpdateConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__UpdateConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__UpdateConfig %p -> %p\n", q, p));
	*(struct __MultiXTpm12__UpdateConfig*)p = *(struct __MultiXTpm12__UpdateConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm12__GetConfig(struct soap *soap, struct __MultiXTpm12__GetConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__GetConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm12__GetConfig(struct soap *soap, const struct __MultiXTpm12__GetConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__GetConfig(soap, &a->MultiXTpm__GetConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm12__GetConfig(struct soap *soap, const struct __MultiXTpm12__GetConfig *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm12__GetConfig(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm12__GetConfig(struct soap *soap, const char *tag, int id, const struct __MultiXTpm12__GetConfig *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__GetConfig(soap, "MultiXTpm:GetConfig", -1, &a->MultiXTpm__GetConfig, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm12__GetConfig * SOAP_FMAC4 soap_get___MultiXTpm12__GetConfig(struct soap *soap, struct __MultiXTpm12__GetConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm12__GetConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm12__GetConfig * SOAP_FMAC4 soap_in___MultiXTpm12__GetConfig(struct soap *soap, const char *tag, struct __MultiXTpm12__GetConfig *a, const char *type)
{
	short soap_flag_MultiXTpm__GetConfig = 1;
	short soap_flag;
	a = (struct __MultiXTpm12__GetConfig *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm12__GetConfig, sizeof(struct __MultiXTpm12__GetConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm12__GetConfig(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__GetConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__GetConfig(soap, "MultiXTpm:GetConfig", &a->MultiXTpm__GetConfig, ""))
				{	soap_flag_MultiXTpm__GetConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm12__GetConfig * SOAP_FMAC6 soap_new___MultiXTpm12__GetConfig(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm12__GetConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm12__GetConfig(struct soap *soap, struct __MultiXTpm12__GetConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm12__GetConfig * SOAP_FMAC4 soap_instantiate___MultiXTpm12__GetConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm12__GetConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm12__GetConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm12__GetConfig;
		if (size)
			*size = sizeof(struct __MultiXTpm12__GetConfig);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm12__GetConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm12__GetConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm12__GetConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm12__GetConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm12__GetConfig %p -> %p\n", q, p));
	*(struct __MultiXTpm12__GetConfig*)p = *(struct __MultiXTpm12__GetConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__ResumeAll(struct soap *soap, struct __MultiXTpm11__ResumeAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ResumeAll = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__ResumeAll(struct soap *soap, const struct __MultiXTpm11__ResumeAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ResumeAll(soap, &a->MultiXTpm__ResumeAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__ResumeAll(struct soap *soap, const struct __MultiXTpm11__ResumeAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__ResumeAll(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__ResumeAll(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__ResumeAll *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ResumeAll(soap, "MultiXTpm:ResumeAll", -1, &a->MultiXTpm__ResumeAll, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__ResumeAll * SOAP_FMAC4 soap_get___MultiXTpm11__ResumeAll(struct soap *soap, struct __MultiXTpm11__ResumeAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__ResumeAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__ResumeAll * SOAP_FMAC4 soap_in___MultiXTpm11__ResumeAll(struct soap *soap, const char *tag, struct __MultiXTpm11__ResumeAll *a, const char *type)
{
	short soap_flag_MultiXTpm__ResumeAll = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__ResumeAll *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__ResumeAll, sizeof(struct __MultiXTpm11__ResumeAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__ResumeAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ResumeAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ResumeAll(soap, "MultiXTpm:ResumeAll", &a->MultiXTpm__ResumeAll, ""))
				{	soap_flag_MultiXTpm__ResumeAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__ResumeAll * SOAP_FMAC6 soap_new___MultiXTpm11__ResumeAll(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__ResumeAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__ResumeAll(struct soap *soap, struct __MultiXTpm11__ResumeAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__ResumeAll * SOAP_FMAC4 soap_instantiate___MultiXTpm11__ResumeAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__ResumeAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__ResumeAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__ResumeAll;
		if (size)
			*size = sizeof(struct __MultiXTpm11__ResumeAll);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__ResumeAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__ResumeAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__ResumeAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__ResumeAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__ResumeAll %p -> %p\n", q, p));
	*(struct __MultiXTpm11__ResumeAll*)p = *(struct __MultiXTpm11__ResumeAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__SuspendAll(struct soap *soap, struct __MultiXTpm11__SuspendAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__SuspendAll = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__SuspendAll(struct soap *soap, const struct __MultiXTpm11__SuspendAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__SuspendAll(soap, &a->MultiXTpm__SuspendAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__SuspendAll(struct soap *soap, const struct __MultiXTpm11__SuspendAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__SuspendAll(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__SuspendAll(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__SuspendAll *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__SuspendAll(soap, "MultiXTpm:SuspendAll", -1, &a->MultiXTpm__SuspendAll, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__SuspendAll * SOAP_FMAC4 soap_get___MultiXTpm11__SuspendAll(struct soap *soap, struct __MultiXTpm11__SuspendAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__SuspendAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__SuspendAll * SOAP_FMAC4 soap_in___MultiXTpm11__SuspendAll(struct soap *soap, const char *tag, struct __MultiXTpm11__SuspendAll *a, const char *type)
{
	short soap_flag_MultiXTpm__SuspendAll = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__SuspendAll *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__SuspendAll, sizeof(struct __MultiXTpm11__SuspendAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__SuspendAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__SuspendAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__SuspendAll(soap, "MultiXTpm:SuspendAll", &a->MultiXTpm__SuspendAll, ""))
				{	soap_flag_MultiXTpm__SuspendAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__SuspendAll * SOAP_FMAC6 soap_new___MultiXTpm11__SuspendAll(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__SuspendAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__SuspendAll(struct soap *soap, struct __MultiXTpm11__SuspendAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__SuspendAll * SOAP_FMAC4 soap_instantiate___MultiXTpm11__SuspendAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__SuspendAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__SuspendAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__SuspendAll;
		if (size)
			*size = sizeof(struct __MultiXTpm11__SuspendAll);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__SuspendAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__SuspendAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__SuspendAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__SuspendAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__SuspendAll %p -> %p\n", q, p));
	*(struct __MultiXTpm11__SuspendAll*)p = *(struct __MultiXTpm11__SuspendAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__ShutdownAll(struct soap *soap, struct __MultiXTpm11__ShutdownAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ShutdownAll = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__ShutdownAll(struct soap *soap, const struct __MultiXTpm11__ShutdownAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ShutdownAll(soap, &a->MultiXTpm__ShutdownAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__ShutdownAll(struct soap *soap, const struct __MultiXTpm11__ShutdownAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__ShutdownAll(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__ShutdownAll(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__ShutdownAll *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ShutdownAll(soap, "MultiXTpm:ShutdownAll", -1, &a->MultiXTpm__ShutdownAll, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__ShutdownAll * SOAP_FMAC4 soap_get___MultiXTpm11__ShutdownAll(struct soap *soap, struct __MultiXTpm11__ShutdownAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__ShutdownAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__ShutdownAll * SOAP_FMAC4 soap_in___MultiXTpm11__ShutdownAll(struct soap *soap, const char *tag, struct __MultiXTpm11__ShutdownAll *a, const char *type)
{
	short soap_flag_MultiXTpm__ShutdownAll = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__ShutdownAll *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__ShutdownAll, sizeof(struct __MultiXTpm11__ShutdownAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__ShutdownAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ShutdownAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ShutdownAll(soap, "MultiXTpm:ShutdownAll", &a->MultiXTpm__ShutdownAll, ""))
				{	soap_flag_MultiXTpm__ShutdownAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__ShutdownAll * SOAP_FMAC6 soap_new___MultiXTpm11__ShutdownAll(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__ShutdownAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__ShutdownAll(struct soap *soap, struct __MultiXTpm11__ShutdownAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__ShutdownAll * SOAP_FMAC4 soap_instantiate___MultiXTpm11__ShutdownAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__ShutdownAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__ShutdownAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__ShutdownAll;
		if (size)
			*size = sizeof(struct __MultiXTpm11__ShutdownAll);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__ShutdownAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__ShutdownAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__ShutdownAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__ShutdownAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__ShutdownAll %p -> %p\n", q, p));
	*(struct __MultiXTpm11__ShutdownAll*)p = *(struct __MultiXTpm11__ShutdownAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__StartAll(struct soap *soap, struct __MultiXTpm11__StartAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__StartAll = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__StartAll(struct soap *soap, const struct __MultiXTpm11__StartAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__StartAll(soap, &a->MultiXTpm__StartAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__StartAll(struct soap *soap, const struct __MultiXTpm11__StartAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__StartAll(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__StartAll(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__StartAll *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__StartAll(soap, "MultiXTpm:StartAll", -1, &a->MultiXTpm__StartAll, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__StartAll * SOAP_FMAC4 soap_get___MultiXTpm11__StartAll(struct soap *soap, struct __MultiXTpm11__StartAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__StartAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__StartAll * SOAP_FMAC4 soap_in___MultiXTpm11__StartAll(struct soap *soap, const char *tag, struct __MultiXTpm11__StartAll *a, const char *type)
{
	short soap_flag_MultiXTpm__StartAll = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__StartAll *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__StartAll, sizeof(struct __MultiXTpm11__StartAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__StartAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__StartAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__StartAll(soap, "MultiXTpm:StartAll", &a->MultiXTpm__StartAll, ""))
				{	soap_flag_MultiXTpm__StartAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__StartAll * SOAP_FMAC6 soap_new___MultiXTpm11__StartAll(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__StartAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__StartAll(struct soap *soap, struct __MultiXTpm11__StartAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__StartAll * SOAP_FMAC4 soap_instantiate___MultiXTpm11__StartAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__StartAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__StartAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__StartAll;
		if (size)
			*size = sizeof(struct __MultiXTpm11__StartAll);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__StartAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__StartAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__StartAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__StartAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__StartAll %p -> %p\n", q, p));
	*(struct __MultiXTpm11__StartAll*)p = *(struct __MultiXTpm11__StartAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__RestartAll(struct soap *soap, struct __MultiXTpm11__RestartAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__RestartAll = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__RestartAll(struct soap *soap, const struct __MultiXTpm11__RestartAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__RestartAll(soap, &a->MultiXTpm__RestartAll);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__RestartAll(struct soap *soap, const struct __MultiXTpm11__RestartAll *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__RestartAll(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__RestartAll(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__RestartAll *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__RestartAll(soap, "MultiXTpm:RestartAll", -1, &a->MultiXTpm__RestartAll, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__RestartAll * SOAP_FMAC4 soap_get___MultiXTpm11__RestartAll(struct soap *soap, struct __MultiXTpm11__RestartAll *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__RestartAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__RestartAll * SOAP_FMAC4 soap_in___MultiXTpm11__RestartAll(struct soap *soap, const char *tag, struct __MultiXTpm11__RestartAll *a, const char *type)
{
	short soap_flag_MultiXTpm__RestartAll = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__RestartAll *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__RestartAll, sizeof(struct __MultiXTpm11__RestartAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__RestartAll(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__RestartAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__RestartAll(soap, "MultiXTpm:RestartAll", &a->MultiXTpm__RestartAll, ""))
				{	soap_flag_MultiXTpm__RestartAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__RestartAll * SOAP_FMAC6 soap_new___MultiXTpm11__RestartAll(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__RestartAll(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__RestartAll(struct soap *soap, struct __MultiXTpm11__RestartAll *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__RestartAll * SOAP_FMAC4 soap_instantiate___MultiXTpm11__RestartAll(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__RestartAll(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__RestartAll, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__RestartAll;
		if (size)
			*size = sizeof(struct __MultiXTpm11__RestartAll);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__RestartAll[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__RestartAll);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__RestartAll*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__RestartAll(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__RestartAll %p -> %p\n", q, p));
	*(struct __MultiXTpm11__RestartAll*)p = *(struct __MultiXTpm11__RestartAll*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__ResumeProcess(struct soap *soap, struct __MultiXTpm11__ResumeProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ResumeProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__ResumeProcess(struct soap *soap, const struct __MultiXTpm11__ResumeProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ResumeProcess(soap, &a->MultiXTpm__ResumeProcess);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__ResumeProcess(struct soap *soap, const struct __MultiXTpm11__ResumeProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__ResumeProcess(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__ResumeProcess(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__ResumeProcess *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ResumeProcess(soap, "MultiXTpm:ResumeProcess", -1, &a->MultiXTpm__ResumeProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__ResumeProcess * SOAP_FMAC4 soap_get___MultiXTpm11__ResumeProcess(struct soap *soap, struct __MultiXTpm11__ResumeProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__ResumeProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__ResumeProcess * SOAP_FMAC4 soap_in___MultiXTpm11__ResumeProcess(struct soap *soap, const char *tag, struct __MultiXTpm11__ResumeProcess *a, const char *type)
{
	short soap_flag_MultiXTpm__ResumeProcess = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__ResumeProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__ResumeProcess, sizeof(struct __MultiXTpm11__ResumeProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__ResumeProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ResumeProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ResumeProcess(soap, "MultiXTpm:ResumeProcess", &a->MultiXTpm__ResumeProcess, ""))
				{	soap_flag_MultiXTpm__ResumeProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__ResumeProcess * SOAP_FMAC6 soap_new___MultiXTpm11__ResumeProcess(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__ResumeProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__ResumeProcess(struct soap *soap, struct __MultiXTpm11__ResumeProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__ResumeProcess * SOAP_FMAC4 soap_instantiate___MultiXTpm11__ResumeProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__ResumeProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__ResumeProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__ResumeProcess;
		if (size)
			*size = sizeof(struct __MultiXTpm11__ResumeProcess);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__ResumeProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__ResumeProcess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__ResumeProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__ResumeProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__ResumeProcess %p -> %p\n", q, p));
	*(struct __MultiXTpm11__ResumeProcess*)p = *(struct __MultiXTpm11__ResumeProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__ResumeGroup(struct soap *soap, struct __MultiXTpm11__ResumeGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ResumeGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__ResumeGroup(struct soap *soap, const struct __MultiXTpm11__ResumeGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ResumeGroup(soap, &a->MultiXTpm__ResumeGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__ResumeGroup(struct soap *soap, const struct __MultiXTpm11__ResumeGroup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__ResumeGroup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__ResumeGroup(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__ResumeGroup *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ResumeGroup(soap, "MultiXTpm:ResumeGroup", -1, &a->MultiXTpm__ResumeGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__ResumeGroup * SOAP_FMAC4 soap_get___MultiXTpm11__ResumeGroup(struct soap *soap, struct __MultiXTpm11__ResumeGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__ResumeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__ResumeGroup * SOAP_FMAC4 soap_in___MultiXTpm11__ResumeGroup(struct soap *soap, const char *tag, struct __MultiXTpm11__ResumeGroup *a, const char *type)
{
	short soap_flag_MultiXTpm__ResumeGroup = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__ResumeGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__ResumeGroup, sizeof(struct __MultiXTpm11__ResumeGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__ResumeGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ResumeGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ResumeGroup(soap, "MultiXTpm:ResumeGroup", &a->MultiXTpm__ResumeGroup, ""))
				{	soap_flag_MultiXTpm__ResumeGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__ResumeGroup * SOAP_FMAC6 soap_new___MultiXTpm11__ResumeGroup(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__ResumeGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__ResumeGroup(struct soap *soap, struct __MultiXTpm11__ResumeGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__ResumeGroup * SOAP_FMAC4 soap_instantiate___MultiXTpm11__ResumeGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__ResumeGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__ResumeGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__ResumeGroup;
		if (size)
			*size = sizeof(struct __MultiXTpm11__ResumeGroup);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__ResumeGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__ResumeGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__ResumeGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__ResumeGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__ResumeGroup %p -> %p\n", q, p));
	*(struct __MultiXTpm11__ResumeGroup*)p = *(struct __MultiXTpm11__ResumeGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__SuspendProcess(struct soap *soap, struct __MultiXTpm11__SuspendProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__SuspendProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__SuspendProcess(struct soap *soap, const struct __MultiXTpm11__SuspendProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__SuspendProcess(soap, &a->MultiXTpm__SuspendProcess);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__SuspendProcess(struct soap *soap, const struct __MultiXTpm11__SuspendProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__SuspendProcess(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__SuspendProcess(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__SuspendProcess *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__SuspendProcess(soap, "MultiXTpm:SuspendProcess", -1, &a->MultiXTpm__SuspendProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__SuspendProcess * SOAP_FMAC4 soap_get___MultiXTpm11__SuspendProcess(struct soap *soap, struct __MultiXTpm11__SuspendProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__SuspendProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__SuspendProcess * SOAP_FMAC4 soap_in___MultiXTpm11__SuspendProcess(struct soap *soap, const char *tag, struct __MultiXTpm11__SuspendProcess *a, const char *type)
{
	short soap_flag_MultiXTpm__SuspendProcess = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__SuspendProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__SuspendProcess, sizeof(struct __MultiXTpm11__SuspendProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__SuspendProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__SuspendProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__SuspendProcess(soap, "MultiXTpm:SuspendProcess", &a->MultiXTpm__SuspendProcess, ""))
				{	soap_flag_MultiXTpm__SuspendProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__SuspendProcess * SOAP_FMAC6 soap_new___MultiXTpm11__SuspendProcess(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__SuspendProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__SuspendProcess(struct soap *soap, struct __MultiXTpm11__SuspendProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__SuspendProcess * SOAP_FMAC4 soap_instantiate___MultiXTpm11__SuspendProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__SuspendProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__SuspendProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__SuspendProcess;
		if (size)
			*size = sizeof(struct __MultiXTpm11__SuspendProcess);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__SuspendProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__SuspendProcess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__SuspendProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__SuspendProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__SuspendProcess %p -> %p\n", q, p));
	*(struct __MultiXTpm11__SuspendProcess*)p = *(struct __MultiXTpm11__SuspendProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__SuspendGroup(struct soap *soap, struct __MultiXTpm11__SuspendGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__SuspendGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__SuspendGroup(struct soap *soap, const struct __MultiXTpm11__SuspendGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__SuspendGroup(soap, &a->MultiXTpm__SuspendGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__SuspendGroup(struct soap *soap, const struct __MultiXTpm11__SuspendGroup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__SuspendGroup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__SuspendGroup(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__SuspendGroup *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__SuspendGroup(soap, "MultiXTpm:SuspendGroup", -1, &a->MultiXTpm__SuspendGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__SuspendGroup * SOAP_FMAC4 soap_get___MultiXTpm11__SuspendGroup(struct soap *soap, struct __MultiXTpm11__SuspendGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__SuspendGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__SuspendGroup * SOAP_FMAC4 soap_in___MultiXTpm11__SuspendGroup(struct soap *soap, const char *tag, struct __MultiXTpm11__SuspendGroup *a, const char *type)
{
	short soap_flag_MultiXTpm__SuspendGroup = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__SuspendGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__SuspendGroup, sizeof(struct __MultiXTpm11__SuspendGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__SuspendGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__SuspendGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__SuspendGroup(soap, "MultiXTpm:SuspendGroup", &a->MultiXTpm__SuspendGroup, ""))
				{	soap_flag_MultiXTpm__SuspendGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__SuspendGroup * SOAP_FMAC6 soap_new___MultiXTpm11__SuspendGroup(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__SuspendGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__SuspendGroup(struct soap *soap, struct __MultiXTpm11__SuspendGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__SuspendGroup * SOAP_FMAC4 soap_instantiate___MultiXTpm11__SuspendGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__SuspendGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__SuspendGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__SuspendGroup;
		if (size)
			*size = sizeof(struct __MultiXTpm11__SuspendGroup);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__SuspendGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__SuspendGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__SuspendGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__SuspendGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__SuspendGroup %p -> %p\n", q, p));
	*(struct __MultiXTpm11__SuspendGroup*)p = *(struct __MultiXTpm11__SuspendGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__ShutdownGroup(struct soap *soap, struct __MultiXTpm11__ShutdownGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ShutdownGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__ShutdownGroup(struct soap *soap, const struct __MultiXTpm11__ShutdownGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ShutdownGroup(soap, &a->MultiXTpm__ShutdownGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__ShutdownGroup(struct soap *soap, const struct __MultiXTpm11__ShutdownGroup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__ShutdownGroup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__ShutdownGroup(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__ShutdownGroup *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ShutdownGroup(soap, "MultiXTpm:ShutdownGroup", -1, &a->MultiXTpm__ShutdownGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__ShutdownGroup * SOAP_FMAC4 soap_get___MultiXTpm11__ShutdownGroup(struct soap *soap, struct __MultiXTpm11__ShutdownGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__ShutdownGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__ShutdownGroup * SOAP_FMAC4 soap_in___MultiXTpm11__ShutdownGroup(struct soap *soap, const char *tag, struct __MultiXTpm11__ShutdownGroup *a, const char *type)
{
	short soap_flag_MultiXTpm__ShutdownGroup = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__ShutdownGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__ShutdownGroup, sizeof(struct __MultiXTpm11__ShutdownGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__ShutdownGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ShutdownGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ShutdownGroup(soap, "MultiXTpm:ShutdownGroup", &a->MultiXTpm__ShutdownGroup, ""))
				{	soap_flag_MultiXTpm__ShutdownGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__ShutdownGroup * SOAP_FMAC6 soap_new___MultiXTpm11__ShutdownGroup(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__ShutdownGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__ShutdownGroup(struct soap *soap, struct __MultiXTpm11__ShutdownGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__ShutdownGroup * SOAP_FMAC4 soap_instantiate___MultiXTpm11__ShutdownGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__ShutdownGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__ShutdownGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__ShutdownGroup;
		if (size)
			*size = sizeof(struct __MultiXTpm11__ShutdownGroup);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__ShutdownGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__ShutdownGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__ShutdownGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__ShutdownGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__ShutdownGroup %p -> %p\n", q, p));
	*(struct __MultiXTpm11__ShutdownGroup*)p = *(struct __MultiXTpm11__ShutdownGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__ShutdownProcess(struct soap *soap, struct __MultiXTpm11__ShutdownProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__ShutdownProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__ShutdownProcess(struct soap *soap, const struct __MultiXTpm11__ShutdownProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__ShutdownProcess(soap, &a->MultiXTpm__ShutdownProcess);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__ShutdownProcess(struct soap *soap, const struct __MultiXTpm11__ShutdownProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__ShutdownProcess(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__ShutdownProcess(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__ShutdownProcess *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__ShutdownProcess(soap, "MultiXTpm:ShutdownProcess", -1, &a->MultiXTpm__ShutdownProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__ShutdownProcess * SOAP_FMAC4 soap_get___MultiXTpm11__ShutdownProcess(struct soap *soap, struct __MultiXTpm11__ShutdownProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__ShutdownProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__ShutdownProcess * SOAP_FMAC4 soap_in___MultiXTpm11__ShutdownProcess(struct soap *soap, const char *tag, struct __MultiXTpm11__ShutdownProcess *a, const char *type)
{
	short soap_flag_MultiXTpm__ShutdownProcess = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__ShutdownProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__ShutdownProcess, sizeof(struct __MultiXTpm11__ShutdownProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__ShutdownProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__ShutdownProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__ShutdownProcess(soap, "MultiXTpm:ShutdownProcess", &a->MultiXTpm__ShutdownProcess, ""))
				{	soap_flag_MultiXTpm__ShutdownProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__ShutdownProcess * SOAP_FMAC6 soap_new___MultiXTpm11__ShutdownProcess(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__ShutdownProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__ShutdownProcess(struct soap *soap, struct __MultiXTpm11__ShutdownProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__ShutdownProcess * SOAP_FMAC4 soap_instantiate___MultiXTpm11__ShutdownProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__ShutdownProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__ShutdownProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__ShutdownProcess;
		if (size)
			*size = sizeof(struct __MultiXTpm11__ShutdownProcess);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__ShutdownProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__ShutdownProcess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__ShutdownProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__ShutdownProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__ShutdownProcess %p -> %p\n", q, p));
	*(struct __MultiXTpm11__ShutdownProcess*)p = *(struct __MultiXTpm11__ShutdownProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__StartGroup(struct soap *soap, struct __MultiXTpm11__StartGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__StartGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__StartGroup(struct soap *soap, const struct __MultiXTpm11__StartGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__StartGroup(soap, &a->MultiXTpm__StartGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__StartGroup(struct soap *soap, const struct __MultiXTpm11__StartGroup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__StartGroup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__StartGroup(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__StartGroup *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__StartGroup(soap, "MultiXTpm:StartGroup", -1, &a->MultiXTpm__StartGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__StartGroup * SOAP_FMAC4 soap_get___MultiXTpm11__StartGroup(struct soap *soap, struct __MultiXTpm11__StartGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__StartGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__StartGroup * SOAP_FMAC4 soap_in___MultiXTpm11__StartGroup(struct soap *soap, const char *tag, struct __MultiXTpm11__StartGroup *a, const char *type)
{
	short soap_flag_MultiXTpm__StartGroup = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__StartGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__StartGroup, sizeof(struct __MultiXTpm11__StartGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__StartGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__StartGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__StartGroup(soap, "MultiXTpm:StartGroup", &a->MultiXTpm__StartGroup, ""))
				{	soap_flag_MultiXTpm__StartGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__StartGroup * SOAP_FMAC6 soap_new___MultiXTpm11__StartGroup(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__StartGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__StartGroup(struct soap *soap, struct __MultiXTpm11__StartGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__StartGroup * SOAP_FMAC4 soap_instantiate___MultiXTpm11__StartGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__StartGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__StartGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__StartGroup;
		if (size)
			*size = sizeof(struct __MultiXTpm11__StartGroup);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__StartGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__StartGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__StartGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__StartGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__StartGroup %p -> %p\n", q, p));
	*(struct __MultiXTpm11__StartGroup*)p = *(struct __MultiXTpm11__StartGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__StartProcess(struct soap *soap, struct __MultiXTpm11__StartProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__StartProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__StartProcess(struct soap *soap, const struct __MultiXTpm11__StartProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__StartProcess(soap, &a->MultiXTpm__StartProcess);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__StartProcess(struct soap *soap, const struct __MultiXTpm11__StartProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__StartProcess(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__StartProcess(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__StartProcess *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__StartProcess(soap, "MultiXTpm:StartProcess", -1, &a->MultiXTpm__StartProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__StartProcess * SOAP_FMAC4 soap_get___MultiXTpm11__StartProcess(struct soap *soap, struct __MultiXTpm11__StartProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__StartProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__StartProcess * SOAP_FMAC4 soap_in___MultiXTpm11__StartProcess(struct soap *soap, const char *tag, struct __MultiXTpm11__StartProcess *a, const char *type)
{
	short soap_flag_MultiXTpm__StartProcess = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__StartProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__StartProcess, sizeof(struct __MultiXTpm11__StartProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__StartProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__StartProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__StartProcess(soap, "MultiXTpm:StartProcess", &a->MultiXTpm__StartProcess, ""))
				{	soap_flag_MultiXTpm__StartProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__StartProcess * SOAP_FMAC6 soap_new___MultiXTpm11__StartProcess(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__StartProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__StartProcess(struct soap *soap, struct __MultiXTpm11__StartProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__StartProcess * SOAP_FMAC4 soap_instantiate___MultiXTpm11__StartProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__StartProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__StartProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__StartProcess;
		if (size)
			*size = sizeof(struct __MultiXTpm11__StartProcess);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__StartProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__StartProcess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__StartProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__StartProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__StartProcess %p -> %p\n", q, p));
	*(struct __MultiXTpm11__StartProcess*)p = *(struct __MultiXTpm11__StartProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__RestartGroup(struct soap *soap, struct __MultiXTpm11__RestartGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__RestartGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__RestartGroup(struct soap *soap, const struct __MultiXTpm11__RestartGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__RestartGroup(soap, &a->MultiXTpm__RestartGroup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__RestartGroup(struct soap *soap, const struct __MultiXTpm11__RestartGroup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__RestartGroup(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__RestartGroup(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__RestartGroup *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__RestartGroup(soap, "MultiXTpm:RestartGroup", -1, &a->MultiXTpm__RestartGroup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__RestartGroup * SOAP_FMAC4 soap_get___MultiXTpm11__RestartGroup(struct soap *soap, struct __MultiXTpm11__RestartGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__RestartGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__RestartGroup * SOAP_FMAC4 soap_in___MultiXTpm11__RestartGroup(struct soap *soap, const char *tag, struct __MultiXTpm11__RestartGroup *a, const char *type)
{
	short soap_flag_MultiXTpm__RestartGroup = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__RestartGroup *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__RestartGroup, sizeof(struct __MultiXTpm11__RestartGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__RestartGroup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__RestartGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__RestartGroup(soap, "MultiXTpm:RestartGroup", &a->MultiXTpm__RestartGroup, ""))
				{	soap_flag_MultiXTpm__RestartGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__RestartGroup * SOAP_FMAC6 soap_new___MultiXTpm11__RestartGroup(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__RestartGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__RestartGroup(struct soap *soap, struct __MultiXTpm11__RestartGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__RestartGroup * SOAP_FMAC4 soap_instantiate___MultiXTpm11__RestartGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__RestartGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__RestartGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__RestartGroup;
		if (size)
			*size = sizeof(struct __MultiXTpm11__RestartGroup);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__RestartGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__RestartGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__RestartGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__RestartGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__RestartGroup %p -> %p\n", q, p));
	*(struct __MultiXTpm11__RestartGroup*)p = *(struct __MultiXTpm11__RestartGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__RestartProcess(struct soap *soap, struct __MultiXTpm11__RestartProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__RestartProcess = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__RestartProcess(struct soap *soap, const struct __MultiXTpm11__RestartProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__RestartProcess(soap, &a->MultiXTpm__RestartProcess);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__RestartProcess(struct soap *soap, const struct __MultiXTpm11__RestartProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__RestartProcess(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__RestartProcess(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__RestartProcess *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__RestartProcess(soap, "MultiXTpm:RestartProcess", -1, &a->MultiXTpm__RestartProcess, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__RestartProcess * SOAP_FMAC4 soap_get___MultiXTpm11__RestartProcess(struct soap *soap, struct __MultiXTpm11__RestartProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__RestartProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__RestartProcess * SOAP_FMAC4 soap_in___MultiXTpm11__RestartProcess(struct soap *soap, const char *tag, struct __MultiXTpm11__RestartProcess *a, const char *type)
{
	short soap_flag_MultiXTpm__RestartProcess = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__RestartProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__RestartProcess, sizeof(struct __MultiXTpm11__RestartProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__RestartProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__RestartProcess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__RestartProcess(soap, "MultiXTpm:RestartProcess", &a->MultiXTpm__RestartProcess, ""))
				{	soap_flag_MultiXTpm__RestartProcess--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__RestartProcess * SOAP_FMAC6 soap_new___MultiXTpm11__RestartProcess(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__RestartProcess(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__RestartProcess(struct soap *soap, struct __MultiXTpm11__RestartProcess *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__RestartProcess * SOAP_FMAC4 soap_instantiate___MultiXTpm11__RestartProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__RestartProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__RestartProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__RestartProcess;
		if (size)
			*size = sizeof(struct __MultiXTpm11__RestartProcess);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__RestartProcess[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__RestartProcess);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__RestartProcess*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__RestartProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__RestartProcess %p -> %p\n", q, p));
	*(struct __MultiXTpm11__RestartProcess*)p = *(struct __MultiXTpm11__RestartProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__GetSystemStatus(struct soap *soap, struct __MultiXTpm11__GetSystemStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__GetSystemStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__GetSystemStatus(struct soap *soap, const struct __MultiXTpm11__GetSystemStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__GetSystemStatus(soap, &a->MultiXTpm__GetSystemStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__GetSystemStatus(struct soap *soap, const struct __MultiXTpm11__GetSystemStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__GetSystemStatus(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__GetSystemStatus(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__GetSystemStatus *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__GetSystemStatus(soap, "MultiXTpm:GetSystemStatus", -1, &a->MultiXTpm__GetSystemStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__GetSystemStatus * SOAP_FMAC4 soap_get___MultiXTpm11__GetSystemStatus(struct soap *soap, struct __MultiXTpm11__GetSystemStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__GetSystemStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__GetSystemStatus * SOAP_FMAC4 soap_in___MultiXTpm11__GetSystemStatus(struct soap *soap, const char *tag, struct __MultiXTpm11__GetSystemStatus *a, const char *type)
{
	short soap_flag_MultiXTpm__GetSystemStatus = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__GetSystemStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__GetSystemStatus, sizeof(struct __MultiXTpm11__GetSystemStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__GetSystemStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__GetSystemStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__GetSystemStatus(soap, "MultiXTpm:GetSystemStatus", &a->MultiXTpm__GetSystemStatus, ""))
				{	soap_flag_MultiXTpm__GetSystemStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__GetSystemStatus * SOAP_FMAC6 soap_new___MultiXTpm11__GetSystemStatus(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__GetSystemStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__GetSystemStatus(struct soap *soap, struct __MultiXTpm11__GetSystemStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__GetSystemStatus * SOAP_FMAC4 soap_instantiate___MultiXTpm11__GetSystemStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__GetSystemStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__GetSystemStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__GetSystemStatus;
		if (size)
			*size = sizeof(struct __MultiXTpm11__GetSystemStatus);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__GetSystemStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__GetSystemStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__GetSystemStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__GetSystemStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__GetSystemStatus %p -> %p\n", q, p));
	*(struct __MultiXTpm11__GetSystemStatus*)p = *(struct __MultiXTpm11__GetSystemStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__UpdateConfig(struct soap *soap, struct __MultiXTpm11__UpdateConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__UpdateConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__UpdateConfig(struct soap *soap, const struct __MultiXTpm11__UpdateConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__UpdateConfig(soap, &a->MultiXTpm__UpdateConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__UpdateConfig(struct soap *soap, const struct __MultiXTpm11__UpdateConfig *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__UpdateConfig(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__UpdateConfig(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__UpdateConfig *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__UpdateConfig(soap, "MultiXTpm:UpdateConfig", -1, &a->MultiXTpm__UpdateConfig, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__UpdateConfig * SOAP_FMAC4 soap_get___MultiXTpm11__UpdateConfig(struct soap *soap, struct __MultiXTpm11__UpdateConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__UpdateConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__UpdateConfig * SOAP_FMAC4 soap_in___MultiXTpm11__UpdateConfig(struct soap *soap, const char *tag, struct __MultiXTpm11__UpdateConfig *a, const char *type)
{
	short soap_flag_MultiXTpm__UpdateConfig = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__UpdateConfig *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__UpdateConfig, sizeof(struct __MultiXTpm11__UpdateConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__UpdateConfig(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__UpdateConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__UpdateConfig(soap, "MultiXTpm:UpdateConfig", &a->MultiXTpm__UpdateConfig, ""))
				{	soap_flag_MultiXTpm__UpdateConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__UpdateConfig * SOAP_FMAC6 soap_new___MultiXTpm11__UpdateConfig(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__UpdateConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__UpdateConfig(struct soap *soap, struct __MultiXTpm11__UpdateConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__UpdateConfig * SOAP_FMAC4 soap_instantiate___MultiXTpm11__UpdateConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__UpdateConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__UpdateConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__UpdateConfig;
		if (size)
			*size = sizeof(struct __MultiXTpm11__UpdateConfig);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__UpdateConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__UpdateConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__UpdateConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__UpdateConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__UpdateConfig %p -> %p\n", q, p));
	*(struct __MultiXTpm11__UpdateConfig*)p = *(struct __MultiXTpm11__UpdateConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___MultiXTpm11__GetConfig(struct soap *soap, struct __MultiXTpm11__GetConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MultiXTpm__GetConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___MultiXTpm11__GetConfig(struct soap *soap, const struct __MultiXTpm11__GetConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_MultiXTpm__GetConfig(soap, &a->MultiXTpm__GetConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___MultiXTpm11__GetConfig(struct soap *soap, const struct __MultiXTpm11__GetConfig *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___MultiXTpm11__GetConfig(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___MultiXTpm11__GetConfig(struct soap *soap, const char *tag, int id, const struct __MultiXTpm11__GetConfig *a, const char *type)
{
	if (soap_out_PointerTo_MultiXTpm__GetConfig(soap, "MultiXTpm:GetConfig", -1, &a->MultiXTpm__GetConfig, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __MultiXTpm11__GetConfig * SOAP_FMAC4 soap_get___MultiXTpm11__GetConfig(struct soap *soap, struct __MultiXTpm11__GetConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in___MultiXTpm11__GetConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __MultiXTpm11__GetConfig * SOAP_FMAC4 soap_in___MultiXTpm11__GetConfig(struct soap *soap, const char *tag, struct __MultiXTpm11__GetConfig *a, const char *type)
{
	short soap_flag_MultiXTpm__GetConfig = 1;
	short soap_flag;
	a = (struct __MultiXTpm11__GetConfig *)soap_id_enter(soap, "", a, SOAP_TYPE___MultiXTpm11__GetConfig, sizeof(struct __MultiXTpm11__GetConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___MultiXTpm11__GetConfig(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MultiXTpm__GetConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_MultiXTpm__GetConfig(soap, "MultiXTpm:GetConfig", &a->MultiXTpm__GetConfig, ""))
				{	soap_flag_MultiXTpm__GetConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __MultiXTpm11__GetConfig * SOAP_FMAC6 soap_new___MultiXTpm11__GetConfig(struct soap *soap, int n)
{	return soap_instantiate___MultiXTpm11__GetConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___MultiXTpm11__GetConfig(struct soap *soap, struct __MultiXTpm11__GetConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __MultiXTpm11__GetConfig * SOAP_FMAC4 soap_instantiate___MultiXTpm11__GetConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___MultiXTpm11__GetConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___MultiXTpm11__GetConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __MultiXTpm11__GetConfig;
		if (size)
			*size = sizeof(struct __MultiXTpm11__GetConfig);
	}
	else
	{	cp->ptr = (void*)new struct __MultiXTpm11__GetConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __MultiXTpm11__GetConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __MultiXTpm11__GetConfig*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___MultiXTpm11__GetConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __MultiXTpm11__GetConfig %p -> %p\n", q, p));
	*(struct __MultiXTpm11__GetConfig*)p = *(struct __MultiXTpm11__GetConfig*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ResumeAllResponse(struct soap *soap, _MultiXTpm__ResumeAllResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ResumeAllResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ResumeAllResponse(struct soap *soap, _MultiXTpm__ResumeAllResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ResumeAllResponse);
	if (soap_out_PointerTo_MultiXTpm__ResumeAllResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ResumeAllResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__ResumeAllResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ResumeAllResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeAllResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ResumeAllResponse(struct soap *soap, _MultiXTpm__ResumeAllResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ResumeAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ResumeAllResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ResumeAllResponse(struct soap *soap, const char *tag, _MultiXTpm__ResumeAllResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ResumeAllResponse **)soap_malloc(soap, sizeof(_MultiXTpm__ResumeAllResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ResumeAllResponse *)soap_instantiate__MultiXTpm__ResumeAllResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ResumeAllResponse ** p = (_MultiXTpm__ResumeAllResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ResumeAllResponse, sizeof(_MultiXTpm__ResumeAllResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ResumeAll(struct soap *soap, _MultiXTpm__ResumeAll *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ResumeAll))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ResumeAll(struct soap *soap, _MultiXTpm__ResumeAll *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ResumeAll);
	if (soap_out_PointerTo_MultiXTpm__ResumeAll(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ResumeAll(struct soap *soap, const char *tag, int id, _MultiXTpm__ResumeAll *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ResumeAll);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeAll ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ResumeAll(struct soap *soap, _MultiXTpm__ResumeAll **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ResumeAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ResumeAll ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ResumeAll(struct soap *soap, const char *tag, _MultiXTpm__ResumeAll **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ResumeAll **)soap_malloc(soap, sizeof(_MultiXTpm__ResumeAll *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ResumeAll *)soap_instantiate__MultiXTpm__ResumeAll(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ResumeAll ** p = (_MultiXTpm__ResumeAll **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ResumeAll, sizeof(_MultiXTpm__ResumeAll), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__SuspendAllResponse(struct soap *soap, _MultiXTpm__SuspendAllResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__SuspendAllResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__SuspendAllResponse(struct soap *soap, _MultiXTpm__SuspendAllResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__SuspendAllResponse);
	if (soap_out_PointerTo_MultiXTpm__SuspendAllResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__SuspendAllResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__SuspendAllResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__SuspendAllResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendAllResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__SuspendAllResponse(struct soap *soap, _MultiXTpm__SuspendAllResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__SuspendAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__SuspendAllResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__SuspendAllResponse(struct soap *soap, const char *tag, _MultiXTpm__SuspendAllResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__SuspendAllResponse **)soap_malloc(soap, sizeof(_MultiXTpm__SuspendAllResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__SuspendAllResponse *)soap_instantiate__MultiXTpm__SuspendAllResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__SuspendAllResponse ** p = (_MultiXTpm__SuspendAllResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__SuspendAllResponse, sizeof(_MultiXTpm__SuspendAllResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__SuspendAll(struct soap *soap, _MultiXTpm__SuspendAll *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__SuspendAll))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__SuspendAll(struct soap *soap, _MultiXTpm__SuspendAll *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__SuspendAll);
	if (soap_out_PointerTo_MultiXTpm__SuspendAll(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__SuspendAll(struct soap *soap, const char *tag, int id, _MultiXTpm__SuspendAll *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__SuspendAll);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendAll ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__SuspendAll(struct soap *soap, _MultiXTpm__SuspendAll **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__SuspendAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__SuspendAll ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__SuspendAll(struct soap *soap, const char *tag, _MultiXTpm__SuspendAll **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__SuspendAll **)soap_malloc(soap, sizeof(_MultiXTpm__SuspendAll *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__SuspendAll *)soap_instantiate__MultiXTpm__SuspendAll(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__SuspendAll ** p = (_MultiXTpm__SuspendAll **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__SuspendAll, sizeof(_MultiXTpm__SuspendAll), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ShutdownAllResponse(struct soap *soap, _MultiXTpm__ShutdownAllResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ShutdownAllResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ShutdownAllResponse(struct soap *soap, _MultiXTpm__ShutdownAllResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ShutdownAllResponse);
	if (soap_out_PointerTo_MultiXTpm__ShutdownAllResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ShutdownAllResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__ShutdownAllResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ShutdownAllResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownAllResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ShutdownAllResponse(struct soap *soap, _MultiXTpm__ShutdownAllResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ShutdownAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ShutdownAllResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ShutdownAllResponse(struct soap *soap, const char *tag, _MultiXTpm__ShutdownAllResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ShutdownAllResponse **)soap_malloc(soap, sizeof(_MultiXTpm__ShutdownAllResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ShutdownAllResponse *)soap_instantiate__MultiXTpm__ShutdownAllResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ShutdownAllResponse ** p = (_MultiXTpm__ShutdownAllResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ShutdownAllResponse, sizeof(_MultiXTpm__ShutdownAllResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ShutdownAll(struct soap *soap, _MultiXTpm__ShutdownAll *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ShutdownAll))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ShutdownAll(struct soap *soap, _MultiXTpm__ShutdownAll *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ShutdownAll);
	if (soap_out_PointerTo_MultiXTpm__ShutdownAll(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ShutdownAll(struct soap *soap, const char *tag, int id, _MultiXTpm__ShutdownAll *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ShutdownAll);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownAll ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ShutdownAll(struct soap *soap, _MultiXTpm__ShutdownAll **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ShutdownAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ShutdownAll ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ShutdownAll(struct soap *soap, const char *tag, _MultiXTpm__ShutdownAll **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ShutdownAll **)soap_malloc(soap, sizeof(_MultiXTpm__ShutdownAll *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ShutdownAll *)soap_instantiate__MultiXTpm__ShutdownAll(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ShutdownAll ** p = (_MultiXTpm__ShutdownAll **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ShutdownAll, sizeof(_MultiXTpm__ShutdownAll), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__StartAllResponse(struct soap *soap, _MultiXTpm__StartAllResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__StartAllResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__StartAllResponse(struct soap *soap, _MultiXTpm__StartAllResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__StartAllResponse);
	if (soap_out_PointerTo_MultiXTpm__StartAllResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__StartAllResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__StartAllResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__StartAllResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__StartAllResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__StartAllResponse(struct soap *soap, _MultiXTpm__StartAllResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__StartAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__StartAllResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__StartAllResponse(struct soap *soap, const char *tag, _MultiXTpm__StartAllResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__StartAllResponse **)soap_malloc(soap, sizeof(_MultiXTpm__StartAllResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__StartAllResponse *)soap_instantiate__MultiXTpm__StartAllResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__StartAllResponse ** p = (_MultiXTpm__StartAllResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__StartAllResponse, sizeof(_MultiXTpm__StartAllResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__StartAll(struct soap *soap, _MultiXTpm__StartAll *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__StartAll))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__StartAll(struct soap *soap, _MultiXTpm__StartAll *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__StartAll);
	if (soap_out_PointerTo_MultiXTpm__StartAll(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__StartAll(struct soap *soap, const char *tag, int id, _MultiXTpm__StartAll *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__StartAll);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__StartAll ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__StartAll(struct soap *soap, _MultiXTpm__StartAll **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__StartAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__StartAll ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__StartAll(struct soap *soap, const char *tag, _MultiXTpm__StartAll **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__StartAll **)soap_malloc(soap, sizeof(_MultiXTpm__StartAll *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__StartAll *)soap_instantiate__MultiXTpm__StartAll(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__StartAll ** p = (_MultiXTpm__StartAll **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__StartAll, sizeof(_MultiXTpm__StartAll), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__RestartAllResponse(struct soap *soap, _MultiXTpm__RestartAllResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__RestartAllResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__RestartAllResponse(struct soap *soap, _MultiXTpm__RestartAllResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__RestartAllResponse);
	if (soap_out_PointerTo_MultiXTpm__RestartAllResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__RestartAllResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__RestartAllResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__RestartAllResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__RestartAllResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__RestartAllResponse(struct soap *soap, _MultiXTpm__RestartAllResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__RestartAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__RestartAllResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__RestartAllResponse(struct soap *soap, const char *tag, _MultiXTpm__RestartAllResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__RestartAllResponse **)soap_malloc(soap, sizeof(_MultiXTpm__RestartAllResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__RestartAllResponse *)soap_instantiate__MultiXTpm__RestartAllResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__RestartAllResponse ** p = (_MultiXTpm__RestartAllResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__RestartAllResponse, sizeof(_MultiXTpm__RestartAllResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__RestartAll(struct soap *soap, _MultiXTpm__RestartAll *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__RestartAll))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__RestartAll(struct soap *soap, _MultiXTpm__RestartAll *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__RestartAll);
	if (soap_out_PointerTo_MultiXTpm__RestartAll(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__RestartAll(struct soap *soap, const char *tag, int id, _MultiXTpm__RestartAll *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__RestartAll);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__RestartAll ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__RestartAll(struct soap *soap, _MultiXTpm__RestartAll **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__RestartAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__RestartAll ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__RestartAll(struct soap *soap, const char *tag, _MultiXTpm__RestartAll **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__RestartAll **)soap_malloc(soap, sizeof(_MultiXTpm__RestartAll *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__RestartAll *)soap_instantiate__MultiXTpm__RestartAll(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__RestartAll ** p = (_MultiXTpm__RestartAll **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__RestartAll, sizeof(_MultiXTpm__RestartAll), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ResumeProcessResponse(struct soap *soap, _MultiXTpm__ResumeProcessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ResumeProcessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ResumeProcessResponse(struct soap *soap, _MultiXTpm__ResumeProcessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ResumeProcessResponse);
	if (soap_out_PointerTo_MultiXTpm__ResumeProcessResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ResumeProcessResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__ResumeProcessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ResumeProcessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeProcessResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ResumeProcessResponse(struct soap *soap, _MultiXTpm__ResumeProcessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ResumeProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ResumeProcessResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ResumeProcessResponse(struct soap *soap, const char *tag, _MultiXTpm__ResumeProcessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ResumeProcessResponse **)soap_malloc(soap, sizeof(_MultiXTpm__ResumeProcessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ResumeProcessResponse *)soap_instantiate__MultiXTpm__ResumeProcessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ResumeProcessResponse ** p = (_MultiXTpm__ResumeProcessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ResumeProcessResponse, sizeof(_MultiXTpm__ResumeProcessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ResumeProcess(struct soap *soap, _MultiXTpm__ResumeProcess *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ResumeProcess))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ResumeProcess(struct soap *soap, _MultiXTpm__ResumeProcess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ResumeProcess);
	if (soap_out_PointerTo_MultiXTpm__ResumeProcess(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ResumeProcess(struct soap *soap, const char *tag, int id, _MultiXTpm__ResumeProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ResumeProcess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeProcess ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ResumeProcess(struct soap *soap, _MultiXTpm__ResumeProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ResumeProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ResumeProcess ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ResumeProcess(struct soap *soap, const char *tag, _MultiXTpm__ResumeProcess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ResumeProcess **)soap_malloc(soap, sizeof(_MultiXTpm__ResumeProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ResumeProcess *)soap_instantiate__MultiXTpm__ResumeProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ResumeProcess ** p = (_MultiXTpm__ResumeProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ResumeProcess, sizeof(_MultiXTpm__ResumeProcess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ResumeGroupResponse(struct soap *soap, _MultiXTpm__ResumeGroupResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ResumeGroupResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ResumeGroupResponse(struct soap *soap, _MultiXTpm__ResumeGroupResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ResumeGroupResponse);
	if (soap_out_PointerTo_MultiXTpm__ResumeGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ResumeGroupResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__ResumeGroupResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ResumeGroupResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeGroupResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ResumeGroupResponse(struct soap *soap, _MultiXTpm__ResumeGroupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ResumeGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ResumeGroupResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ResumeGroupResponse(struct soap *soap, const char *tag, _MultiXTpm__ResumeGroupResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ResumeGroupResponse **)soap_malloc(soap, sizeof(_MultiXTpm__ResumeGroupResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ResumeGroupResponse *)soap_instantiate__MultiXTpm__ResumeGroupResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ResumeGroupResponse ** p = (_MultiXTpm__ResumeGroupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ResumeGroupResponse, sizeof(_MultiXTpm__ResumeGroupResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ResumeGroup(struct soap *soap, _MultiXTpm__ResumeGroup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ResumeGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ResumeGroup(struct soap *soap, _MultiXTpm__ResumeGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ResumeGroup);
	if (soap_out_PointerTo_MultiXTpm__ResumeGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ResumeGroup(struct soap *soap, const char *tag, int id, _MultiXTpm__ResumeGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ResumeGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ResumeGroup ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ResumeGroup(struct soap *soap, _MultiXTpm__ResumeGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ResumeGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ResumeGroup ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ResumeGroup(struct soap *soap, const char *tag, _MultiXTpm__ResumeGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ResumeGroup **)soap_malloc(soap, sizeof(_MultiXTpm__ResumeGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ResumeGroup *)soap_instantiate__MultiXTpm__ResumeGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ResumeGroup ** p = (_MultiXTpm__ResumeGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ResumeGroup, sizeof(_MultiXTpm__ResumeGroup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__SuspendProcessResponse(struct soap *soap, _MultiXTpm__SuspendProcessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__SuspendProcessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__SuspendProcessResponse(struct soap *soap, _MultiXTpm__SuspendProcessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__SuspendProcessResponse);
	if (soap_out_PointerTo_MultiXTpm__SuspendProcessResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__SuspendProcessResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__SuspendProcessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__SuspendProcessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendProcessResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__SuspendProcessResponse(struct soap *soap, _MultiXTpm__SuspendProcessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__SuspendProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__SuspendProcessResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__SuspendProcessResponse(struct soap *soap, const char *tag, _MultiXTpm__SuspendProcessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__SuspendProcessResponse **)soap_malloc(soap, sizeof(_MultiXTpm__SuspendProcessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__SuspendProcessResponse *)soap_instantiate__MultiXTpm__SuspendProcessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__SuspendProcessResponse ** p = (_MultiXTpm__SuspendProcessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__SuspendProcessResponse, sizeof(_MultiXTpm__SuspendProcessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__SuspendProcess(struct soap *soap, _MultiXTpm__SuspendProcess *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__SuspendProcess))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__SuspendProcess(struct soap *soap, _MultiXTpm__SuspendProcess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__SuspendProcess);
	if (soap_out_PointerTo_MultiXTpm__SuspendProcess(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__SuspendProcess(struct soap *soap, const char *tag, int id, _MultiXTpm__SuspendProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__SuspendProcess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendProcess ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__SuspendProcess(struct soap *soap, _MultiXTpm__SuspendProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__SuspendProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__SuspendProcess ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__SuspendProcess(struct soap *soap, const char *tag, _MultiXTpm__SuspendProcess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__SuspendProcess **)soap_malloc(soap, sizeof(_MultiXTpm__SuspendProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__SuspendProcess *)soap_instantiate__MultiXTpm__SuspendProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__SuspendProcess ** p = (_MultiXTpm__SuspendProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__SuspendProcess, sizeof(_MultiXTpm__SuspendProcess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__SuspendGroupResponse(struct soap *soap, _MultiXTpm__SuspendGroupResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__SuspendGroupResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__SuspendGroupResponse(struct soap *soap, _MultiXTpm__SuspendGroupResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__SuspendGroupResponse);
	if (soap_out_PointerTo_MultiXTpm__SuspendGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__SuspendGroupResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__SuspendGroupResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__SuspendGroupResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendGroupResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__SuspendGroupResponse(struct soap *soap, _MultiXTpm__SuspendGroupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__SuspendGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__SuspendGroupResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__SuspendGroupResponse(struct soap *soap, const char *tag, _MultiXTpm__SuspendGroupResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__SuspendGroupResponse **)soap_malloc(soap, sizeof(_MultiXTpm__SuspendGroupResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__SuspendGroupResponse *)soap_instantiate__MultiXTpm__SuspendGroupResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__SuspendGroupResponse ** p = (_MultiXTpm__SuspendGroupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__SuspendGroupResponse, sizeof(_MultiXTpm__SuspendGroupResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__SuspendGroup(struct soap *soap, _MultiXTpm__SuspendGroup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__SuspendGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__SuspendGroup(struct soap *soap, _MultiXTpm__SuspendGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__SuspendGroup);
	if (soap_out_PointerTo_MultiXTpm__SuspendGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__SuspendGroup(struct soap *soap, const char *tag, int id, _MultiXTpm__SuspendGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__SuspendGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__SuspendGroup ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__SuspendGroup(struct soap *soap, _MultiXTpm__SuspendGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__SuspendGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__SuspendGroup ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__SuspendGroup(struct soap *soap, const char *tag, _MultiXTpm__SuspendGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__SuspendGroup **)soap_malloc(soap, sizeof(_MultiXTpm__SuspendGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__SuspendGroup *)soap_instantiate__MultiXTpm__SuspendGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__SuspendGroup ** p = (_MultiXTpm__SuspendGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__SuspendGroup, sizeof(_MultiXTpm__SuspendGroup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ShutdownGroupResponse(struct soap *soap, _MultiXTpm__ShutdownGroupResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ShutdownGroupResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ShutdownGroupResponse(struct soap *soap, _MultiXTpm__ShutdownGroupResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ShutdownGroupResponse);
	if (soap_out_PointerTo_MultiXTpm__ShutdownGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ShutdownGroupResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__ShutdownGroupResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ShutdownGroupResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownGroupResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ShutdownGroupResponse(struct soap *soap, _MultiXTpm__ShutdownGroupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ShutdownGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ShutdownGroupResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ShutdownGroupResponse(struct soap *soap, const char *tag, _MultiXTpm__ShutdownGroupResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ShutdownGroupResponse **)soap_malloc(soap, sizeof(_MultiXTpm__ShutdownGroupResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ShutdownGroupResponse *)soap_instantiate__MultiXTpm__ShutdownGroupResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ShutdownGroupResponse ** p = (_MultiXTpm__ShutdownGroupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ShutdownGroupResponse, sizeof(_MultiXTpm__ShutdownGroupResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ShutdownGroup(struct soap *soap, _MultiXTpm__ShutdownGroup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ShutdownGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ShutdownGroup(struct soap *soap, _MultiXTpm__ShutdownGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ShutdownGroup);
	if (soap_out_PointerTo_MultiXTpm__ShutdownGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ShutdownGroup(struct soap *soap, const char *tag, int id, _MultiXTpm__ShutdownGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ShutdownGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownGroup ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ShutdownGroup(struct soap *soap, _MultiXTpm__ShutdownGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ShutdownGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ShutdownGroup ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ShutdownGroup(struct soap *soap, const char *tag, _MultiXTpm__ShutdownGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ShutdownGroup **)soap_malloc(soap, sizeof(_MultiXTpm__ShutdownGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ShutdownGroup *)soap_instantiate__MultiXTpm__ShutdownGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ShutdownGroup ** p = (_MultiXTpm__ShutdownGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ShutdownGroup, sizeof(_MultiXTpm__ShutdownGroup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ShutdownProcessResponse(struct soap *soap, _MultiXTpm__ShutdownProcessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ShutdownProcessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ShutdownProcessResponse(struct soap *soap, _MultiXTpm__ShutdownProcessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ShutdownProcessResponse);
	if (soap_out_PointerTo_MultiXTpm__ShutdownProcessResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ShutdownProcessResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__ShutdownProcessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ShutdownProcessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownProcessResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ShutdownProcessResponse(struct soap *soap, _MultiXTpm__ShutdownProcessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ShutdownProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ShutdownProcessResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ShutdownProcessResponse(struct soap *soap, const char *tag, _MultiXTpm__ShutdownProcessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ShutdownProcessResponse **)soap_malloc(soap, sizeof(_MultiXTpm__ShutdownProcessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ShutdownProcessResponse *)soap_instantiate__MultiXTpm__ShutdownProcessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ShutdownProcessResponse ** p = (_MultiXTpm__ShutdownProcessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ShutdownProcessResponse, sizeof(_MultiXTpm__ShutdownProcessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__ShutdownProcess(struct soap *soap, _MultiXTpm__ShutdownProcess *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__ShutdownProcess))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__ShutdownProcess(struct soap *soap, _MultiXTpm__ShutdownProcess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__ShutdownProcess);
	if (soap_out_PointerTo_MultiXTpm__ShutdownProcess(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__ShutdownProcess(struct soap *soap, const char *tag, int id, _MultiXTpm__ShutdownProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__ShutdownProcess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__ShutdownProcess ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__ShutdownProcess(struct soap *soap, _MultiXTpm__ShutdownProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__ShutdownProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__ShutdownProcess ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__ShutdownProcess(struct soap *soap, const char *tag, _MultiXTpm__ShutdownProcess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__ShutdownProcess **)soap_malloc(soap, sizeof(_MultiXTpm__ShutdownProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__ShutdownProcess *)soap_instantiate__MultiXTpm__ShutdownProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__ShutdownProcess ** p = (_MultiXTpm__ShutdownProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__ShutdownProcess, sizeof(_MultiXTpm__ShutdownProcess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__StartGroupResponse(struct soap *soap, _MultiXTpm__StartGroupResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__StartGroupResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__StartGroupResponse(struct soap *soap, _MultiXTpm__StartGroupResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__StartGroupResponse);
	if (soap_out_PointerTo_MultiXTpm__StartGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__StartGroupResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__StartGroupResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__StartGroupResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__StartGroupResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__StartGroupResponse(struct soap *soap, _MultiXTpm__StartGroupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__StartGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__StartGroupResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__StartGroupResponse(struct soap *soap, const char *tag, _MultiXTpm__StartGroupResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__StartGroupResponse **)soap_malloc(soap, sizeof(_MultiXTpm__StartGroupResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__StartGroupResponse *)soap_instantiate__MultiXTpm__StartGroupResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__StartGroupResponse ** p = (_MultiXTpm__StartGroupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__StartGroupResponse, sizeof(_MultiXTpm__StartGroupResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__StartGroup(struct soap *soap, _MultiXTpm__StartGroup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__StartGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__StartGroup(struct soap *soap, _MultiXTpm__StartGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__StartGroup);
	if (soap_out_PointerTo_MultiXTpm__StartGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__StartGroup(struct soap *soap, const char *tag, int id, _MultiXTpm__StartGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__StartGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__StartGroup ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__StartGroup(struct soap *soap, _MultiXTpm__StartGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__StartGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__StartGroup ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__StartGroup(struct soap *soap, const char *tag, _MultiXTpm__StartGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__StartGroup **)soap_malloc(soap, sizeof(_MultiXTpm__StartGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__StartGroup *)soap_instantiate__MultiXTpm__StartGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__StartGroup ** p = (_MultiXTpm__StartGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__StartGroup, sizeof(_MultiXTpm__StartGroup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__StartProcessResponse(struct soap *soap, _MultiXTpm__StartProcessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__StartProcessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__StartProcessResponse(struct soap *soap, _MultiXTpm__StartProcessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__StartProcessResponse);
	if (soap_out_PointerTo_MultiXTpm__StartProcessResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__StartProcessResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__StartProcessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__StartProcessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__StartProcessResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__StartProcessResponse(struct soap *soap, _MultiXTpm__StartProcessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__StartProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__StartProcessResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__StartProcessResponse(struct soap *soap, const char *tag, _MultiXTpm__StartProcessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__StartProcessResponse **)soap_malloc(soap, sizeof(_MultiXTpm__StartProcessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__StartProcessResponse *)soap_instantiate__MultiXTpm__StartProcessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__StartProcessResponse ** p = (_MultiXTpm__StartProcessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__StartProcessResponse, sizeof(_MultiXTpm__StartProcessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__StartProcess(struct soap *soap, _MultiXTpm__StartProcess *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__StartProcess))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__StartProcess(struct soap *soap, _MultiXTpm__StartProcess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__StartProcess);
	if (soap_out_PointerTo_MultiXTpm__StartProcess(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__StartProcess(struct soap *soap, const char *tag, int id, _MultiXTpm__StartProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__StartProcess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__StartProcess ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__StartProcess(struct soap *soap, _MultiXTpm__StartProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__StartProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__StartProcess ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__StartProcess(struct soap *soap, const char *tag, _MultiXTpm__StartProcess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__StartProcess **)soap_malloc(soap, sizeof(_MultiXTpm__StartProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__StartProcess *)soap_instantiate__MultiXTpm__StartProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__StartProcess ** p = (_MultiXTpm__StartProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__StartProcess, sizeof(_MultiXTpm__StartProcess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__RestartGroupResponse(struct soap *soap, _MultiXTpm__RestartGroupResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__RestartGroupResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__RestartGroupResponse(struct soap *soap, _MultiXTpm__RestartGroupResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__RestartGroupResponse);
	if (soap_out_PointerTo_MultiXTpm__RestartGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__RestartGroupResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__RestartGroupResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__RestartGroupResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__RestartGroupResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__RestartGroupResponse(struct soap *soap, _MultiXTpm__RestartGroupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__RestartGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__RestartGroupResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__RestartGroupResponse(struct soap *soap, const char *tag, _MultiXTpm__RestartGroupResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__RestartGroupResponse **)soap_malloc(soap, sizeof(_MultiXTpm__RestartGroupResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__RestartGroupResponse *)soap_instantiate__MultiXTpm__RestartGroupResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__RestartGroupResponse ** p = (_MultiXTpm__RestartGroupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__RestartGroupResponse, sizeof(_MultiXTpm__RestartGroupResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__RestartGroup(struct soap *soap, _MultiXTpm__RestartGroup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__RestartGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__RestartGroup(struct soap *soap, _MultiXTpm__RestartGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__RestartGroup);
	if (soap_out_PointerTo_MultiXTpm__RestartGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__RestartGroup(struct soap *soap, const char *tag, int id, _MultiXTpm__RestartGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__RestartGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__RestartGroup ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__RestartGroup(struct soap *soap, _MultiXTpm__RestartGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__RestartGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__RestartGroup ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__RestartGroup(struct soap *soap, const char *tag, _MultiXTpm__RestartGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__RestartGroup **)soap_malloc(soap, sizeof(_MultiXTpm__RestartGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__RestartGroup *)soap_instantiate__MultiXTpm__RestartGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__RestartGroup ** p = (_MultiXTpm__RestartGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__RestartGroup, sizeof(_MultiXTpm__RestartGroup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__RestartProcessResponse(struct soap *soap, _MultiXTpm__RestartProcessResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__RestartProcessResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__RestartProcessResponse(struct soap *soap, _MultiXTpm__RestartProcessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__RestartProcessResponse);
	if (soap_out_PointerTo_MultiXTpm__RestartProcessResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__RestartProcessResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__RestartProcessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__RestartProcessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__RestartProcessResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__RestartProcessResponse(struct soap *soap, _MultiXTpm__RestartProcessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__RestartProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__RestartProcessResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__RestartProcessResponse(struct soap *soap, const char *tag, _MultiXTpm__RestartProcessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__RestartProcessResponse **)soap_malloc(soap, sizeof(_MultiXTpm__RestartProcessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__RestartProcessResponse *)soap_instantiate__MultiXTpm__RestartProcessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__RestartProcessResponse ** p = (_MultiXTpm__RestartProcessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__RestartProcessResponse, sizeof(_MultiXTpm__RestartProcessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__RestartProcess(struct soap *soap, _MultiXTpm__RestartProcess *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__RestartProcess))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__RestartProcess(struct soap *soap, _MultiXTpm__RestartProcess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__RestartProcess);
	if (soap_out_PointerTo_MultiXTpm__RestartProcess(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__RestartProcess(struct soap *soap, const char *tag, int id, _MultiXTpm__RestartProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__RestartProcess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__RestartProcess ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__RestartProcess(struct soap *soap, _MultiXTpm__RestartProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__RestartProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__RestartProcess ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__RestartProcess(struct soap *soap, const char *tag, _MultiXTpm__RestartProcess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__RestartProcess **)soap_malloc(soap, sizeof(_MultiXTpm__RestartProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__RestartProcess *)soap_instantiate__MultiXTpm__RestartProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__RestartProcess ** p = (_MultiXTpm__RestartProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__RestartProcess, sizeof(_MultiXTpm__RestartProcess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__GetSystemStatusResponse(struct soap *soap, _MultiXTpm__GetSystemStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__GetSystemStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__GetSystemStatusResponse(struct soap *soap, _MultiXTpm__GetSystemStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__GetSystemStatusResponse);
	if (soap_out_PointerTo_MultiXTpm__GetSystemStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__GetSystemStatusResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__GetSystemStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__GetSystemStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__GetSystemStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__GetSystemStatusResponse(struct soap *soap, _MultiXTpm__GetSystemStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__GetSystemStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__GetSystemStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__GetSystemStatusResponse(struct soap *soap, const char *tag, _MultiXTpm__GetSystemStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__GetSystemStatusResponse **)soap_malloc(soap, sizeof(_MultiXTpm__GetSystemStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__GetSystemStatusResponse *)soap_instantiate__MultiXTpm__GetSystemStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__GetSystemStatusResponse ** p = (_MultiXTpm__GetSystemStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__GetSystemStatusResponse, sizeof(_MultiXTpm__GetSystemStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__GetSystemStatus(struct soap *soap, _MultiXTpm__GetSystemStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__GetSystemStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__GetSystemStatus(struct soap *soap, _MultiXTpm__GetSystemStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__GetSystemStatus);
	if (soap_out_PointerTo_MultiXTpm__GetSystemStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__GetSystemStatus(struct soap *soap, const char *tag, int id, _MultiXTpm__GetSystemStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__GetSystemStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__GetSystemStatus ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__GetSystemStatus(struct soap *soap, _MultiXTpm__GetSystemStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__GetSystemStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__GetSystemStatus ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__GetSystemStatus(struct soap *soap, const char *tag, _MultiXTpm__GetSystemStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__GetSystemStatus **)soap_malloc(soap, sizeof(_MultiXTpm__GetSystemStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__GetSystemStatus *)soap_instantiate__MultiXTpm__GetSystemStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__GetSystemStatus ** p = (_MultiXTpm__GetSystemStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__GetSystemStatus, sizeof(_MultiXTpm__GetSystemStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__UpdateConfigResponse(struct soap *soap, _MultiXTpm__UpdateConfigResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__UpdateConfigResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__UpdateConfigResponse(struct soap *soap, _MultiXTpm__UpdateConfigResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__UpdateConfigResponse);
	if (soap_out_PointerTo_MultiXTpm__UpdateConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__UpdateConfigResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__UpdateConfigResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__UpdateConfigResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__UpdateConfigResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__UpdateConfigResponse(struct soap *soap, _MultiXTpm__UpdateConfigResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__UpdateConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__UpdateConfigResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__UpdateConfigResponse(struct soap *soap, const char *tag, _MultiXTpm__UpdateConfigResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__UpdateConfigResponse **)soap_malloc(soap, sizeof(_MultiXTpm__UpdateConfigResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__UpdateConfigResponse *)soap_instantiate__MultiXTpm__UpdateConfigResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__UpdateConfigResponse ** p = (_MultiXTpm__UpdateConfigResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__UpdateConfigResponse, sizeof(_MultiXTpm__UpdateConfigResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__UpdateConfig(struct soap *soap, _MultiXTpm__UpdateConfig *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__UpdateConfig))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__UpdateConfig(struct soap *soap, _MultiXTpm__UpdateConfig *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__UpdateConfig);
	if (soap_out_PointerTo_MultiXTpm__UpdateConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__UpdateConfig(struct soap *soap, const char *tag, int id, _MultiXTpm__UpdateConfig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__UpdateConfig);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__UpdateConfig ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__UpdateConfig(struct soap *soap, _MultiXTpm__UpdateConfig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__UpdateConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__UpdateConfig ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__UpdateConfig(struct soap *soap, const char *tag, _MultiXTpm__UpdateConfig **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__UpdateConfig **)soap_malloc(soap, sizeof(_MultiXTpm__UpdateConfig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__UpdateConfig *)soap_instantiate__MultiXTpm__UpdateConfig(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__UpdateConfig ** p = (_MultiXTpm__UpdateConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__UpdateConfig, sizeof(_MultiXTpm__UpdateConfig), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__GetConfigResponse(struct soap *soap, _MultiXTpm__GetConfigResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__GetConfigResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__GetConfigResponse(struct soap *soap, _MultiXTpm__GetConfigResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__GetConfigResponse);
	if (soap_out_PointerTo_MultiXTpm__GetConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__GetConfigResponse(struct soap *soap, const char *tag, int id, _MultiXTpm__GetConfigResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__GetConfigResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__GetConfigResponse ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__GetConfigResponse(struct soap *soap, _MultiXTpm__GetConfigResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__GetConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__GetConfigResponse ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__GetConfigResponse(struct soap *soap, const char *tag, _MultiXTpm__GetConfigResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__GetConfigResponse **)soap_malloc(soap, sizeof(_MultiXTpm__GetConfigResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__GetConfigResponse *)soap_instantiate__MultiXTpm__GetConfigResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__GetConfigResponse ** p = (_MultiXTpm__GetConfigResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__GetConfigResponse, sizeof(_MultiXTpm__GetConfigResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__GetConfig(struct soap *soap, _MultiXTpm__GetConfig *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__GetConfig))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__GetConfig(struct soap *soap, _MultiXTpm__GetConfig *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__GetConfig);
	if (soap_out_PointerTo_MultiXTpm__GetConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__GetConfig(struct soap *soap, const char *tag, int id, _MultiXTpm__GetConfig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__GetConfig);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__GetConfig ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__GetConfig(struct soap *soap, _MultiXTpm__GetConfig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__GetConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__GetConfig ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__GetConfig(struct soap *soap, const char *tag, _MultiXTpm__GetConfig **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__GetConfig **)soap_malloc(soap, sizeof(_MultiXTpm__GetConfig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__GetConfig *)soap_instantiate__MultiXTpm__GetConfig(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__GetConfig ** p = (_MultiXTpm__GetConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__GetConfig, sizeof(_MultiXTpm__GetConfig), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfInt1(struct soap *soap, MultiXTpm__ArrayOfInt1 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfInt1))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfInt1(struct soap *soap, MultiXTpm__ArrayOfInt1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfInt1);
	if (soap_out_PointerToMultiXTpm__ArrayOfInt1(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfInt1(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfInt1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfInt1);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfInt1 ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfInt1(struct soap *soap, MultiXTpm__ArrayOfInt1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfInt1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfInt1 ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfInt1(struct soap *soap, const char *tag, MultiXTpm__ArrayOfInt1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfInt1 **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfInt1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfInt1 *)soap_instantiate_MultiXTpm__ArrayOfInt1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfInt1 ** p = (MultiXTpm__ArrayOfInt1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfInt1, sizeof(MultiXTpm__ArrayOfInt1), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__SystemStatus(struct soap *soap, MultiXTpm__SystemStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__SystemStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__SystemStatus(struct soap *soap, MultiXTpm__SystemStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__SystemStatus);
	if (soap_out_PointerToMultiXTpm__SystemStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__SystemStatus(struct soap *soap, const char *tag, int id, MultiXTpm__SystemStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__SystemStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__SystemStatus ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__SystemStatus(struct soap *soap, MultiXTpm__SystemStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__SystemStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__SystemStatus ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__SystemStatus(struct soap *soap, const char *tag, MultiXTpm__SystemStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__SystemStatus **)soap_malloc(soap, sizeof(MultiXTpm__SystemStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__SystemStatus *)soap_instantiate_MultiXTpm__SystemStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__SystemStatus ** p = (MultiXTpm__SystemStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__SystemStatus, sizeof(MultiXTpm__SystemStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ConfigData(struct soap *soap, MultiXTpm__ConfigData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ConfigData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ConfigData(struct soap *soap, MultiXTpm__ConfigData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ConfigData);
	if (soap_out_PointerToMultiXTpm__ConfigData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ConfigData(struct soap *soap, const char *tag, int id, MultiXTpm__ConfigData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ConfigData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ConfigData ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ConfigData(struct soap *soap, MultiXTpm__ConfigData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ConfigData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ConfigData ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ConfigData(struct soap *soap, const char *tag, MultiXTpm__ConfigData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ConfigData **)soap_malloc(soap, sizeof(MultiXTpm__ConfigData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ConfigData *)soap_instantiate_MultiXTpm__ConfigData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ConfigData ** p = (MultiXTpm__ConfigData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ConfigData, sizeof(MultiXTpm__ConfigData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ProcessStatus(struct soap *soap, MultiXTpm__ProcessStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ProcessStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ProcessStatus(struct soap *soap, MultiXTpm__ProcessStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ProcessStatus);
	if (soap_out_PointerToMultiXTpm__ProcessStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ProcessStatus(struct soap *soap, const char *tag, int id, MultiXTpm__ProcessStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ProcessStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ProcessStatus ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ProcessStatus(struct soap *soap, MultiXTpm__ProcessStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ProcessStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ProcessStatus ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ProcessStatus(struct soap *soap, const char *tag, MultiXTpm__ProcessStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ProcessStatus **)soap_malloc(soap, sizeof(MultiXTpm__ProcessStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ProcessStatus *)soap_instantiate_MultiXTpm__ProcessStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ProcessStatus ** p = (MultiXTpm__ProcessStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ProcessStatus, sizeof(MultiXTpm__ProcessStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__GroupStatus(struct soap *soap, MultiXTpm__GroupStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__GroupStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__GroupStatus(struct soap *soap, MultiXTpm__GroupStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__GroupStatus);
	if (soap_out_PointerToMultiXTpm__GroupStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__GroupStatus(struct soap *soap, const char *tag, int id, MultiXTpm__GroupStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__GroupStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__GroupStatus ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__GroupStatus(struct soap *soap, MultiXTpm__GroupStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__GroupStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__GroupStatus ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__GroupStatus(struct soap *soap, const char *tag, MultiXTpm__GroupStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__GroupStatus **)soap_malloc(soap, sizeof(MultiXTpm__GroupStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__GroupStatus *)soap_instantiate_MultiXTpm__GroupStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__GroupStatus ** p = (MultiXTpm__GroupStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__GroupStatus, sizeof(MultiXTpm__GroupStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfProcessStatus(struct soap *soap, MultiXTpm__ArrayOfProcessStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfProcessStatus(struct soap *soap, MultiXTpm__ArrayOfProcessStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfProcessStatus);
	if (soap_out_PointerToMultiXTpm__ArrayOfProcessStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfProcessStatus(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfProcessStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfProcessStatus ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfProcessStatus(struct soap *soap, MultiXTpm__ArrayOfProcessStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfProcessStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfProcessStatus ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfProcessStatus(struct soap *soap, const char *tag, MultiXTpm__ArrayOfProcessStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfProcessStatus **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfProcessStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfProcessStatus *)soap_instantiate_MultiXTpm__ArrayOfProcessStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfProcessStatus ** p = (MultiXTpm__ArrayOfProcessStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfProcessStatus, sizeof(MultiXTpm__ArrayOfProcessStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfGroupStatus(struct soap *soap, MultiXTpm__ArrayOfGroupStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfGroupStatus(struct soap *soap, MultiXTpm__ArrayOfGroupStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroupStatus);
	if (soap_out_PointerToMultiXTpm__ArrayOfGroupStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfGroupStatus(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfGroupStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroupStatus ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfGroupStatus(struct soap *soap, MultiXTpm__ArrayOfGroupStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfGroupStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroupStatus ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfGroupStatus(struct soap *soap, const char *tag, MultiXTpm__ArrayOfGroupStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfGroupStatus **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfGroupStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfGroupStatus *)soap_instantiate_MultiXTpm__ArrayOfGroupStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfGroupStatus ** p = (MultiXTpm__ArrayOfGroupStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfGroupStatus, sizeof(MultiXTpm__ArrayOfGroupStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__GroupForwardFlags(struct soap *soap, MultiXTpm__GroupForwardFlags *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__GroupForwardFlags))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__GroupForwardFlags(struct soap *soap, MultiXTpm__GroupForwardFlags *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__GroupForwardFlags);
	if (soap_out_PointerToMultiXTpm__GroupForwardFlags(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__GroupForwardFlags(struct soap *soap, const char *tag, int id, MultiXTpm__GroupForwardFlags *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__GroupForwardFlags);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__GroupForwardFlags ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__GroupForwardFlags(struct soap *soap, MultiXTpm__GroupForwardFlags **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__GroupForwardFlags(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__GroupForwardFlags ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__GroupForwardFlags(struct soap *soap, const char *tag, MultiXTpm__GroupForwardFlags **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__GroupForwardFlags **)soap_malloc(soap, sizeof(MultiXTpm__GroupForwardFlags *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__GroupForwardFlags *)soap_instantiate_MultiXTpm__GroupForwardFlags(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__GroupForwardFlags ** p = (MultiXTpm__GroupForwardFlags **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__GroupForwardFlags, sizeof(MultiXTpm__GroupForwardFlags), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, MultiXTpm__ArrayOfGroupForwardFlags *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, MultiXTpm__ArrayOfGroupForwardFlags *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroupForwardFlags);
	if (soap_out_PointerToMultiXTpm__ArrayOfGroupForwardFlags(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfGroupForwardFlags *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroupForwardFlags ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, MultiXTpm__ArrayOfGroupForwardFlags **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfGroupForwardFlags(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroupForwardFlags ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfGroupForwardFlags(struct soap *soap, const char *tag, MultiXTpm__ArrayOfGroupForwardFlags **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfGroupForwardFlags **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfGroupForwardFlags *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfGroupForwardFlags *)soap_instantiate_MultiXTpm__ArrayOfGroupForwardFlags(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfGroupForwardFlags ** p = (MultiXTpm__ArrayOfGroupForwardFlags **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfGroupForwardFlags, sizeof(MultiXTpm__ArrayOfGroupForwardFlags), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__Message(struct soap *soap, MultiXTpm__Message *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__Message))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__Message(struct soap *soap, MultiXTpm__Message *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__Message);
	if (soap_out_PointerToMultiXTpm__Message(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__Message(struct soap *soap, const char *tag, int id, MultiXTpm__Message *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__Message);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__Message ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__Message(struct soap *soap, MultiXTpm__Message **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__Message ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__Message(struct soap *soap, const char *tag, MultiXTpm__Message **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__Message **)soap_malloc(soap, sizeof(MultiXTpm__Message *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__Message *)soap_instantiate_MultiXTpm__Message(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__Message ** p = (MultiXTpm__Message **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__Message, sizeof(MultiXTpm__Message), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__Group(struct soap *soap, MultiXTpm__Group *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__Group))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__Group(struct soap *soap, MultiXTpm__Group *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__Group);
	if (soap_out_PointerToMultiXTpm__Group(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__Group(struct soap *soap, const char *tag, int id, MultiXTpm__Group *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__Group);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__Group ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__Group(struct soap *soap, MultiXTpm__Group **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__Group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__Group ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__Group(struct soap *soap, const char *tag, MultiXTpm__Group **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__Group **)soap_malloc(soap, sizeof(MultiXTpm__Group *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__Group *)soap_instantiate_MultiXTpm__Group(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__Group ** p = (MultiXTpm__Group **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__Group, sizeof(MultiXTpm__Group), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__SSLParams(struct soap *soap, MultiXTpm__SSLParams *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__SSLParams))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__SSLParams(struct soap *soap, MultiXTpm__SSLParams *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__SSLParams);
	if (soap_out_PointerToMultiXTpm__SSLParams(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__SSLParams(struct soap *soap, const char *tag, int id, MultiXTpm__SSLParams *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__SSLParams);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__SSLParams ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__SSLParams(struct soap *soap, MultiXTpm__SSLParams **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__SSLParams(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__SSLParams ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__SSLParams(struct soap *soap, const char *tag, MultiXTpm__SSLParams **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__SSLParams **)soap_malloc(soap, sizeof(MultiXTpm__SSLParams *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__SSLParams *)soap_instantiate_MultiXTpm__SSLParams(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__SSLParams ** p = (MultiXTpm__SSLParams **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__SSLParams, sizeof(MultiXTpm__SSLParams), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__Link(struct soap *soap, MultiXTpm__Link *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__Link))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__Link(struct soap *soap, MultiXTpm__Link *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__Link);
	if (soap_out_PointerToMultiXTpm__Link(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__Link(struct soap *soap, const char *tag, int id, MultiXTpm__Link *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__Link);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__Link ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__Link(struct soap *soap, MultiXTpm__Link **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__Link(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__Link ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__Link(struct soap *soap, const char *tag, MultiXTpm__Link **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__Link **)soap_malloc(soap, sizeof(MultiXTpm__Link *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__Link *)soap_instantiate_MultiXTpm__Link(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__Link ** p = (MultiXTpm__Link **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__Link, sizeof(MultiXTpm__Link), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_MultiXTpm__Param_XmlParamValue(struct soap *soap, _MultiXTpm__Param_XmlParamValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__MultiXTpm__Param_XmlParamValue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_MultiXTpm__Param_XmlParamValue(struct soap *soap, _MultiXTpm__Param_XmlParamValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_MultiXTpm__Param_XmlParamValue);
	if (soap_out_PointerTo_MultiXTpm__Param_XmlParamValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_MultiXTpm__Param_XmlParamValue(struct soap *soap, const char *tag, int id, _MultiXTpm__Param_XmlParamValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__MultiXTpm__Param_XmlParamValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _MultiXTpm__Param_XmlParamValue ** SOAP_FMAC4 soap_get_PointerTo_MultiXTpm__Param_XmlParamValue(struct soap *soap, _MultiXTpm__Param_XmlParamValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_MultiXTpm__Param_XmlParamValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _MultiXTpm__Param_XmlParamValue ** SOAP_FMAC4 soap_in_PointerTo_MultiXTpm__Param_XmlParamValue(struct soap *soap, const char *tag, _MultiXTpm__Param_XmlParamValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_MultiXTpm__Param_XmlParamValue **)soap_malloc(soap, sizeof(_MultiXTpm__Param_XmlParamValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_MultiXTpm__Param_XmlParamValue *)soap_instantiate__MultiXTpm__Param_XmlParamValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_MultiXTpm__Param_XmlParamValue ** p = (_MultiXTpm__Param_XmlParamValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__MultiXTpm__Param_XmlParamValue, sizeof(_MultiXTpm__Param_XmlParamValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__Param(struct soap *soap, MultiXTpm__Param *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__Param))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__Param(struct soap *soap, MultiXTpm__Param *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__Param);
	if (soap_out_PointerToMultiXTpm__Param(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__Param(struct soap *soap, const char *tag, int id, MultiXTpm__Param *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__Param);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__Param ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__Param(struct soap *soap, MultiXTpm__Param **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__Param(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__Param ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__Param(struct soap *soap, const char *tag, MultiXTpm__Param **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__Param **)soap_malloc(soap, sizeof(MultiXTpm__Param *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__Param *)soap_instantiate_MultiXTpm__Param(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__Param ** p = (MultiXTpm__Param **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__Param, sizeof(MultiXTpm__Param), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfInt(struct soap *soap, MultiXTpm__ArrayOfInt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfInt))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfInt(struct soap *soap, MultiXTpm__ArrayOfInt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfInt);
	if (soap_out_PointerToMultiXTpm__ArrayOfInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfInt(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfInt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfInt);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfInt ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfInt(struct soap *soap, MultiXTpm__ArrayOfInt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfInt ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfInt(struct soap *soap, const char *tag, MultiXTpm__ArrayOfInt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfInt **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfInt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfInt *)soap_instantiate_MultiXTpm__ArrayOfInt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfInt ** p = (MultiXTpm__ArrayOfInt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfInt, sizeof(MultiXTpm__ArrayOfInt), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfParam(struct soap *soap, MultiXTpm__ArrayOfParam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfParam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfParam(struct soap *soap, MultiXTpm__ArrayOfParam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfParam);
	if (soap_out_PointerToMultiXTpm__ArrayOfParam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfParam(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfParam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfParam ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfParam(struct soap *soap, MultiXTpm__ArrayOfParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfParam(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfParam ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfParam(struct soap *soap, const char *tag, MultiXTpm__ArrayOfParam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfParam **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfParam *)soap_instantiate_MultiXTpm__ArrayOfParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfParam ** p = (MultiXTpm__ArrayOfParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfParam, sizeof(MultiXTpm__ArrayOfParam), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ProcessClass(struct soap *soap, MultiXTpm__ProcessClass *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ProcessClass))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ProcessClass(struct soap *soap, MultiXTpm__ProcessClass *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ProcessClass);
	if (soap_out_PointerToMultiXTpm__ProcessClass(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ProcessClass(struct soap *soap, const char *tag, int id, MultiXTpm__ProcessClass *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ProcessClass);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ProcessClass ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ProcessClass(struct soap *soap, MultiXTpm__ProcessClass **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ProcessClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ProcessClass ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ProcessClass(struct soap *soap, const char *tag, MultiXTpm__ProcessClass **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ProcessClass **)soap_malloc(soap, sizeof(MultiXTpm__ProcessClass *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ProcessClass *)soap_instantiate_MultiXTpm__ProcessClass(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ProcessClass ** p = (MultiXTpm__ProcessClass **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ProcessClass, sizeof(MultiXTpm__ProcessClass), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__UserPermission(struct soap *soap, MultiXTpm__UserPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__UserPermission))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__UserPermission(struct soap *soap, MultiXTpm__UserPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__UserPermission);
	if (soap_out_PointerToMultiXTpm__UserPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__UserPermission(struct soap *soap, const char *tag, int id, MultiXTpm__UserPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__UserPermission);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__UserPermission ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__UserPermission(struct soap *soap, MultiXTpm__UserPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__UserPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__UserPermission ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__UserPermission(struct soap *soap, const char *tag, MultiXTpm__UserPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__UserPermission **)soap_malloc(soap, sizeof(MultiXTpm__UserPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__UserPermission *)soap_instantiate_MultiXTpm__UserPermission(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__UserPermission ** p = (MultiXTpm__UserPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__UserPermission, sizeof(MultiXTpm__UserPermission), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfUserPermission(struct soap *soap, MultiXTpm__ArrayOfUserPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfUserPermission))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfUserPermission(struct soap *soap, MultiXTpm__ArrayOfUserPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfUserPermission);
	if (soap_out_PointerToMultiXTpm__ArrayOfUserPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfUserPermission(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfUserPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfUserPermission);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfUserPermission ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfUserPermission(struct soap *soap, MultiXTpm__ArrayOfUserPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfUserPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfUserPermission ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfUserPermission(struct soap *soap, const char *tag, MultiXTpm__ArrayOfUserPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfUserPermission **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfUserPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfUserPermission *)soap_instantiate_MultiXTpm__ArrayOfUserPermission(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfUserPermission ** p = (MultiXTpm__ArrayOfUserPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfUserPermission, sizeof(MultiXTpm__ArrayOfUserPermission), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfMessage(struct soap *soap, MultiXTpm__ArrayOfMessage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfMessage))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfMessage(struct soap *soap, MultiXTpm__ArrayOfMessage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfMessage);
	if (soap_out_PointerToMultiXTpm__ArrayOfMessage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfMessage(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfMessage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfMessage ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfMessage(struct soap *soap, MultiXTpm__ArrayOfMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfMessage ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfMessage(struct soap *soap, const char *tag, MultiXTpm__ArrayOfMessage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfMessage **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfMessage *)soap_instantiate_MultiXTpm__ArrayOfMessage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfMessage ** p = (MultiXTpm__ArrayOfMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfMessage, sizeof(MultiXTpm__ArrayOfMessage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfGroup(struct soap *soap, MultiXTpm__ArrayOfGroup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfGroup))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfGroup(struct soap *soap, MultiXTpm__ArrayOfGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfGroup);
	if (soap_out_PointerToMultiXTpm__ArrayOfGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfGroup(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroup ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfGroup(struct soap *soap, MultiXTpm__ArrayOfGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfGroup ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfGroup(struct soap *soap, const char *tag, MultiXTpm__ArrayOfGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfGroup **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfGroup *)soap_instantiate_MultiXTpm__ArrayOfGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfGroup ** p = (MultiXTpm__ArrayOfGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfGroup, sizeof(MultiXTpm__ArrayOfGroup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfLink(struct soap *soap, MultiXTpm__ArrayOfLink *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfLink))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfLink(struct soap *soap, MultiXTpm__ArrayOfLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfLink);
	if (soap_out_PointerToMultiXTpm__ArrayOfLink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfLink(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfLink);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfLink ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfLink(struct soap *soap, MultiXTpm__ArrayOfLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfLink ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfLink(struct soap *soap, const char *tag, MultiXTpm__ArrayOfLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfLink **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfLink *)soap_instantiate_MultiXTpm__ArrayOfLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfLink ** p = (MultiXTpm__ArrayOfLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfLink, sizeof(MultiXTpm__ArrayOfLink), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMultiXTpm__ArrayOfProcessClass(struct soap *soap, MultiXTpm__ArrayOfProcessClass *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_MultiXTpm__ArrayOfProcessClass))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMultiXTpm__ArrayOfProcessClass(struct soap *soap, MultiXTpm__ArrayOfProcessClass *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToMultiXTpm__ArrayOfProcessClass);
	if (soap_out_PointerToMultiXTpm__ArrayOfProcessClass(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMultiXTpm__ArrayOfProcessClass(struct soap *soap, const char *tag, int id, MultiXTpm__ArrayOfProcessClass *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_MultiXTpm__ArrayOfProcessClass);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 MultiXTpm__ArrayOfProcessClass ** SOAP_FMAC4 soap_get_PointerToMultiXTpm__ArrayOfProcessClass(struct soap *soap, MultiXTpm__ArrayOfProcessClass **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMultiXTpm__ArrayOfProcessClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 MultiXTpm__ArrayOfProcessClass ** SOAP_FMAC4 soap_in_PointerToMultiXTpm__ArrayOfProcessClass(struct soap *soap, const char *tag, MultiXTpm__ArrayOfProcessClass **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (MultiXTpm__ArrayOfProcessClass **)soap_malloc(soap, sizeof(MultiXTpm__ArrayOfProcessClass *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (MultiXTpm__ArrayOfProcessClass *)soap_instantiate_MultiXTpm__ArrayOfProcessClass(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	MultiXTpm__ArrayOfProcessClass ** p = (MultiXTpm__ArrayOfProcessClass **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MultiXTpm__ArrayOfProcessClass, sizeof(MultiXTpm__ArrayOfProcessClass), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(struct soap *soap, std::vector<MultiXTpm__ProcessStatus * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(struct soap *soap, const std::vector<MultiXTpm__ProcessStatus * >*a)
{
	for (std::vector<MultiXTpm__ProcessStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToMultiXTpm__ProcessStatus(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(struct soap *soap, const char *tag, int id, const std::vector<MultiXTpm__ProcessStatus * >*a, const char *type)
{
	for (std::vector<MultiXTpm__ProcessStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToMultiXTpm__ProcessStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<MultiXTpm__ProcessStatus * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(struct soap *soap, const char *tag, std::vector<MultiXTpm__ProcessStatus * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(soap, -1)))
		return NULL;
	MultiXTpm__ProcessStatus *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_MultiXTpm__ProcessStatus, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus, sizeof(MultiXTpm__ProcessStatus), 1))
				break;
			if (!soap_in_PointerToMultiXTpm__ProcessStatus(soap, tag, NULL, "MultiXTpm:ProcessStatus"))
				break;
		}
		else
		{
			if (!soap_in_PointerToMultiXTpm__ProcessStatus(soap, tag, &n, "MultiXTpm:ProcessStatus"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<MultiXTpm__ProcessStatus * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(struct soap *soap, std::vector<MultiXTpm__ProcessStatus * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<MultiXTpm__ProcessStatus * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<MultiXTpm__ProcessStatus * >;
		if (size)
			*size = sizeof(std::vector<MultiXTpm__ProcessStatus * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<MultiXTpm__ProcessStatus * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<MultiXTpm__ProcessStatus * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<MultiXTpm__ProcessStatus * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToMultiXTpm__ProcessStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<MultiXTpm__ProcessStatus * > %p -> %p\n", q, p));
	*(std::vector<MultiXTpm__ProcessStatus * >*)p = *(std::vector<MultiXTpm__ProcessStatus * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(struct soap *soap, std::vector<MultiXTpm__GroupStatus * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(struct soap *soap, const std::vector<MultiXTpm__GroupStatus * >*a)
{
	for (std::vector<MultiXTpm__GroupStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToMultiXTpm__GroupStatus(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(struct soap *soap, const char *tag, int id, const std::vector<MultiXTpm__GroupStatus * >*a, const char *type)
{
	for (std::vector<MultiXTpm__GroupStatus * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToMultiXTpm__GroupStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<MultiXTpm__GroupStatus * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(struct soap *soap, const char *tag, std::vector<MultiXTpm__GroupStatus * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(soap, -1)))
		return NULL;
	MultiXTpm__GroupStatus *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_MultiXTpm__GroupStatus, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus, sizeof(MultiXTpm__GroupStatus), 1))
				break;
			if (!soap_in_PointerToMultiXTpm__GroupStatus(soap, tag, NULL, "MultiXTpm:GroupStatus"))
				break;
		}
		else
		{
			if (!soap_in_PointerToMultiXTpm__GroupStatus(soap, tag, &n, "MultiXTpm:GroupStatus"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<MultiXTpm__GroupStatus * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(struct soap *soap, std::vector<MultiXTpm__GroupStatus * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<MultiXTpm__GroupStatus * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<MultiXTpm__GroupStatus * >;
		if (size)
			*size = sizeof(std::vector<MultiXTpm__GroupStatus * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<MultiXTpm__GroupStatus * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<MultiXTpm__GroupStatus * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<MultiXTpm__GroupStatus * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToMultiXTpm__GroupStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<MultiXTpm__GroupStatus * > %p -> %p\n", q, p));
	*(std::vector<MultiXTpm__GroupStatus * >*)p = *(std::vector<MultiXTpm__GroupStatus * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(struct soap *soap, std::vector<MultiXTpm__GroupForwardFlags * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(struct soap *soap, const std::vector<MultiXTpm__GroupForwardFlags * >*a)
{
	for (std::vector<MultiXTpm__GroupForwardFlags * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToMultiXTpm__GroupForwardFlags(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(struct soap *soap, const char *tag, int id, const std::vector<MultiXTpm__GroupForwardFlags * >*a, const char *type)
{
	for (std::vector<MultiXTpm__GroupForwardFlags * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToMultiXTpm__GroupForwardFlags(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<MultiXTpm__GroupForwardFlags * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(struct soap *soap, const char *tag, std::vector<MultiXTpm__GroupForwardFlags * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(soap, -1)))
		return NULL;
	MultiXTpm__GroupForwardFlags *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_MultiXTpm__GroupForwardFlags, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags, sizeof(MultiXTpm__GroupForwardFlags), 1))
				break;
			if (!soap_in_PointerToMultiXTpm__GroupForwardFlags(soap, tag, NULL, "MultiXTpm:GroupForwardFlags"))
				break;
		}
		else
		{
			if (!soap_in_PointerToMultiXTpm__GroupForwardFlags(soap, tag, &n, "MultiXTpm:GroupForwardFlags"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<MultiXTpm__GroupForwardFlags * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(struct soap *soap, std::vector<MultiXTpm__GroupForwardFlags * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<MultiXTpm__GroupForwardFlags * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<MultiXTpm__GroupForwardFlags * >;
		if (size)
			*size = sizeof(std::vector<MultiXTpm__GroupForwardFlags * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<MultiXTpm__GroupForwardFlags * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<MultiXTpm__GroupForwardFlags * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<MultiXTpm__GroupForwardFlags * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToMultiXTpm__GroupForwardFlags(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<MultiXTpm__GroupForwardFlags * > %p -> %p\n", q, p));
	*(std::vector<MultiXTpm__GroupForwardFlags * >*)p = *(std::vector<MultiXTpm__GroupForwardFlags * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToMultiXTpm__Message(struct soap *soap, std::vector<MultiXTpm__Message * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__Message(struct soap *soap, const std::vector<MultiXTpm__Message * >*a)
{
	for (std::vector<MultiXTpm__Message * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToMultiXTpm__Message(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToMultiXTpm__Message(struct soap *soap, const char *tag, int id, const std::vector<MultiXTpm__Message * >*a, const char *type)
{
	for (std::vector<MultiXTpm__Message * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToMultiXTpm__Message(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<MultiXTpm__Message * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToMultiXTpm__Message(struct soap *soap, const char *tag, std::vector<MultiXTpm__Message * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToMultiXTpm__Message(soap, -1)))
		return NULL;
	MultiXTpm__Message *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_MultiXTpm__Message, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Message, sizeof(MultiXTpm__Message), 1))
				break;
			if (!soap_in_PointerToMultiXTpm__Message(soap, tag, NULL, "MultiXTpm:Message"))
				break;
		}
		else
		{
			if (!soap_in_PointerToMultiXTpm__Message(soap, tag, &n, "MultiXTpm:Message"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<MultiXTpm__Message * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToMultiXTpm__Message(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Message(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToMultiXTpm__Message(struct soap *soap, std::vector<MultiXTpm__Message * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<MultiXTpm__Message * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Message(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Message(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Message, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<MultiXTpm__Message * >;
		if (size)
			*size = sizeof(std::vector<MultiXTpm__Message * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<MultiXTpm__Message * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<MultiXTpm__Message * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<MultiXTpm__Message * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToMultiXTpm__Message(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<MultiXTpm__Message * > %p -> %p\n", q, p));
	*(std::vector<MultiXTpm__Message * >*)p = *(std::vector<MultiXTpm__Message * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToMultiXTpm__Group(struct soap *soap, std::vector<MultiXTpm__Group * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__Group(struct soap *soap, const std::vector<MultiXTpm__Group * >*a)
{
	for (std::vector<MultiXTpm__Group * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToMultiXTpm__Group(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToMultiXTpm__Group(struct soap *soap, const char *tag, int id, const std::vector<MultiXTpm__Group * >*a, const char *type)
{
	for (std::vector<MultiXTpm__Group * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToMultiXTpm__Group(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<MultiXTpm__Group * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToMultiXTpm__Group(struct soap *soap, const char *tag, std::vector<MultiXTpm__Group * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToMultiXTpm__Group(soap, -1)))
		return NULL;
	MultiXTpm__Group *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_MultiXTpm__Group, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Group, sizeof(MultiXTpm__Group), 1))
				break;
			if (!soap_in_PointerToMultiXTpm__Group(soap, tag, NULL, "MultiXTpm:Group"))
				break;
		}
		else
		{
			if (!soap_in_PointerToMultiXTpm__Group(soap, tag, &n, "MultiXTpm:Group"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<MultiXTpm__Group * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToMultiXTpm__Group(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Group(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToMultiXTpm__Group(struct soap *soap, std::vector<MultiXTpm__Group * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<MultiXTpm__Group * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Group(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Group, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<MultiXTpm__Group * >;
		if (size)
			*size = sizeof(std::vector<MultiXTpm__Group * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<MultiXTpm__Group * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<MultiXTpm__Group * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<MultiXTpm__Group * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToMultiXTpm__Group(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<MultiXTpm__Group * > %p -> %p\n", q, p));
	*(std::vector<MultiXTpm__Group * >*)p = *(std::vector<MultiXTpm__Group * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToMultiXTpm__Link(struct soap *soap, std::vector<MultiXTpm__Link * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__Link(struct soap *soap, const std::vector<MultiXTpm__Link * >*a)
{
	for (std::vector<MultiXTpm__Link * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToMultiXTpm__Link(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToMultiXTpm__Link(struct soap *soap, const char *tag, int id, const std::vector<MultiXTpm__Link * >*a, const char *type)
{
	for (std::vector<MultiXTpm__Link * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToMultiXTpm__Link(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<MultiXTpm__Link * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToMultiXTpm__Link(struct soap *soap, const char *tag, std::vector<MultiXTpm__Link * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToMultiXTpm__Link(soap, -1)))
		return NULL;
	MultiXTpm__Link *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_MultiXTpm__Link, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Link, sizeof(MultiXTpm__Link), 1))
				break;
			if (!soap_in_PointerToMultiXTpm__Link(soap, tag, NULL, "MultiXTpm:Link"))
				break;
		}
		else
		{
			if (!soap_in_PointerToMultiXTpm__Link(soap, tag, &n, "MultiXTpm:Link"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<MultiXTpm__Link * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToMultiXTpm__Link(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Link(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToMultiXTpm__Link(struct soap *soap, std::vector<MultiXTpm__Link * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<MultiXTpm__Link * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Link(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Link(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Link, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<MultiXTpm__Link * >;
		if (size)
			*size = sizeof(std::vector<MultiXTpm__Link * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<MultiXTpm__Link * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<MultiXTpm__Link * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<MultiXTpm__Link * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToMultiXTpm__Link(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<MultiXTpm__Link * > %p -> %p\n", q, p));
	*(std::vector<MultiXTpm__Link * >*)p = *(std::vector<MultiXTpm__Link * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_int(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<int > * SOAP_FMAC6 soap_new_std__vectorTemplateOfint(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<int > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<int >;
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)new std::vector<int >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
		return NULL;
	char *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{
			if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char * > * SOAP_FMAC6 soap_new_std__vectorTemplateOf_XML(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOf_XML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<char * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char * >;
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToMultiXTpm__Param(struct soap *soap, std::vector<MultiXTpm__Param * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__Param(struct soap *soap, const std::vector<MultiXTpm__Param * >*a)
{
	for (std::vector<MultiXTpm__Param * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToMultiXTpm__Param(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToMultiXTpm__Param(struct soap *soap, const char *tag, int id, const std::vector<MultiXTpm__Param * >*a, const char *type)
{
	for (std::vector<MultiXTpm__Param * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToMultiXTpm__Param(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<MultiXTpm__Param * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToMultiXTpm__Param(struct soap *soap, const char *tag, std::vector<MultiXTpm__Param * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToMultiXTpm__Param(soap, -1)))
		return NULL;
	MultiXTpm__Param *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_MultiXTpm__Param, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Param, sizeof(MultiXTpm__Param), 1))
				break;
			if (!soap_in_PointerToMultiXTpm__Param(soap, tag, NULL, "MultiXTpm:Param"))
				break;
		}
		else
		{
			if (!soap_in_PointerToMultiXTpm__Param(soap, tag, &n, "MultiXTpm:Param"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<MultiXTpm__Param * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToMultiXTpm__Param(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Param(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToMultiXTpm__Param(struct soap *soap, std::vector<MultiXTpm__Param * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<MultiXTpm__Param * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Param(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__Param(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__Param, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<MultiXTpm__Param * >;
		if (size)
			*size = sizeof(std::vector<MultiXTpm__Param * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<MultiXTpm__Param * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<MultiXTpm__Param * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<MultiXTpm__Param * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToMultiXTpm__Param(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<MultiXTpm__Param * > %p -> %p\n", q, p));
	*(std::vector<MultiXTpm__Param * >*)p = *(std::vector<MultiXTpm__Param * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(struct soap *soap, std::vector<MultiXTpm__ProcessClass * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(struct soap *soap, const std::vector<MultiXTpm__ProcessClass * >*a)
{
	for (std::vector<MultiXTpm__ProcessClass * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToMultiXTpm__ProcessClass(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(struct soap *soap, const char *tag, int id, const std::vector<MultiXTpm__ProcessClass * >*a, const char *type)
{
	for (std::vector<MultiXTpm__ProcessClass * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToMultiXTpm__ProcessClass(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<MultiXTpm__ProcessClass * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(struct soap *soap, const char *tag, std::vector<MultiXTpm__ProcessClass * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(soap, -1)))
		return NULL;
	MultiXTpm__ProcessClass *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_MultiXTpm__ProcessClass, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass, sizeof(MultiXTpm__ProcessClass), 1))
				break;
			if (!soap_in_PointerToMultiXTpm__ProcessClass(soap, tag, NULL, "MultiXTpm:ProcessClass"))
				break;
		}
		else
		{
			if (!soap_in_PointerToMultiXTpm__ProcessClass(soap, tag, &n, "MultiXTpm:ProcessClass"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<MultiXTpm__ProcessClass * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(struct soap *soap, std::vector<MultiXTpm__ProcessClass * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<MultiXTpm__ProcessClass * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<MultiXTpm__ProcessClass * >;
		if (size)
			*size = sizeof(std::vector<MultiXTpm__ProcessClass * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<MultiXTpm__ProcessClass * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<MultiXTpm__ProcessClass * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<MultiXTpm__ProcessClass * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToMultiXTpm__ProcessClass(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<MultiXTpm__ProcessClass * > %p -> %p\n", q, p));
	*(std::vector<MultiXTpm__ProcessClass * >*)p = *(std::vector<MultiXTpm__ProcessClass * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(struct soap *soap, std::vector<MultiXTpm__UserPermission * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(struct soap *soap, const std::vector<MultiXTpm__UserPermission * >*a)
{
	for (std::vector<MultiXTpm__UserPermission * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToMultiXTpm__UserPermission(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(struct soap *soap, const char *tag, int id, const std::vector<MultiXTpm__UserPermission * >*a, const char *type)
{
	for (std::vector<MultiXTpm__UserPermission * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToMultiXTpm__UserPermission(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<MultiXTpm__UserPermission * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(struct soap *soap, const char *tag, std::vector<MultiXTpm__UserPermission * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(soap, -1)))
		return NULL;
	MultiXTpm__UserPermission *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_MultiXTpm__UserPermission, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__UserPermission, sizeof(MultiXTpm__UserPermission), 1))
				break;
			if (!soap_in_PointerToMultiXTpm__UserPermission(soap, tag, NULL, "MultiXTpm:UserPermission"))
				break;
		}
		else
		{
			if (!soap_in_PointerToMultiXTpm__UserPermission(soap, tag, &n, "MultiXTpm:UserPermission"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<MultiXTpm__UserPermission * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(struct soap *soap, std::vector<MultiXTpm__UserPermission * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<MultiXTpm__UserPermission * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToMultiXTpm__UserPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<MultiXTpm__UserPermission * >;
		if (size)
			*size = sizeof(std::vector<MultiXTpm__UserPermission * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<MultiXTpm__UserPermission * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<MultiXTpm__UserPermission * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<MultiXTpm__UserPermission * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToMultiXTpm__UserPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<MultiXTpm__UserPermission * > %p -> %p\n", q, p));
	*(std::vector<MultiXTpm__UserPermission * >*)p = *(std::vector<MultiXTpm__UserPermission * >*)q;
}

/* End of gSoapMultiXTpmC.cpp */
