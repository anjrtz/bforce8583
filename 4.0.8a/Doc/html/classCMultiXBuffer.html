<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MultiX: CMultiXBuffer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>CMultiXBuffer Class Reference</h1><!-- doxytag: class="CMultiXBuffer" --><a href="classCMultiXBuffer-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
This class provides the means for managing buffer space and buffer pool. It encapsulate the logic for allocating memory, accessing the underlying memory space and adding and removing from a pool. <a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> objects are allocated one using <a class="el" href="classCMultiXApp.html#6d691761e088b749cbbfbfff26b9a775">CMultiXApp::AllocateBuffer()</a> and never freed until the process terminates. When the application does not need the buffer anymore, it returns it to a pool by calling <a class="el" href="classCMultiXBuffer.html#dcdbfa5c6971c2abe82c8fd43c03c9da">ReturnBuffer()</a>, the application has no access to the destractor of the class. A buffer that was returned to the pool, will be used on the next allocate request. <a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> is thread safe object, this means that an application can access the same object from multiple threads. If the application needs to keep multiple pointers to the same object, the application must <a class="el" href="classCMultiXBuffer.html#9db5467d2c3a7ca9e95e8b16d9618b00">Clone()</a> the object and when it not needed any more it must be "returned". 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#d39c6a22731b131b6da56b5292294961">UpdateLengthNoLock</a> (int32_t Value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates the length of the actual data in the buffer.  <a href="#d39c6a22731b131b6da56b5292294961"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#675716ede9fb91c43aeba3cfddeb3e7a">GetDataNoLock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the underline buffer, used for modification of the data, not thread safe. </dd></dl>
 <a href="#675716ede9fb91c43aeba3cfddeb3e7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#9db5467d2c3a7ca9e95e8b16d9618b00">Clone</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>apointer to the same object and incrementing the reference count. </dd></dl>
 <a href="#9db5467d2c3a7ca9e95e8b16d9618b00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#62dd44915baef87214cb3ebaa9e3728d">Unlock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlocks the object that was locked with <a class="el" href="classCMultiXBuffer.html#d874aff45f8694d42de7df2b3f51e69e">LockData()</a>, frees other threads to manipulate the object.  <a href="#62dd44915baef87214cb3ebaa9e3728d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#df55cacfe73e0a5e65994cfa380d90d3">CreateNew</a> (bool bDuplicate=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> object.  <a href="#df55cacfe73e0a5e65994cfa380d90d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#84baa279098f711f3381c92519aba773">Mid</a> (int StartPos, int Len=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new <a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> object and copies the specified range of data to the new object.  <a href="#84baa279098f711f3381c92519aba773"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#6e77e668a0302498f99b798bcd0c27dc">ReleaseData</a> (int NewLength)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the object an updates its length to NewLength.  <a href="#6e77e668a0302498f99b798bcd0c27dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#d874aff45f8694d42de7df2b3f51e69e">LockData</a> (int MinSize=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock the underlying buffer for exclusive update.  <a href="#d874aff45f8694d42de7df2b3f51e69e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#199141460d3016588271071c99157629">Expand</a> (int NewSize, bool bUpdateLength, bool bWithLock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">expand the size of the underlying buffer.  <a href="#199141460d3016588271071c99157629"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#dcdbfa5c6971c2abe82c8fd43c03c9da">ReturnBuffer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the buffer to the pool.  <a href="#dcdbfa5c6971c2abe82c8fd43c03c9da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#563c3a63fd0d2ebc54f079ff7c746a89">Size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The allocated size of the underlying buffer. </dd></dl>
 <a href="#563c3a63fd0d2ebc54f079ff7c746a89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#b512e2c0365e95f4cab4eaef48b6f1e9">Length</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><dl class="return" compact><dt><b>Returns:</b></dt><dd>The length of data stored in the underlying buffer. </dd></dl>
 <a href="#b512e2c0365e95f4cab4eaef48b6f1e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#4aab0d6dbde2346da7a25133603b9b59">DataPtr</a> (int index=0) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get read access to the data in the underlying buffer.  <a href="#4aab0d6dbde2346da7a25133603b9b59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#3238519ac41d55d4cf40c75f9c674d0e">AppendData</a> (const char_t *Data, int Size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the provided data to the underlying buffer.  <a href="#3238519ac41d55d4cf40c75f9c674d0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#e69c4160ab57c26578fbd22a110e5419">AppendString</a> (const char_t *StringData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the provided string to the underlying buffer.  <a href="#e69c4160ab57c26578fbd22a110e5419"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#7086802ec19f7814777972640ddabaad">AppendBuffer</a> (<a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> &amp;Buffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the provided <a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> to the underlying buffer.  <a href="#7086802ec19f7814777972640ddabaad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#b3fa767fc792c89ea410260cd3ee8259">operator&lt;&lt;=</a> (int ShiftCount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift the content of the underlying buffer to the left.  <a href="#b3fa767fc792c89ea410260cd3ee8259"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#13464171f4a77ce9582b6d6c351bd218">operator&gt;&gt;=</a> (int ShiftCount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift the content of the underlying buffer to the right.  <a href="#13464171f4a77ce9582b6d6c351bd218"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#049fec9609d27ea69fe3a73de5af843a">Empty</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the content of the buffer and sets the length to zero.  <a href="#049fec9609d27ea69fe3a73de5af843a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCMultiXBuffer.html#05edd78373da9136f92d45a07519e0c3">operator==</a> (<a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> &amp;Other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the content of 2 buffers.  <a href="#05edd78373da9136f92d45a07519e0c3"></a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d39c6a22731b131b6da56b5292294961"></a><!-- doxytag: member="CMultiXBuffer::UpdateLengthNoLock" ref="d39c6a22731b131b6da56b5292294961" args="(int32_t Value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMultiXBuffer::UpdateLengthNoLock           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>Value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Updates the length of the actual data in the buffer. 
<p>
This function will update the length of the data, but without locking the object. This means that application must assume that no other thread is using the same buffer at the same time. This call used to enhance performance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>The new length of the buffer, it must not exceede the value used in <a class="el" href="classCMultiXApp.html#6d691761e088b749cbbfbfff26b9a775">CMultiXApp::AllocateBuffer()</a> or the <a class="el" href="classCMultiXBuffer.html#199141460d3016588271071c99157629">Expand()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="675716ede9fb91c43aeba3cfddeb3e7a"></a><!-- doxytag: member="CMultiXBuffer::GetDataNoLock" ref="675716ede9fb91c43aeba3cfddeb3e7a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char_t* CMultiXBuffer::GetDataNoLock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the underline buffer, used for modification of the data, not thread safe. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="9db5467d2c3a7ca9e95e8b16d9618b00"></a><!-- doxytag: member="CMultiXBuffer::Clone" ref="9db5467d2c3a7ca9e95e8b16d9618b00" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a>* CMultiXBuffer::Clone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>apointer to the same object and incrementing the reference count. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="62dd44915baef87214cb3ebaa9e3728d"></a><!-- doxytag: member="CMultiXBuffer::Unlock" ref="62dd44915baef87214cb3ebaa9e3728d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMultiXBuffer::Unlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks the object that was locked with <a class="el" href="classCMultiXBuffer.html#d874aff45f8694d42de7df2b3f51e69e">LockData()</a>, frees other threads to manipulate the object. 
<p>

</div>
</div><p>
<a class="anchor" name="df55cacfe73e0a5e65994cfa380d90d3"></a><!-- doxytag: member="CMultiXBuffer::CreateNew" ref="df55cacfe73e0a5e65994cfa380d90d3" args="(bool bDuplicate=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a>* CMultiXBuffer::CreateNew           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bDuplicate</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new <a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> object. 
<p>
This function creates a new object and if specified, copies the data from the current object. After the duplicate, both objects are not related anymore. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bDuplicate</em>&nbsp;</td><td>if true, copies the content of the current object to the newly created object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the newly created object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="84baa279098f711f3381c92519aba773"></a><!-- doxytag: member="CMultiXBuffer::Mid" ref="84baa279098f711f3381c92519aba773" args="(int StartPos, int Len=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a>* CMultiXBuffer::Mid           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>StartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Len</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new <a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> object and copies the specified range of data to the new object. 
<p>
This function creates a new object and if specified, copies the data from the current object. After the duplicate, both objects are not related anymore. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>StartPos</em>&nbsp;</td><td>the index of the first byte to be copied to the new object. if this value is greater the the length of the current buffer, an empty object will be returned (not NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Len</em>&nbsp;</td><td>the number of bytes to copy to the new object. if there are not enough bytes to copy, a smaller amount will be copied. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the newly created object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6e77e668a0302498f99b798bcd0c27dc"></a><!-- doxytag: member="CMultiXBuffer::ReleaseData" ref="6e77e668a0302498f99b798bcd0c27dc" args="(int NewLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMultiXBuffer::ReleaseData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>NewLength</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlock the object an updates its length to NewLength. 
<p>
This function can be called only if it was lock by <a class="el" href="classCMultiXBuffer.html#d874aff45f8694d42de7df2b3f51e69e">LockData()</a>, otherwise an exception is raised. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NewLength</em>&nbsp;</td><td>The new length of the actual data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d874aff45f8694d42de7df2b3f51e69e"></a><!-- doxytag: member="CMultiXBuffer::LockData" ref="d874aff45f8694d42de7df2b3f51e69e" args="(int MinSize=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char_t* CMultiXBuffer::LockData           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>MinSize</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock the underlying buffer for exclusive update. 
<p>
When there is a need to update the underlying buffer, this function is called. If there is a need to ensure the minimum size of the underlying buffer, MinSize is provider. Once the pointer is returned, no other thread can access the object or its clones until Releasedata() or <a class="el" href="classCMultiXBuffer.html#62dd44915baef87214cb3ebaa9e3728d">Unlock()</a> is called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>MinSize</em>&nbsp;</td><td>the minimum size required for the underlying buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the underlying buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="199141460d3016588271071c99157629"></a><!-- doxytag: member="CMultiXBuffer::Expand" ref="199141460d3016588271071c99157629" args="(int NewSize, bool bUpdateLength, bool bWithLock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMultiXBuffer::Expand           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>NewSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bUpdateLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bWithLock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
expand the size of the underlying buffer. 
<p>
Use this function to expand the size of the underlying buffer when there is a need to add data to the underlying buffer. Besides reallocating the underlying buffer, by specifying bUpdateLength, the application tells MultiX to set the length of the data to the size of the buffer, usually, the size of the buffer is larger than the actual data that it stores. If there is a need to ensure that no other thread accesses the object at the time of the expand , set bWithLock to true. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NewSize</em>&nbsp;</td><td>Reallocate the buffer to the new size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bUpdateLength</em>&nbsp;</td><td>Set the length of data to the buffer size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bWithLock</em>&nbsp;</td><td>Lock the object to ensure exclusive access while updating the object size. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dcdbfa5c6971c2abe82c8fd43c03c9da"></a><!-- doxytag: member="CMultiXBuffer::ReturnBuffer" ref="dcdbfa5c6971c2abe82c8fd43c03c9da" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMultiXBuffer::ReturnBuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the buffer to the pool. 
<p>
Once returned, the application should not use the pointer and it should treat it as a deleted object. 
</div>
</div><p>
<a class="anchor" name="563c3a63fd0d2ebc54f079ff7c746a89"></a><!-- doxytag: member="CMultiXBuffer::Size" ref="563c3a63fd0d2ebc54f079ff7c746a89" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMultiXBuffer::Size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The allocated size of the underlying buffer. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="b512e2c0365e95f4cab4eaef48b6f1e9"></a><!-- doxytag: member="CMultiXBuffer::Length" ref="b512e2c0365e95f4cab4eaef48b6f1e9" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMultiXBuffer::Length           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The length of data stored in the underlying buffer. </dd></dl>

<p>

</div>
</div><p>
<a class="anchor" name="4aab0d6dbde2346da7a25133603b9b59"></a><!-- doxytag: member="CMultiXBuffer::DataPtr" ref="4aab0d6dbde2346da7a25133603b9b59" args="(int index=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char_t* CMultiXBuffer::DataPtr           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get read access to the data in the underlying buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The offset into the underlying buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a read only pointer to the underlying buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3238519ac41d55d4cf40c75f9c674d0e"></a><!-- doxytag: member="CMultiXBuffer::AppendData" ref="3238519ac41d55d4cf40c75f9c674d0e" args="(const char_t *Data, int Size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char_t* CMultiXBuffer::AppendData           </td>
          <td>(</td>
          <td class="paramtype">const char_t *&nbsp;</td>
          <td class="paramname"> <em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append the provided data to the underlying buffer. 
<p>
Use this function to append data to the underlying buffer. Before adding the data, MultiX expands the buffer and then it copies the data to the end of the buffer. During the entire process, the buffer is locked, and only the calling thread has write access to the buffer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>a pointer to the data to be added to the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Size</em>&nbsp;</td><td>the size of the data to be added. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a read only pointer to the new underlying buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e69c4160ab57c26578fbd22a110e5419"></a><!-- doxytag: member="CMultiXBuffer::AppendString" ref="e69c4160ab57c26578fbd22a110e5419" args="(const char_t *StringData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char_t* CMultiXBuffer::AppendString           </td>
          <td>(</td>
          <td class="paramtype">const char_t *&nbsp;</td>
          <td class="paramname"> <em>StringData</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append the provided string to the underlying buffer. 
<p>
Use this function to append string to the underlying buffer. Before adding the data, MultiX expands the buffer and then it copies the data to the end of the buffer. During the entire process, the buffer is locked, and only the calling thread has write access to the buffer. The size of the appended data includes the terminating null.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>StringData</em>&nbsp;</td><td>a pointer to the null terminated C string. If it is empty, a null byte is appended. If it is NULL, no data is appended. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a read only pointer to the new underlying buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7086802ec19f7814777972640ddabaad"></a><!-- doxytag: member="CMultiXBuffer::AppendBuffer" ref="7086802ec19f7814777972640ddabaad" args="(CMultiXBuffer &amp;Buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char_t* CMultiXBuffer::AppendBuffer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append the provided <a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> to the underlying buffer. 
<p>
Use this function to append a <a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> Data to the underlying buffer. Before adding the data, MultiX expands the buffer and then it copies the data to the end of the buffer. During the entire process, the buffer is locked, and only the calling thread has write access to the buffer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>a reference to an existing <a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a read only pointer to the new underlying buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3fa767fc792c89ea410260cd3ee8259"></a><!-- doxytag: member="CMultiXBuffer::operator&lt;&lt;=" ref="b3fa767fc792c89ea410260cd3ee8259" args="(int ShiftCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a>&amp; CMultiXBuffer::operator&lt;&lt;=           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ShiftCount</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift the content of the underlying buffer to the left. 
<p>
Use this function to shift the underlying buffer towards the begining of the buffer. the length of the buffer is adjusted accordingly. If ShiftCount is greater then the total length of the underlying buffer, the buffer becomes empty. During the entire process, the buffer is locked, and only the calling thread has write access to the buffer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ShiftCount</em>&nbsp;</td><td>The count of bytes to discard from the begining. The total length of the buffer is subtructed by this number. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a read only pointer to the new underlying buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="13464171f4a77ce9582b6d6c351bd218"></a><!-- doxytag: member="CMultiXBuffer::operator&gt;&gt;=" ref="13464171f4a77ce9582b6d6c351bd218" args="(int ShiftCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a>&amp; CMultiXBuffer::operator&gt;&gt;=           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ShiftCount</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift the content of the underlying buffer to the right. 
<p>
Use this function to shift the underlying buffer towards the end of the buffer. the length of the buffer is adjusted accordingly. If ShiftCount is greater then the total length of the underlying buffer, the buffer becomes empty. During the entire process, the buffer is locked, and only the calling thread has write access to the buffer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ShiftCount</em>&nbsp;</td><td>The count of bytes to add to the buffer. The total length of the buffer is incremented by this number. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a read only pointer to the new underlying buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="049fec9609d27ea69fe3a73de5af843a"></a><!-- doxytag: member="CMultiXBuffer::Empty" ref="049fec9609d27ea69fe3a73de5af843a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMultiXBuffer::Empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the content of the buffer and sets the length to zero. 
<p>

</div>
</div><p>
<a class="anchor" name="05edd78373da9136f92d45a07519e0c3"></a><!-- doxytag: member="CMultiXBuffer::operator==" ref="05edd78373da9136f92d45a07519e0c3" args="(CMultiXBuffer &amp;Other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CMultiXBuffer::operator==           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCMultiXBuffer.html">CMultiXBuffer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>Other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare the content of 2 buffers. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the content and length of the of the data is the same </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 16 22:16:20 2008 for MultiX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
