<html>
<head>
	<meta name="keywords" content="Application Server, SOAP, XML, Message Oriented Middleware, MOM, Distributed Processing, Application Level Router, POS, 
Point of Sale, Message Queue, Development, Developers, Projects, Downloads, OSTG, VA Software, SF.net, SourceForge, Web Services, ISO 8583, Transaction Processing Monitor, Open Source">
	<title>MultiXTpm Application Server</title>
	<style>
a
{
 font-weight: bold; 
}
</style>
</head>
<body alink="blue" bgcolor="lightyellow" lang="EN-US" link="blue" vlink="purple"><center>

		<script type="text/javascript"><!--
google_ad_client = "pub-4337232098909741";
/* 728x90, created 11/2/08 */
google_ad_slot = "6805685938";
google_ad_width = 728;
google_ad_height = 90;
//-->
		</script>

		<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
		</script>

	</center>
	<font face="Arial,Helvetica">
		<div style="text-align: center;">
			<table border="0" cellpadding="8" cellspacing="2">
				<tr>
					<td align="center">
						<a href="/">Home</a>
					</td>
				</tr>
				<tr>
					<td align="center">
						<h1 style="font-size: 30pt; color: orangered">
							MultiXTpm Application Server</h1>
						<h1 style="font-size: 30pt; color: orangered">
							Open Source/Free Software</h1>
					</td>
				</tr>
				<tr>
					<td align="left">
						<strong>MultiXTpm</strong> is an Application Server, Message Oriented Middleware
						(MOM) and Transaction Processing (TP) Monitor. It provides the runtime environment
						and rich API for developing large, scalable applications that are required to process
						online transactions originated from various types of computers and devices.
					</td>
				</tr>
				<tr>
					<td align="left">
						A <strong>MultiXTpm</strong> based system is built from various types of processes
						that run on one or more machines and communicate with each other using the provided
						API. Among other things, this API enables the developers to build systems that are
						based on multiple processes that communicate with each other, rather than build
						one monolithic program that does all processing of all types of activities.
					</td>
				</tr>
				<tr>
					<td align="left">
						As an Application Server and Message Oriented Middleware (MOM) in a Distributed
						Processing environment, <strong>MultiXTpm</strong> provides a system that is as
						open and flexible as it can be. <strong>MultiXTpm</strong> can provide services
						to all kinds of applications and hardware devices. It does not impose any restrictions
						or requirements on any part that is external to the main processes of the system.
						For example, if there is a requirement to connect a specific POS (Point of Sale)
						terminal to the system but it uses a specific protocol and data format, in that
						case <strong>MultiXTpm</strong> provides all the facilities and API to interact
						with that POS terminal, convert its data to an “understood” format and “inject”
						the data into the system as it was received from some other internal resource. This
						flexibility makes <strong>MultiXTpm</strong> the best solution for large scale systems
						that are required to support a wide range of devices and input methods. This is
						in opposite to all object oriented application servers that enforce the developers
						to use a single or maybe two input methods in order to interact with the main application
						server.
					</td>
				</tr>
				<tr>
					<td align="left">
						When it comes to connecting to legacy systems and proprietary applications or hardware
						controllers, <strong>MultiXTpm</strong> provides all the necessary services to:<br />
						<ul>
							<li>Act as a server to these systems, handle requests and provide responses to these
								requests.</li>
							<li>Act as a client to these systems by handling all the protocol and data conversions
								when sending requests and receiving responses.</li>
							<li>Act as an Application Level Router/Gateway/Connector between different systems</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td align="left">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							MultiXTpm Architecture
						</h2>
						<strong>MultiXTpm</strong> architecture is based on the idea that the entire runtime
						environment comprises of multiple processes of different types and purposes that
						communicate with each other using messages. In order to enable efficient use of
						resources and to enable each process handle as many requests as possible in a short
						time, <strong>MultiXTpm</strong> environment provides a special API that is implemented
						in a special DLL called <strong>MultiX</strong>. The <strong>MultiX</strong> API
						provides the framework for developing event driven processes where all inter process
						communications and communication related issues are handled by the <strong>MultiX</strong>
						DLL and are performed in a NO WAIT manner. This architecture enables a single process
						to handle many requests in a short time without the process needing to explicitly
						wait for the data to arrive and without wait for response to be actually sent. Since
						the application is event driven, <strong>MultiX</strong> is responsible for receiving
						the data buffers, assembling it into a logical message and notifying the application
						on the complete message. When a response needs to be sent, the application just
						issues a send request, regardless of the message size, and <strong>MultiX</strong>
						will send the message, one fragment after the other and at the end, it notifies
						the application on the success or failure of the send. During this whole time, the
						application may receive and process many other messages.
					</td>
				</tr>
				<tr>
					<td align="left">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							Compact and Modular Code</h2>
						Since <strong>MultiXTpm</strong> environment is built from many processes that communicate
						with each other, the designer of a given implementation is encouraged to build a
						system that comprises of many processes where each process has a well defined function
						in the system. This approach enables building a very modular system and a very efficient
						and scalable system. The fact that the system modularity is achieved thru multi
						processing makes the system very highly distributable and scalable. This architecture
						also makes it very easy to maintain and debug the modules. Small, functional processes
						are a lot easier to debug than large processes that are built from thousands of
						lines of code and it is easier than debugging a DLL that is part of a larger process.
					</td>
				</tr>
				<tr>
					<td align="left">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							Threading</h2>
						An application designed to run in <strong>MultiXTpm</strong> environment using the
						<strong>MultiX</strong> API, is usually built single threaded. While <strong>MultiX</strong>
						itself uses multithreading for processing its events, the application is usually
						written single threaded. The idea is that multi threading in the application layer
						is done to achieve concurrency and higher throughput, but in <strong>MultiXTpm</strong>
						environment these goals are achieved thru use of multi processing and not multi
						threading. In <strong>MultiXTpm</strong> environment it is <strong>MultiXTpm</strong>'s
						responsibility to launch instances of the same program when needed and stop these
						instances when the load gets low. This capability of <strong>MultiXTpm</strong>
						frees the developer from the burden of developing multithreaded applications. It
						also frees the designer of the application from the burden of building tools to
						load balance the system within one process (multi threads), within one machine (how
						many instances of a given process and when) and within a domain or a cluster (how
						many processes on each machines and when to launch them).<br />
						Never the less, if a developer chooses to use multiple threads for processing multiple
						requests simultaneously within the same process; <strong>MultiX</strong> API provides excellent threading
						support that fits within the entire architecture. A good example for using multiple
						threads within the same process for achieving better throughput can be found <a href="MultiXTpm gSoap Enhancer.htm">MultiXTpm
						gSoap Enhancer</a>
						where each service call is handled by different thread, allowing
						the main process doing other activities while the Web Service performs its own activities.
					</td>
				</tr>
				<tr>
					<td align="left" dir="ltr" style="height: 210px">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							MultiXTpm Processes</h2>
						When building an application for <strong>MultiXTpm</strong> environment we may define
						4 types of processes that can take part in a given system:
						<ul>
							<li><strong>MultiXTpm</strong> itself.</li>
							<li>Front End processes.</li>
							<li>Back End / Application / DB Server processes.</li>
							<li>Gateway / Converter / Adapter processes. </li>
						</ul>
					</td>
				</tr>
				<tr>
					<td align="left">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							MultiXTpm</h2>
						This process is the heart of the system and it is responsible for the following
						activities:
						<ul>
							<li>Processes Control - Control all other processes by means of starting, stopping
								or restarting them either automatically as required or manually as requested by
								operators.</li>
							<li>Process Configuration - Provide configuration information to the other processes
								when they start or when they get connected to <strong>MultiXTpm</strong>. </li>
							<li>Messages Routing - Route messages between all processes as dictated by the configuration
								information stored in its XML configuration file.</li>
							<li>Messages Queues Management - &nbsp;Since it acts as router and load balancer,
								<strong>MultiXTpm</strong> maintains a message queue for each group of processes
								and for each process in particular.</li>
							<li>Sessions Management - <strong>MultiX</strong> Sessions enable the sharing of a
								single context between multiple processes. This enables management of stateful objects
								at the application level. <strong>MultiXTpm</strong> has the knowledge on all existing
								sessions at any given time and it is responsible to notify all relevant processes
								when a member joins a session, when it leaves the session and when a session is
								terminated.</li>
							<li>Load Balance - <strong>MultiXTpm</strong> is responsible for load balancing of
								all activities between all processes so no one process can be overloaded while other
								processes are doing nothing. This load balancing crosses machine boundaries which
								makes the system scalable and can be balanced using unlimited number of machines.</li>
							<li>High Availability - <strong>MultiXTpm</strong>'s ability to distribute the processing
								between multiple processes and multiple machines makes the system highly available
								where no one application or machine can stop system operation.</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td align="left">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							Front End Processes</h2>
						Since <strong>MultiXTpm</strong> based applications communicate with each other
						using the <strong>MultiX</strong> API, there comes a time that there is a need to
						communicate with an application or a device that do not use the <strong>MultiX</strong>
						API. In such situation, a Front End Process is created. It has two logical end points,
						one to communicate with the non-<strong>MultiX</strong> device or application thru
						using some kind of protocol and data format and the other end point is to communicate
						with <strong>MultiXTpm</strong> and the other <strong>MultiX</strong> based processes.<br />
						A typical implementation of a Front End Process is as follows:<br />
						<ol>
							<li>The process is started, getting configuration from <strong>MultiXTpm</strong>.
							</li>
							<li>Listen on one or more ports for incoming connection (using the <strong>MultiX</strong>
								API).</li>
							<li>When a new connection is established, some hand shaking takes place.</li>
							<li>Receive some data from the remote end (thru the Event mechanism that is built
								into the <strong>MultiX</strong> API).</li>
							<li>Analyze the data and if the received data is not a complete message (application
								dependent) step 4 is performed again.</li>
							<li>When a complete message is received, it may convert the data to some internal
								format and forward it to <strong>MultiXTpm</strong> using the <strong>MultiX</strong>
								API for application level processing.</li>
							<li>At some point, a notification is received from <strong>MultiXTpm</strong> that
								there is a response for the request.</li>
							<li>The response may be converted to some other format and forwarded back to the remote
								end using the specific protocol and data format that is suitable for the remote
								end.</li>
							<li>The Front End Process may choose to disconnect the connection to the remote end
								or wait for another message, it is all implementation dependent. </li>
						</ol>
						Some typical scenarios for implementing Front End Processes are:
						<ul>
							<li>Communicating with devices like POS terminals that use some complicated protocol
								and data format, for example, a terminal that uses X28 for its protocol and ISO
								8583 for its data format.</li>
							<li>Communicating with legacy systems that interact with others by sending and receiving
								proprietary text or binary messages, for example, an IBM mainframe that runs CICS
								and can handle transactions sent and received in EBCDIC format.</li>
							<li>Interacting with hardware controllers that use proprietary protocol over a multidrop
								link (RS448) and represents multiple sub devices of different types.</li>
							<li>Acting as an XML Web Services server where it receives all the HTTP and SOAP data
								and forwards it to the actual application server to process the web service request.</li>
						</ul>
						<a href="http://wp.netscape.com/eng/ssl3/">Secured Socket Layer (SSL) Support<br />
						</a>
						<br />
						Since Front End Processes interact with external applications and devices, there
						might be a requirement for these interfaces to be secured. To fulfill this requirement,
						MultiXTpm Application Server provides SSL support using the <a href="http://www.openssl.org">
							OpenSSL</a> software package. Front End Processes make use of this capability
						provided by MultiXTpm Application Server. <a href="SSL_Support.htm">Read more about
							SSL Support</a>.<br />
						<br />
						In general, the idea of a Front End Process is that it handles interface issues
						related remote end applications or devices that do not use the <strong>MultiX</strong>
						API. It forwards the “normalized” message to some back-end/application process for
						the actual processing of the data. This is in contrast to implementing the interface/protocol/data
						conversion/data processing in a single process. This way, if more than one interface
						exists for a given service, only a Front End Process needs to be added/modified
						and the application that handle the data processing/business logic is not modified
						or touched at all.
					</td>
				</tr>
				<tr>
					<td align="left">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							Back End / Application / DB Server processes</h2>
						Back End processes are responsible for the actual processing of the requests and
						only that. When a new requests is received by a Back End Process, it assumes that
						the request is complete and contains all the data and partial message that needs
						to be gathered from fragments. A Back End Process has no knowledge on the mechanism
						used to deliver the request,what protocol was used or what transport used. The same
						is tru when a Back End Process send its responses to the sender. In <strong>MultiXTpm</strong>
						environment, it is possible for more than one Back End Process to receive a request
						that was forwarded from a Front End Process, each Back End Process can act differently
						on the same request. Usually, Back End Processes are not aware of the fact that
						other processes receiving the same message.<br />
						A typical implementation of a back end process is as follows:<br />
						<ol>
							<li>The process is started, getting configuration from <strong>MultiXTpm</strong>.
							</li>
							<li>Process may do some initialization like opening a database or some other activity
								and enter a wait state for incoming requests.</li>
							<li>At some point a new request is received, either from <strong>MultiXTpm</strong>
								or from some other <strong>MultiX</strong> based process, Front End Process for
								example.</li>
							<li>It processes the request and it may respond to the originator immediately or it
								may forward it to another process for additional processing.</li>
							<li>If the request was forwarded for additional processing, a response for that forwarding
								may arrive at some point and the entire response will be returned to the originator.</li>
							<li>The process returns to a wait for a new request.</li>
						</ol>
						In a Back End process, there is no connection establishment and termination with
						the outside world, it has an open connection with <strong>MultiXTpm</strong> and
						maybe with other processes controlled by <strong>MultiXTpm</strong>.<br />
						The idea of implementing a Back End Process is to help the developer separate the
						development of the business logic from all other issues.<br />
						Back End Processes take care only for pure application issues and not for anything
						else. Some typical scenarios for implementing Back End Processes are:
						<ul>
							<li>Credit Card Authorization process, this process receives some data regarding the
								credit card, it does not care how the data got there, it checks the credit card
								for validity and the database for eligibility and it responds with the appropriate
								answer. It might need to forward the request to some other service for authorization,
								in that case it forwards it (thru <strong>MultiXTpm</strong>) to another process
								that might interact with that other service and only when the entire response is
								received, it is forwarded to the originator.</li>
							<li>SOAP Web Service invocation server, this process receives some SOAP/XML formatted
								data, regardless of the source of the data, using some internal logic it invokes
								the appropriate function/DLL to parse, analyze and process the request, at the end,
								the SOAP/XML formatted response is forwarded to the originator. </li>
						</ul>
					</td>
				</tr>
				<tr>
					<td align="left">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							Gateway / Converter / Adapter processes</h2>
						Gateway Processes play almost the same role of Front End Processes except that they
						are logically located at the back end of the system. They are mainly used in cases
						where a request is originated at the front end side of the system, then forwarded
						to some Back End Process which in turn needs to forward the request to some external
						system for additional processing. In such scenario, the Gateway processes acts like
						a Back End Process by the fact that it receives its request from the internal processes,
						but on its other side it behaves like a Front End Process by the fact that it interacts
						with some external system using some specific protocol and data format.<br />
						The main difference between Front End Process and a Gateway Process is the origin
						of the request. In a Front End Process the request is originated from the remote
						non-<strong>MultiX</strong> end, then it is forwarded to an internal Back End Process
						and when a response is received from the Back End Process, it is sent back to the
						remote end. In a Gateway Process, the request is originated from some internal Back
						End or Front End Process, then when received by the Gateway Process, it is forwarded
						(and maybe converted) to some external non-<strong>MultiX</strong> remote end. When
						a response is received from the remote end, it is forwarded back to the internal
						Back End Process that originated the request.<br />
						Some typical scenarios for implementing Gateway processes are:<br />
						<ul>
							<li>In a credit card authorization, a local authorizing application might need to
								forward the authorization request to the credit card issuer for final authorization.</li>
							<li>In a security system, a service provider might receive some alert for a security
								event, after processing the event, there might be a need to escalate it and forward
								the event to another service provider for additional processing. </li>
						</ul>
					</td>
				</tr>
				<tr>
					<td align="left">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							Summary</h2>
						<strong>MultiXTpm Application Server</strong> a high availability, high throughput,
						scalable server for implementing messages based and service oriented systems. It
						is built to support large number of processes that can run on one or more machine
						and platform. It load balances the system thru using multiple processes and multiple
						machines. It can easily interact with third party systems and with various hardware
						devices that use a variety of protocols and data formats. Finally, it is open ended
						and can be customized to support any future requirements for interaction with external
						systems and improving internal mechanisms for load balancing and message forwarding.
					</td>
				</tr>
				<tr>
					<td align="left">
					</td>
				</tr>
				<tr>
					<td align="left">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							Download information</h2>
						<strong>MultiXTpm Application Server</strong> is free software; you can redistribute
						it and/or modify it under the terms of the <a href="http://www.gnu.org/copyleft/gpl.html">
							GNU General Public License</a> as published by the Free Software Foundation; either
						version 2 of the License, or (at your option) any later version.<br />
						<br />
						<strong>MultiXTpm Application Server</strong> is distributed in source code format
						and it supports: Windows OS, Linux, Solaris and HP Nonstop Server OSS.<br />
						<br />
						The source code is packed in ZIP file and can be downloaded from SourceForge.net.<br />
						<br />
						To Access the <a href="http://sourceforge.net/project/showfiles.php?group_id=196021"
							onclick="javascript:urchinTracker('/outgoing/DownloadPage');">Download Page</a>
						at SourceForge.net you may click <a href="http://sourceforge.net/project/showfiles.php?group_id=196021"
							onclick="javascript:urchinTracker('/outgoing/DownloadPage');">Here</a><br />
						or
						<br />
						Navigate to <a href="http://sourceforge.net/projects/multixtpm" onclick="javascript:urchinTracker('/outgoing/ProjectPage');">
							http://sourceforge.net/projects/multixtpm</a>
						<br />
					</td>
				</tr>
				<tr>
					<td align="left">
						<h2 style="text-align: center; text-decoration: underline; color: green;">
							Contact information</h2>
						For more information, Bug Reports, Feature Requests, and Support Requests, please
						use:
						<br />
						<a href="http://sourceforge.net/tracker/?group_id=196021" onclick="javascript:urchinTracker('/outgoing/TrackerPage');">
							SourceForge.net tracker</a>
						<br />
						or
						<br />
						<a href="http://sourceforge.net/forum/?group_id=196021" onclick="javascript:urchinTracker('/outgoing/ForumPage');">
							SourceForge.net Project Forums</a>
						<br />
						or
						<br />
						<a href="http://tech.groups.yahoo.com/group/multixtpm/" onclick="javascript:urchinTracker('/outgoing/YahooGroup');">
							MultiXTpm group at Yahoo Groups.</a>
						<br />
						or
						<br />
						you may send an email to: <a href="mailto:multixtpm@mitug.co.il" onclick="javascript:urchinTracker('/outgoing/Email');">
							Moshe Shitrit</a>
					</td>
				</tr>
				<tr>
					<td align="center">
						<a href="/">Home</a>
					</td>
				</tr>
			</table>
		</div>
	</font>

	<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
	</script>

	<script type="text/javascript">
	if(window.location.hostname	==	"www.mitug.co.il")
		_uacct = "UA-2084378-1";
	else
		_uacct = "UA-2084437-1";
urchinTracker();
	</script>

</body>
</html>
